{"ast":null,"code":"import { Md5 } from \"./md5.js\";\nimport { createRandomToken } from \"./utils.js\";\n\nfunction MD5(s) {\n  return Md5.hashStr(s);\n}\n/**\n * Digest Authentication.\n * @internal\n */\n\n\nexport class DigestAuthentication {\n  /**\n   * Constructor.\n   * @param loggerFactory - LoggerFactory.\n   * @param username - Username.\n   * @param password - Password.\n   */\n  constructor(loggerFactory, ha1, username, password) {\n    this.logger = loggerFactory.getLogger(\"sipjs.digestauthentication\");\n    this.username = username;\n    this.password = password;\n    this.ha1 = ha1;\n    this.nc = 0;\n    this.ncHex = \"00000000\";\n  }\n  /**\n   * Performs Digest authentication given a SIP request and the challenge\n   * received in a response to that request.\n   * @param request -\n   * @param challenge -\n   * @returns true if credentials were successfully generated, false otherwise.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  authenticate(request, challenge, body) {\n    // Inspect and validate the challenge.\n    this.algorithm = challenge.algorithm;\n    this.realm = challenge.realm;\n    this.nonce = challenge.nonce;\n    this.opaque = challenge.opaque;\n    this.stale = challenge.stale;\n\n    if (this.algorithm) {\n      if (this.algorithm !== \"MD5\") {\n        this.logger.warn(\"challenge with Digest algorithm different than 'MD5', authentication aborted\");\n        return false;\n      }\n    } else {\n      this.algorithm = \"MD5\";\n    }\n\n    if (!this.realm) {\n      this.logger.warn(\"challenge without Digest realm, authentication aborted\");\n      return false;\n    }\n\n    if (!this.nonce) {\n      this.logger.warn(\"challenge without Digest nonce, authentication aborted\");\n      return false;\n    } // 'qop' can contain a list of values (Array). Let's choose just one.\n\n\n    if (challenge.qop) {\n      if (challenge.qop.indexOf(\"auth\") > -1) {\n        this.qop = \"auth\";\n      } else if (challenge.qop.indexOf(\"auth-int\") > -1) {\n        this.qop = \"auth-int\";\n      } else {\n        // Otherwise 'qop' is present but does not contain 'auth' or 'auth-int', so abort here.\n        this.logger.warn(\"challenge without Digest qop different than 'auth' or 'auth-int', authentication aborted\");\n        return false;\n      }\n    } else {\n      this.qop = undefined;\n    } // Fill other attributes.\n\n\n    this.method = request.method;\n    this.uri = request.ruri;\n    this.cnonce = createRandomToken(12);\n    this.nc += 1;\n    this.updateNcHex(); // nc-value = 8LHEX. Max value = 'FFFFFFFF'.\n\n    if (this.nc === 4294967296) {\n      this.nc = 1;\n      this.ncHex = \"00000001\";\n    } // Calculate the Digest \"response\" value.\n\n\n    this.calculateResponse(body);\n    return true;\n  }\n  /**\n   * Return the Proxy-Authorization or WWW-Authorization header value.\n   */\n\n\n  toString() {\n    const authParams = [];\n\n    if (!this.response) {\n      throw new Error(\"response field does not exist, cannot generate Authorization header\");\n    }\n\n    authParams.push(\"algorithm=\" + this.algorithm);\n    authParams.push('username=\"' + this.username + '\"');\n    authParams.push('realm=\"' + this.realm + '\"');\n    authParams.push('nonce=\"' + this.nonce + '\"');\n    authParams.push('uri=\"' + this.uri + '\"');\n    authParams.push('response=\"' + this.response + '\"');\n\n    if (this.opaque) {\n      authParams.push('opaque=\"' + this.opaque + '\"');\n    }\n\n    if (this.qop) {\n      authParams.push(\"qop=\" + this.qop);\n      authParams.push('cnonce=\"' + this.cnonce + '\"');\n      authParams.push(\"nc=\" + this.ncHex);\n    }\n\n    return \"Digest \" + authParams.join(\", \");\n  }\n  /**\n   * Generate the 'nc' value as required by Digest in this.ncHex by reading this.nc.\n   */\n\n\n  updateNcHex() {\n    const hex = Number(this.nc).toString(16);\n    this.ncHex = \"00000000\".substr(0, 8 - hex.length) + hex;\n  }\n  /**\n   * Generate Digest 'response' value.\n   */\n\n\n  calculateResponse(body) {\n    let ha1, ha2; // HA1 = MD5(A1) = MD5(username:realm:password)\n\n    ha1 = this.ha1;\n\n    if (ha1 === \"\" || ha1 === undefined) {\n      ha1 = MD5(this.username + \":\" + this.realm + \":\" + this.password);\n    }\n\n    if (this.qop === \"auth\") {\n      // HA2 = MD5(A2) = MD5(method:digestURI)\n      ha2 = MD5(this.method + \":\" + this.uri); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)`\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth:\" + ha2);\n    } else if (this.qop === \"auth-int\") {\n      // HA2 = MD5(A2) = MD5(method:digestURI:MD5(entityBody))\n      ha2 = MD5(this.method + \":\" + this.uri + \":\" + MD5(body ? body : \"\")); // response = MD5(HA1:nonce:nonceCount:credentialsNonce:qop:HA2)\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + this.ncHex + \":\" + this.cnonce + \":auth-int:\" + ha2);\n    } else if (this.qop === undefined) {\n      // HA2 = MD5(A2) = MD5(method:digestURI)\n      ha2 = MD5(this.method + \":\" + this.uri); // response = MD5(HA1:nonce:HA2)\n\n      this.response = MD5(ha1 + \":\" + this.nonce + \":\" + ha2);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}