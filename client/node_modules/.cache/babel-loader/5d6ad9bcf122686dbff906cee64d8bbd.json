{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar WebSocket = require(\"ws\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\"); // tslint:disable-next-line\n\n\nvar Backoff = require('backoff');\n\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\nvar MAX_PREFERRED_DURATION = 15000;\nvar MAX_PRIMARY_DURATION = Infinity;\nvar MAX_PREFERRED_DELAY = 1000;\nvar MAX_PRIMARY_DELAY = 20000;\n/**\n * All possible states of WSTransport.\n */\n\nvar WSTransportState;\n\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\n\n\nvar WSTransport =\n/** @class */\nfunction (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n\n\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n\n\n    _this.state = WSTransportState.Closed;\n    /**\n     * Start timestamp values for backoffs.\n     */\n\n    _this._backoffStartTime = {\n      preferred: null,\n      primary: null\n    };\n    /**\n     * The URI that the transport is connecting or connected to. The value of this\n     * property is `null` if a connection attempt has not been made yet.\n     */\n\n    _this._connectedUri = null;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n\n\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason); // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n\n\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n\n        var wasConnected = // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open || // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open; // Only fallback if this is not the first error\n        // and if we were not connected previously\n\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n\n        _this._shouldFallback = true;\n      }\n\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n\n\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n\n\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout(); // Filter and respond to heartbeats\n\n\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n\n        return;\n      }\n\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n\n\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n\n      _this._setState(WSTransportState.Open);\n\n      clearTimeout(_this._connectTimeout);\n\n      _this._resetBackoffs();\n\n      _this._setHeartbeatTimeout();\n\n      _this.emit('open');\n    };\n\n    _this._options = __assign(__assign({}, WSTransport.defaultConstructorOptions), options);\n    _this._uris = uris;\n    _this._backoff = _this._setupBackoffs();\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n\n\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n\n      return;\n    }\n\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n\n\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n\n      this._closeSocket();\n\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n\n\n  WSTransport.prototype.updatePreferredURI = function (uri) {\n    this._preferredUri = uri;\n  };\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n\n\n  WSTransport.prototype.updateURIs = function (uris) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n\n    this._uris = uris;\n    this._uriIndex = 0;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n\n\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose);\n\n    this._socket.removeEventListener('error', this._onSocketError);\n\n    this._socket.removeEventListener('message', this._onSocketMessage);\n\n    this._socket.removeEventListener('open', this._onSocketOpen);\n\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    } // Reset backoff counter if connection was open for long enough to be considered successful\n\n\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n\n\n  WSTransport.prototype._connect = function (uri, retryCount) {\n    var _this = this;\n\n    this._log.info(typeof retryCount === 'number' ? \"Attempting to reconnect (retry #\" + retryCount + \")...\" : 'Attempting to connect...');\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n\n    this._connectedUri = uri;\n\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n\n      this._close();\n\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._connectedUri,\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n\n    this._socket.addEventListener('close', this._onSocketClose);\n\n    this._socket.addEventListener('error', this._onSocketError);\n\n    this._socket.addEventListener('message', this._onSocketMessage);\n\n    this._socket.addEventListener('open', this._onSocketOpen);\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n\n      _this._moveUriIndex();\n\n      _this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  };\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n\n\n  WSTransport.prototype._performBackoff = function () {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n\n      this._backoff.primary.backoff();\n    }\n  };\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n\n\n  WSTransport.prototype._resetBackoffs = function () {\n    this._backoff.preferred.reset();\n\n    this._backoff.primary.reset();\n\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n\n\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n\n      _this._shouldFallback = true;\n\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n\n\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n\n\n  WSTransport.prototype._setupBackoffs = function () {\n    var _this = this;\n\n    var preferredBackoffConfig = {\n      factor: 2.0,\n      maxDelay: this._options.maxPreferredDelayMs,\n      randomisationFactor: 0.40\n    };\n\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n\n    var preferredBackoff = Backoff.exponential(preferredBackoffConfig);\n    preferredBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect Websocket to preferred URI in \" + delay + \"ms\");\n\n      if (attempt === 0) {\n        _this._backoffStartTime.preferred = Date.now();\n\n        _this._log.info(\"Preferred backoff start; \" + _this._backoffStartTime.preferred);\n      }\n    });\n    preferredBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      if (_this._backoffStartTime.preferred === null) {\n        _this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n\n        return;\n      }\n\n      if (Date.now() - _this._backoffStartTime.preferred > _this._options.maxPreferredDurationMs) {\n        _this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n\n        _this._preferredUri = null;\n\n        _this._backoff.primary.backoff();\n\n        return;\n      }\n\n      if (typeof _this._preferredUri !== 'string') {\n        _this._log.info('Preferred URI cleared; falling back to primary backoff.');\n\n        _this._preferredUri = null;\n\n        _this._backoff.primary.backoff();\n\n        return;\n      }\n\n      _this._connect(_this._preferredUri, attempt + 1);\n    });\n    var primaryBackoffConfig = {\n      factor: 2.0,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay: this._uris && this._uris.length > 1 ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000 : 100,\n      maxDelay: this._options.maxPrimaryDelayMs,\n      randomisationFactor: 0.40\n    };\n\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n\n    var primaryBackoff = Backoff.exponential(primaryBackoffConfig);\n    primaryBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n\n      if (attempt === 0) {\n        _this._backoffStartTime.primary = Date.now();\n\n        _this._log.info(\"Primary backoff start; \" + _this._backoffStartTime.primary);\n      }\n    });\n    primaryBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      if (_this._backoffStartTime.primary === null) {\n        _this._log.info('Primary backoff start time invalid; not attempting a connection.');\n\n        return;\n      }\n\n      if (Date.now() - _this._backoffStartTime.primary > _this._options.maxPrimaryDurationMs) {\n        _this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n\n        return;\n      }\n\n      _this._connect(_this._uris[_this._uriIndex], attempt + 1);\n    });\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff\n    };\n  };\n\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._connectedUri;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  WSTransport.defaultConstructorOptions = {\n    WebSocket: WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION\n  };\n  return WSTransport;\n}(events_1.EventEmitter);\n\nexports.default = WSTransport;","map":{"version":3,"mappings":"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","names":["Backoff","require","CONNECT_SUCCESS_TIMEOUT","CONNECT_TIMEOUT","HEARTBEAT_TIMEOUT","MAX_PREFERRED_DURATION","MAX_PRIMARY_DURATION","Infinity","MAX_PREFERRED_DELAY","MAX_PRIMARY_DELAY","WSTransportState","exports","__extends","uris","options","_super","_this","Closed","preferred","primary","log_1","getInstance","_uriIndex","_uris","length","event","_log","info","code","reason","emit","message","twilioError","errors_1","ConnectionError","wasConnected","state","Open","_previousState","_shouldFallback","_moveUriIndex","_closeSocket","err","ConnectionDisconnected","_setHeartbeatTimeout","_socket","data","send","_timeOpened","Date","now","_setState","clearTimeout","_connectTimeout","_resetBackoffs","_options","__assign","WSTransport","defaultConstructorOptions","_backoff","_setupBackoffs","_close","readyState","WebSocket","CONNECTING","OPEN","_preferredUri","_connect","e","uri","_heartbeatTimeout","removeEventListener","_onSocketClose","_onSocketError","_onSocketMessage","_onSocketOpen","close","_performBackoff","retryCount","Connecting","_connectedUri","addEventListener","setTimeout","connectTimeoutMs","backoff","reset","_backoffStartTime","preferredBackoffConfig","factor","maxDelay","maxPreferredDelayMs","randomisationFactor","preferredBackoff","exponential","on","attempt","delay","_delay","maxPreferredDurationMs","primaryBackoffConfig","initialDelay","Math","floor","random","maxPrimaryDelayMs","primaryBackoff","maxPrimaryDurationMs","Object","events_1"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/wstransport.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\nconst MAX_PREFERRED_DURATION = 15000;\nconst MAX_PRIMARY_DURATION = Infinity;\nconst MAX_PREFERRED_DELAY = 1000;\nconst MAX_PRIMARY_DELAY = 20000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * The maximum delay for the preferred backoff to make a connection attempt.\n   */\n  maxPreferredDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPreferredDurationMs?: number;\n\n  /**\n   * The maximum delay for the rimary backoff to make a connection attempt.\n   */\n  maxPrimaryDelayMs?: number;\n\n  /**\n   * Max duration to attempt connecting to a preferred URI.\n   */\n  maxPrimaryDurationMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: typeof WebSocket;\n}\n\n/**\n * Type of the stored options property internally used by the WSTransport class.\n */\ntype IInternalWSTransportConstructorOptions = Required<IWSTransportConstructorOptions>;\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  private static defaultConstructorOptions: IInternalWSTransportConstructorOptions = {\n    WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION,\n  };\n\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: {\n    preferred: any;\n    primary: any;\n  };\n\n  /**\n   * Start timestamp values for backoffs.\n   */\n  private _backoffStartTime: {\n    preferred: number | null;\n    primary: number | null;\n  } = {\n    preferred: null,\n    primary: null,\n  };\n\n  /**\n   * The URI that the transport is connecting or connected to. The value of this\n   * property is `null` if a connection attempt has not been made yet.\n   */\n  private _connectedUri: string | null = null;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Options after missing values are defaulted.\n   */\n  private _options: IInternalWSTransportConstructorOptions;\n\n  /**\n   * Preferred URI endpoint to connect to.\n   */\n  private _preferredUri: string | null;\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private _uris: string[];\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._options = { ...WSTransport.defaultConstructorOptions, ...options };\n\n    this._uris = uris;\n\n    this._backoff = this._setupBackoffs();\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n  updatePreferredURI(uri: string | null) {\n    this._preferredUri = uri;\n  }\n\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n  updateURIs(uris: string[] | string) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n\n    this._uris = uris;\n    this._uriIndex = 0;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(uri: string, retryCount?: number): void {\n    this._log.info(\n      typeof retryCount === 'number'\n        ? `Attempting to reconnect (retry #${retryCount})...`\n        : 'Attempting to connect...',\n    );\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    this._connectedUri = uri;\n\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._connectedUri}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    this._socket.addEventListener('close', this._onSocketClose as any);\n    this._socket.addEventListener('error', this._onSocketError as any);\n    this._socket.addEventListener('message', this._onSocketMessage as any);\n    this._socket.addEventListener('open', this._onSocketOpen as any);\n\n    delete this._timeOpened;\n\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._resetBackoffs();\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n  private _performBackoff(): void {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n      this._backoff.primary.backoff();\n    }\n  }\n\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n  private _resetBackoffs() {\n    this._backoff.preferred.reset();\n    this._backoff.primary.reset();\n\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n  private _setupBackoffs(): typeof WSTransport.prototype._backoff {\n    const preferredBackoffConfig = {\n      factor: 2.0,\n      maxDelay: this._options.maxPreferredDelayMs,\n      randomisationFactor: 0.40,\n    };\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n    const preferredBackoff = Backoff.exponential(preferredBackoffConfig);\n\n    preferredBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect Websocket to preferred URI in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.preferred = Date.now();\n        this._log.info(`Preferred backoff start; ${this._backoffStartTime.preferred}`);\n      }\n    });\n\n    preferredBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.preferred === null) {\n        this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.preferred > this._options.maxPreferredDurationMs) {\n        this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      if (typeof this._preferredUri !== 'string') {\n        this._log.info('Preferred URI cleared; falling back to primary backoff.');\n        this._preferredUri = null;\n        this._backoff.primary.backoff();\n        return;\n      }\n      this._connect(this._preferredUri, attempt + 1);\n    });\n\n    const primaryBackoffConfig = {\n      factor: 2.0,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay: this._uris && this._uris.length > 1\n        ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000\n        : 100,\n      maxDelay: this._options.maxPrimaryDelayMs,\n      randomisationFactor: 0.40,\n    };\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n    const primaryBackoff = Backoff.exponential(primaryBackoffConfig);\n\n    primaryBackoff.on('backoff', (attempt: number, delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n        return;\n      }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n      if (attempt === 0) {\n        this._backoffStartTime.primary = Date.now();\n        this._log.info(`Primary backoff start; ${this._backoffStartTime.primary}`);\n      }\n    });\n\n    primaryBackoff.on('ready', (attempt: number, _delay: number) => {\n      if (this.state === WSTransportState.Closed) {\n        this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n        return;\n      }\n      if (this._backoffStartTime.primary === null) {\n        this._log.info('Primary backoff start time invalid; not attempting a connection.');\n        return;\n      }\n      if (Date.now() - this._backoffStartTime.primary > this._options.maxPrimaryDurationMs) {\n        this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n        return;\n      }\n      this._connect(this._uris[this._uriIndex], attempt + 1);\n    });\n\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff,\n    };\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string | null {\n    return this._connectedUri;\n  }\n}\n"]},"metadata":{},"sourceType":"script"}