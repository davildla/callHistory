{"ast":null,"code":"import { Grammar } from \"../../grammar/grammar.js\";\nimport { headerize } from \"./utils.js\";\n/**\n * Incoming message.\n * @public\n */\n\nexport class IncomingMessage {\n  constructor() {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    this.headers = {};\n  }\n  /**\n   * Insert a header of the given name and value into the last position of the\n   * header array.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  addHeader(name, value) {\n    const header = {\n      raw: value\n    };\n    name = headerize(name);\n\n    if (this.headers[name]) {\n      this.headers[name].push(header);\n    } else {\n      this.headers[name] = [header];\n    }\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   * @param name - header name\n   * @returns Returns the specified header, undefined if header doesn't exist.\n   */\n\n\n  getHeader(name) {\n    const header = this.headers[headerize(name)];\n\n    if (header) {\n      if (header[0]) {\n        return header[0].raw;\n      }\n    } else {\n      return;\n    }\n  }\n  /**\n   * Get the header/s of the given name.\n   * @param name - header name\n   * @returns Array - with all the headers of the specified name.\n   */\n\n\n  getHeaders(name) {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const header = this.headers[headerize(name)];\n    const result = [];\n\n    if (!header) {\n      return [];\n    }\n\n    for (const headerPart of header) {\n      result.push(headerPart.raw);\n    }\n\n    return result;\n  }\n  /**\n   * Verify the existence of the given header.\n   * @param name - header name\n   * @returns true if header with given name exists, false otherwise\n   */\n\n\n  hasHeader(name) {\n    return !!this.headers[headerize(name)];\n  }\n  /**\n   * Parse the given header on the given index.\n   * @param name - header name\n   * @param idx - header index\n   * @returns Parsed header object, undefined if the\n   *   header is not present or in case of a parsing error.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  parseHeader(name) {\n    let idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    name = headerize(name);\n\n    if (!this.headers[name]) {\n      // this.logger.log(\"header '\" + name + \"' not present\");\n      return;\n    } else if (idx >= this.headers[name].length) {\n      // this.logger.log(\"not so many '\" + name + \"' headers present\");\n      return;\n    }\n\n    const header = this.headers[name][idx];\n    const value = header.raw;\n\n    if (header.parsed) {\n      return header.parsed;\n    } // substitute '-' by '_' for grammar rule matching.\n\n\n    const parsed = Grammar.parse(value, name.replace(/-/g, \"_\"));\n\n    if (parsed === -1) {\n      this.headers[name].splice(idx, 1); // delete from headers\n      // this.logger.warn('error parsing \"' + name + '\" header field with value \"' + value + '\"');\n\n      return;\n    } else {\n      header.parsed = parsed;\n      return parsed;\n    }\n  }\n  /**\n   * Message Header attribute selector. Alias of parseHeader.\n   * @param name - header name\n   * @param idx - header index\n   * @returns Parsed header object, undefined if the\n   *   header is not present or in case of a parsing error.\n   *\n   * @example\n   * message.s('via',3).port\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  s(name) {\n    let idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    return this.parseHeader(name, idx);\n  }\n  /**\n   * Replace the value of the given header by the value.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  setHeader(name, value) {\n    this.headers[headerize(name)] = [{\n      raw: value\n    }];\n  }\n\n  toString() {\n    return this.data;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}