{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nvar C = require('./constants');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Log = require('./log').default;\n\nvar util = require('util');\n\nvar WSTransport = require('./wstransport').default;\n\nvar _require = require('./errors'),\n    GeneralErrors = _require.GeneralErrors,\n    SignalingErrors = _require.SignalingErrors;\n\nvar PSTREAM_VERSION = '1.5';\n/**\n * Constructor for PStream objects.\n *\n * @exports PStream as Twilio.PStream\n * @memberOf Twilio\n * @borrows EventEmitter#addListener as #addListener\n * @borrows EventEmitter#removeListener as #removeListener\n * @borrows EventEmitter#emit as #emit\n * @borrows EventEmitter#hasListener as #hasListener\n * @constructor\n * @param {string} token The Twilio capabilities JWT\n * @param {string[]} uris An array of PStream endpoint URIs\n * @param {object} [options]\n * @config {boolean} [options.backoffMaxMs=20000] Enable debugging\n */\n\nfunction PStream(token, uris, options) {\n  if (!(this instanceof PStream)) {\n    return new PStream(token, uris, options);\n  }\n\n  var defaults = {\n    TransportFactory: WSTransport\n  };\n  options = options || {};\n\n  for (var prop in defaults) {\n    if (prop in options) continue;\n    options[prop] = defaults[prop];\n  }\n\n  this.options = options;\n  this.token = token || '';\n  this.status = 'disconnected';\n  this.gateway = null;\n  this.region = null;\n  this._messageQueue = [];\n  this._uris = uris;\n  this._handleTransportClose = this._handleTransportClose.bind(this);\n  this._handleTransportError = this._handleTransportError.bind(this);\n  this._handleTransportMessage = this._handleTransportMessage.bind(this);\n  this._handleTransportOpen = this._handleTransportOpen.bind(this);\n  this._log = Log.getInstance(); // NOTE(mroberts): EventEmitter requires that we catch all errors.\n\n  this.on('error', function () {});\n  /*\n   *events used by device\n   *'invite',\n   *'ready',\n   *'error',\n   *'offline',\n   *\n   *'cancel',\n   *'presence',\n   *'roster',\n   *'answer',\n   *'candidate',\n   *'hangup'\n   */\n\n  var self = this;\n  this.addListener('ready', function () {\n    self.status = 'ready';\n  });\n  this.addListener('offline', function () {\n    self.status = 'offline';\n  });\n  this.addListener('close', function () {\n    self._log.info('Received \"close\" from server. Destroying PStream...');\n\n    self._destroy();\n  });\n  this.transport = new this.options.TransportFactory(this._uris, {\n    backoffMaxMs: this.options.backoffMaxMs\n  });\n  Object.defineProperties(this, {\n    uri: {\n      enumerable: true,\n      get: function get() {\n        return this.transport.uri;\n      }\n    }\n  });\n  this.transport.on('close', this._handleTransportClose);\n  this.transport.on('error', this._handleTransportError);\n  this.transport.on('message', this._handleTransportMessage);\n  this.transport.on('open', this._handleTransportOpen);\n  this.transport.open();\n  return this;\n}\n\nutil.inherits(PStream, EventEmitter);\n\nPStream.prototype._handleTransportClose = function () {\n  this.emit('transportClose');\n\n  if (this.status !== 'disconnected') {\n    if (this.status !== 'offline') {\n      this.emit('offline', this);\n    }\n\n    this.status = 'disconnected';\n  }\n};\n\nPStream.prototype._handleTransportError = function (error) {\n  if (!error) {\n    this.emit('error', {\n      error: {\n        code: 31000,\n        message: 'Websocket closed without a provided reason',\n        twilioError: new SignalingErrors.ConnectionDisconnected()\n      }\n    });\n    return;\n  } // We receive some errors without call metadata (just the error). We need to convert these\n  // to be contained within the 'error' field so that these errors match the expected format.\n\n\n  this.emit('error', typeof error.code !== 'undefined' ? {\n    error: error\n  } : error);\n};\n\nPStream.prototype._handleTransportMessage = function (msg) {\n  if (!msg || !msg.data || typeof msg.data !== 'string') {\n    return;\n  }\n\n  var _JSON$parse = JSON.parse(msg.data),\n      type = _JSON$parse.type,\n      _JSON$parse$payload = _JSON$parse.payload,\n      payload = _JSON$parse$payload === undefined ? {} : _JSON$parse$payload;\n\n  this.gateway = payload.gateway || this.gateway;\n  this.region = payload.region || this.region;\n\n  if (type === 'error' && payload.error) {\n    payload.error.twilioError = new SignalingErrors.ConnectionError();\n  }\n\n  this.emit(type, payload);\n};\n\nPStream.prototype._handleTransportOpen = function () {\n  var _this = this;\n\n  this.status = 'connected';\n  this.setToken(this.token);\n\n  var messages = this._messageQueue.splice(0, this._messageQueue.length);\n\n  messages.forEach(function (message) {\n    return _this._publish.apply(_this, _toConsumableArray(message));\n  });\n};\n/**\n * @return {string}\n */\n\n\nPStream.toString = function () {\n  return '[Twilio.PStream class]';\n};\n\nPStream.prototype.toString = function () {\n  return '[Twilio.PStream instance]';\n};\n\nPStream.prototype.setToken = function (token) {\n  this._log.info('Setting token and publishing listen');\n\n  this.token = token;\n  var payload = {\n    token: token,\n    browserinfo: getBrowserInfo()\n  };\n\n  this._publish('listen', payload);\n};\n\nPStream.prototype.register = function (mediaCapabilities) {\n  var regPayload = {\n    media: mediaCapabilities\n  };\n\n  this._publish('register', regPayload, true);\n};\n\nPStream.prototype.invite = function (sdp, callsid, preflight, params) {\n  var payload = {\n    callsid: callsid,\n    sdp: sdp,\n    preflight: !!preflight,\n    twilio: params ? {\n      params: params\n    } : {}\n  };\n\n  this._publish('invite', payload, true);\n};\n\nPStream.prototype.answer = function (sdp, callsid) {\n  this._publish('answer', {\n    sdp: sdp,\n    callsid: callsid\n  }, true);\n};\n\nPStream.prototype.dtmf = function (callsid, digits) {\n  this._publish('dtmf', {\n    callsid: callsid,\n    dtmf: digits\n  }, true);\n};\n\nPStream.prototype.hangup = function (callsid, message) {\n  var payload = message ? {\n    callsid: callsid,\n    message: message\n  } : {\n    callsid: callsid\n  };\n\n  this._publish('hangup', payload, true);\n};\n\nPStream.prototype.reject = function (callsid) {\n  this._publish('reject', {\n    callsid: callsid\n  }, true);\n};\n\nPStream.prototype.reinvite = function (sdp, callsid) {\n  this._publish('reinvite', {\n    sdp: sdp,\n    callsid: callsid\n  }, false);\n};\n\nPStream.prototype._destroy = function () {\n  this.transport.removeListener('close', this._handleTransportClose);\n  this.transport.removeListener('error', this._handleTransportError);\n  this.transport.removeListener('message', this._handleTransportMessage);\n  this.transport.removeListener('open', this._handleTransportOpen);\n  this.transport.close();\n  this.emit('offline', this);\n};\n\nPStream.prototype.destroy = function () {\n  this._log.info('PStream.destroy() called...');\n\n  this._destroy();\n\n  return this;\n};\n\nPStream.prototype.publish = function (type, payload) {\n  return this._publish(type, payload, true);\n};\n\nPStream.prototype._publish = function (type, payload, shouldRetry) {\n  var msg = JSON.stringify({\n    type: type,\n    version: PSTREAM_VERSION,\n    payload: payload\n  });\n  var isSent = !!this.transport.send(msg);\n\n  if (!isSent) {\n    this.emit('error', {\n      error: {\n        code: 31009,\n        message: 'No transport available to send or receive messages',\n        twilioError: new GeneralErrors.TransportError()\n      }\n    });\n\n    if (shouldRetry) {\n      this._messageQueue.push([type, payload, true]);\n    }\n  }\n};\n\nfunction getBrowserInfo() {\n  var nav = typeof navigator !== 'undefined' ? navigator : {};\n  var info = {\n    p: 'browser',\n    v: C.RELEASE_VERSION,\n    browser: {\n      userAgent: nav.userAgent || 'unknown',\n      platform: nav.platform || 'unknown'\n    },\n    plugin: 'rtc'\n  };\n  return info;\n}\n\nmodule.exports = PStream;","map":null,"metadata":{},"sourceType":"script"}