{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\n\nvar events_1 = require(\"events\");\n\nvar device_1 = require(\"./device\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar icecandidate_1 = require(\"./rtc/icecandidate\");\n\nvar statsMonitor_1 = require(\"./statsMonitor\");\n\nvar util_1 = require(\"./util\");\n\nvar Backoff = require('backoff');\n\nvar C = require('./constants');\n\nvar PeerConnection = require('./rtc').PeerConnection;\n\nvar getPreferredCodecInfo = require('./rtc/sdp').getPreferredCodecInfo;\n\nvar BACKOFF_CONFIG = {\n  factor: 1.1,\n  initialDelay: 1,\n  maxDelay: 30000,\n  randomisationFactor: 0.5\n};\nvar DTMF_INTER_TONE_GAP = 70;\nvar DTMF_PAUSE_DURATION = 500;\nvar DTMF_TONE_DURATION = 160;\nvar METRICS_BATCH_SIZE = 10;\nvar METRICS_DELAY = 5000;\nvar MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new errors_1.MediaErrors.ConnectionError()\n  }\n};\nvar MULTIPLE_THRESHOLD_WARNING_NAMES = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction'\n  }\n};\nvar WARNING_NAMES = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt'\n};\nvar WARNING_PREFIXES = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-'\n};\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\n\nvar Call =\n/** @class */\nfunction (_super) {\n  __extends(Call, _super);\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n\n\n  function Call(config, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Call parameters received from Twilio for an incoming call.\n     */\n\n\n    _this.parameters = {};\n    /**\n     * The number of times input volume has been the same consecutively.\n     */\n\n    _this._inputVolumeStreak = 0;\n    /**\n     * Whether the call has been answered.\n     */\n\n    _this._isAnswered = false;\n    /**\n     * Whether the call has been cancelled.\n     */\n\n    _this._isCancelled = false;\n    /**\n     * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n\n    _this._latestInputVolume = 0;\n    /**\n     * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n\n    _this._latestOutputVolume = 0;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * State of the {@link Call}'s media.\n     */\n\n    _this._mediaStatus = Call.State.Pending;\n    /**\n     * A batch of metrics samples to send to Insights. Gets cleared after\n     * each send and appended to on each new sample.\n     */\n\n    _this._metricsSamples = [];\n    /**\n     * Options passed to this {@link Call}.\n     */\n\n    _this._options = {\n      MediaHandler: PeerConnection,\n      offerSdp: null,\n      shouldPlayDisconnect: function () {\n        return true;\n      }\n    };\n    /**\n     * The number of times output volume has been the same consecutively.\n     */\n\n    _this._outputVolumeStreak = 0;\n    /**\n     * Whether the {@link Call} should send a hangup on disconnect.\n     */\n\n    _this._shouldSendHangup = true;\n    /**\n     * State of the {@link Call}'s signaling.\n     */\n\n    _this._signalingStatus = Call.State.Pending;\n    /**\n     * A Map of Sounds to play.\n     */\n\n    _this._soundcache = new Map();\n    /**\n     * State of the {@link Call}.\n     */\n\n    _this._status = Call.State.Pending;\n    /**\n     * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n     */\n\n    _this._wasConnected = false;\n    /**\n     * String representation of {@link Call} instance.\n     * @private\n     */\n\n    _this.toString = function () {\n      return '[Twilio.Call instance]';\n    };\n\n    _this._emitWarning = function (groupPrefix, warningName, threshold, value, wasCleared, warningData) {\n      var groupSuffix = wasCleared ? '-cleared' : '-raised';\n      var groupName = groupPrefix + \"warning\" + groupSuffix; // Ignore constant input if the Call is muted (Expected)\n\n      if (warningName === 'constant-audio-input-level' && _this.isMuted()) {\n        return;\n      }\n\n      var level = wasCleared ? 'info' : 'warning'; // Avoid throwing false positives as warnings until we refactor volume metrics\n\n      if (warningName === 'constant-audio-output-level') {\n        level = 'info';\n      }\n\n      var payloadData = {\n        threshold: threshold\n      };\n\n      if (value) {\n        if (value instanceof Array) {\n          payloadData.values = value.map(function (val) {\n            if (typeof val === 'number') {\n              return Math.round(val * 100) / 100;\n            }\n\n            return value;\n          });\n        } else {\n          payloadData.value = value;\n        }\n      }\n\n      _this._publisher.post(level, groupName, warningName, {\n        data: payloadData\n      }, _this);\n\n      if (warningName !== 'constant-audio-output-level') {\n        var emitName = wasCleared ? 'warning-cleared' : 'warning';\n\n        _this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n      }\n    };\n    /**\n     * Called when the {@link Call} is answered.\n     * @param payload\n     */\n\n\n    _this._onAnswer = function (payload) {\n      if (typeof payload.reconnect === 'string') {\n        _this._signalingReconnectToken = payload.reconnect;\n      } // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n      // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n      // the callee accepts the call firing a second `accept` event if we don't\n      // short circuit here.\n\n\n      if (_this._isAnswered && _this._status !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._setCallSid(payload);\n\n      _this._isAnswered = true;\n\n      _this._maybeTransitionToOpen();\n    };\n    /**\n     * Called when the {@link Call} is cancelled.\n     * @param payload\n     */\n\n\n    _this._onCancel = function (payload) {\n      // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n      var callsid = payload.callsid;\n\n      if (_this.parameters.CallSid === callsid) {\n        _this._isCancelled = true;\n\n        _this._publisher.info('connection', 'cancel', null, _this);\n\n        _this._cleanupEventListeners();\n\n        _this._mediaHandler.close();\n\n        _this._status = Call.State.Closed;\n\n        _this.emit('cancel');\n\n        _this._pstream.removeListener('cancel', _this._onCancel);\n      }\n    };\n    /**\n     * Called when we receive a connected event from pstream.\n     * Re-emits the event.\n     */\n\n\n    _this._onConnected = function () {\n      _this._log.info('Received connected from pstream');\n\n      if (_this._signalingReconnectToken) {\n        _this._pstream.reconnect(_this._mediaHandler.version.getSDP(), _this.parameters.CallSid, _this._signalingReconnectToken);\n      }\n    };\n    /**\n     * Called when the {@link Call} is hung up.\n     * @param payload\n     */\n\n\n    _this._onHangup = function (payload) {\n      if (_this.status() === Call.State.Closed) {\n        return;\n      }\n      /**\n       *  see if callsid passed in message matches either callsid or outbound id\n       *  call should always have either callsid or outbound id\n       *  if no callsid passed hangup anyways\n       */\n\n\n      if (payload.callsid && (_this.parameters.CallSid || _this.outboundConnectionId)) {\n        if (payload.callsid !== _this.parameters.CallSid && payload.callsid !== _this.outboundConnectionId) {\n          return;\n        }\n      } else if (payload.callsid) {\n        // hangup is for another call\n        return;\n      }\n\n      _this._log.info('Received HANGUP from gateway');\n\n      if (payload.error) {\n        var error = new errors_1.GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n\n        _this._log.error('Received an error from the gateway:', error);\n\n        _this.emit('error', error);\n      }\n\n      _this._shouldSendHangup = false;\n\n      _this._publisher.info('connection', 'disconnected-by-remote', null, _this);\n\n      _this._disconnect(null, true);\n\n      _this._cleanupEventListeners();\n    };\n    /**\n     * Called when there is a media failure.\n     * Manages all media-related states and takes action base on the states\n     * @param type - Type of media failure\n     */\n\n\n    _this._onMediaFailure = function (type) {\n      var _a = Call.MediaFailure,\n          ConnectionDisconnected = _a.ConnectionDisconnected,\n          ConnectionFailed = _a.ConnectionFailed,\n          IceGatheringFailed = _a.IceGatheringFailed,\n          LowBytes = _a.LowBytes; // These types signifies the end of a single ICE cycle\n\n      var isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed; // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n      // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n      // Since we cannot detect if ICE Restart is complete, we will not retry.\n\n      if (!util_1.isChrome(window, window.navigator) && type === ConnectionFailed) {\n        return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n      } // Ignore subsequent requests if ice restart is in progress\n\n\n      if (_this._mediaStatus === Call.State.Reconnecting) {\n        // This is a retry. Previous ICE Restart failed\n        if (isEndOfIceCycle) {\n          // We already exceeded max retry time.\n          if (Date.now() - _this._mediaReconnectStartTime > BACKOFF_CONFIG.maxDelay) {\n            _this._log.info('Exceeded max ICE retries');\n\n            return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n          } // Issue ICE restart with backoff\n\n\n          try {\n            _this._mediaReconnectBackoff.backoff();\n          } catch (error) {\n            // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n            // ongoing and we try to start another one, there shouldn't be a\n            // problem.\n            if (!(error.message && error.message === 'Backoff in progress.')) {\n              throw error;\n            }\n          }\n        }\n\n        return;\n      }\n\n      var pc = _this._mediaHandler.version.pc;\n      var isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n\n      var hasLowBytesWarning = _this._monitor.hasActiveWarning('bytesSent', 'min') || _this._monitor.hasActiveWarning('bytesReceived', 'min'); // Only certain conditions can trigger media reconnection\n\n\n      if (type === LowBytes && isIceDisconnected || type === ConnectionDisconnected && hasLowBytesWarning || isEndOfIceCycle) {\n        var mediaReconnectionError = new errors_1.MediaErrors.ConnectionError('Media connection failed.');\n\n        _this._log.warn('ICE Connection disconnected.');\n\n        _this._publisher.warn('connection', 'error', mediaReconnectionError, _this);\n\n        _this._publisher.info('connection', 'reconnecting', null, _this);\n\n        _this._mediaReconnectStartTime = Date.now();\n        _this._status = Call.State.Reconnecting;\n        _this._mediaStatus = Call.State.Reconnecting;\n\n        _this._mediaReconnectBackoff.reset();\n\n        _this._mediaReconnectBackoff.backoff();\n\n        _this.emit('reconnecting', mediaReconnectionError);\n      }\n    };\n    /**\n     * Called when media call is restored\n     */\n\n\n    _this._onMediaReconnected = function () {\n      // Only trigger once.\n      // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n      if (_this._mediaStatus !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._log.info('ICE Connection reestablished.');\n\n      _this._mediaStatus = Call.State.Open;\n\n      if (_this._signalingStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n\n        _this.emit('reconnected');\n\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * When we get a RINGING signal from PStream, update the {@link Call} status.\n     * @param payload\n     */\n\n\n    _this._onRinging = function (payload) {\n      _this._setCallSid(payload); // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n\n\n      if (_this._status !== Call.State.Connecting && _this._status !== Call.State.Ringing) {\n        return;\n      }\n\n      var hasEarlyMedia = !!payload.sdp;\n      _this._status = Call.State.Ringing;\n\n      _this._publisher.info('connection', 'outgoing-ringing', {\n        hasEarlyMedia: hasEarlyMedia\n      }, _this);\n\n      _this.emit('ringing', hasEarlyMedia);\n    };\n    /**\n     * Called each time StatsMonitor emits a sample.\n     * Emits stats event and batches the call stats metrics and sends them to Insights.\n     * @param sample\n     */\n\n\n    _this._onRTCSample = function (sample) {\n      var callMetrics = __assign(__assign({}, sample), {\n        inputVolume: _this._latestInputVolume,\n        outputVolume: _this._latestOutputVolume\n      });\n\n      _this._codec = callMetrics.codecName;\n\n      _this._metricsSamples.push(callMetrics);\n\n      if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n        _this._publishMetrics();\n      }\n\n      _this.emit('sample', sample);\n    };\n    /**\n     * Called when signaling is restored\n     */\n\n\n    _this._onSignalingReconnected = function () {\n      if (_this._signalingStatus !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._log.info('Signaling Connection reestablished.');\n\n      _this._signalingStatus = Call.State.Open;\n\n      if (_this._mediaStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n\n        _this.emit('reconnected');\n\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Called when we receive a transportClose event from pstream.\n     * Re-emits the event.\n     */\n\n\n    _this._onTransportClose = function () {\n      _this._log.error('Received transportClose from pstream');\n\n      _this.emit('transportClose');\n\n      if (_this._signalingReconnectToken) {\n        _this._status = Call.State.Reconnecting;\n        _this._signalingStatus = Call.State.Reconnecting;\n\n        _this.emit('reconnecting', new errors_1.SignalingErrors.ConnectionDisconnected());\n      } else {\n        _this._status = Call.State.Closed;\n        _this._signalingStatus = Call.State.Closed;\n      }\n    };\n    /**\n     * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n     * @param warningData\n     * @param wasCleared - Whether this is a -cleared or -raised event.\n     */\n\n\n    _this._reemitWarning = function (warningData, wasCleared) {\n      var groupPrefix = /^audio/.test(warningData.name) ? 'audio-level-' : 'network-quality-';\n      var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n      /**\n       * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n       * `high-packets-lost-fraction`, so in this case we need to use a different\n       * `WARNING_NAME` mapping.\n       */\n\n      var warningName;\n\n      if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n        warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n      } else if (warningData.name in WARNING_NAMES) {\n        warningName = WARNING_NAMES[warningData.name];\n      }\n\n      var warning = warningPrefix + warningName;\n\n      _this._emitWarning(groupPrefix, warning, warningData.threshold.value, warningData.values || warningData.value, wasCleared, warningData);\n    };\n    /**\n     * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n     * @param warningData\n     */\n\n\n    _this._reemitWarningCleared = function (warningData) {\n      _this._reemitWarning(warningData, true);\n    };\n\n    _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    _this._soundcache = config.soundcache;\n\n    if (typeof config.onIgnore === 'function') {\n      _this._onIgnore = config.onIgnore;\n    }\n\n    var message = options && options.twimlParams || {};\n    _this.customParameters = new Map(Object.entries(message).map(function (_a) {\n      var key = _a[0],\n          val = _a[1];\n      return [key, String(val)];\n    }));\n    Object.assign(_this._options, options);\n\n    if (_this._options.callParameters) {\n      _this.parameters = _this._options.callParameters;\n    }\n\n    if (_this._options.reconnectToken) {\n      _this._signalingReconnectToken = _this._options.reconnectToken;\n    }\n\n    _this._direction = _this.parameters.CallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n\n    if (_this._direction === Call.CallDirection.Incoming && _this.parameters) {\n      _this.callerInfo = _this.parameters.StirStatus ? {\n        isVerified: _this.parameters.StirStatus === 'TN-Validation-Passed-A'\n      } : null;\n    } else {\n      _this.callerInfo = null;\n    }\n\n    _this._mediaReconnectBackoff = Backoff.exponential(BACKOFF_CONFIG);\n\n    _this._mediaReconnectBackoff.on('ready', function () {\n      return _this._mediaHandler.iceRestart();\n    }); // temporary call sid to be used for outgoing calls\n\n\n    _this.outboundConnectionId = generateTempCallSid();\n    var publisher = _this._publisher = config.publisher;\n\n    if (_this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, _this);\n    } else {\n      publisher.info('connection', 'outgoing', {\n        preflight: _this._options.preflight\n      }, _this);\n    }\n\n    var monitor = _this._monitor = new (_this._options.StatsMonitor || statsMonitor_1.default)();\n    monitor.on('sample', _this._onRTCSample); // First 20 seconds or so are choppy, so let's not bother with these warnings.\n\n    monitor.disableWarnings();\n    setTimeout(function () {\n      return monitor.enableWarnings();\n    }, METRICS_DELAY);\n    monitor.on('warning', function (data, wasCleared) {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        _this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n\n      _this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', function (data) {\n      _this._reemitWarningCleared(data);\n    });\n    _this._mediaHandler = new _this._options.MediaHandler(config.audioHelper, config.pstream, config.getUserMedia, {\n      codecPreferences: _this._options.codecPreferences,\n      dscp: _this._options.dscp,\n      forceAggressiveIceNomination: _this._options.forceAggressiveIceNomination,\n      isUnifiedPlan: _this._isUnifiedPlanDefault,\n      maxAverageBitrate: _this._options.maxAverageBitrate,\n      preflight: _this._options.preflight\n    });\n\n    _this.on('volume', function (inputVolume, outputVolume) {\n      _this._inputVolumeStreak = _this._checkVolume(inputVolume, _this._inputVolumeStreak, _this._latestInputVolume, 'input');\n      _this._outputVolumeStreak = _this._checkVolume(outputVolume, _this._outputVolumeStreak, _this._latestOutputVolume, 'output');\n      _this._latestInputVolume = inputVolume;\n      _this._latestOutputVolume = outputVolume;\n    });\n\n    _this._mediaHandler.onvolume = function (inputVolume, outputVolume, internalInputVolume, internalOutputVolume) {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes(internalInputVolume / 255 * 32767, internalOutputVolume / 255 * 32767); // (rrowland) 0.0 -> 1.0 linear\n\n      _this.emit('volume', inputVolume, outputVolume);\n    };\n\n    _this._mediaHandler.ondtlstransportstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n\n      _this._publisher.post(level, 'dtls-transport-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onpcconnectionstatechange = function (state) {\n      var level = 'debug';\n\n      var dtlsTransport = _this._mediaHandler.getRTCDtlsTransport();\n\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n\n      _this._publisher.post(level, 'pc-connection-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onicecandidate = function (candidate) {\n      var payload = new icecandidate_1.IceCandidate(candidate).toPayload();\n\n      _this._publisher.debug('ice-candidate', 'ice-candidate', payload, _this);\n    };\n\n    _this._mediaHandler.onselectedcandidatepairchange = function (pair) {\n      var localCandidatePayload = new icecandidate_1.IceCandidate(pair.local).toPayload();\n      var remoteCandidatePayload = new icecandidate_1.IceCandidate(pair.remote, true).toPayload();\n\n      _this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload\n      }, _this);\n    };\n\n    _this._mediaHandler.oniceconnectionstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n\n      _this._publisher.post(level, 'ice-connection-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onicegatheringfailure = function (type) {\n      _this._publisher.warn('ice-gathering-state', type, null, _this);\n\n      _this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n\n    _this._mediaHandler.onicegatheringstatechange = function (state) {\n      _this._publisher.debug('ice-gathering-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onsignalingstatechange = function (state) {\n      _this._publisher.debug('signaling-state', state, null, _this);\n    };\n\n    _this._mediaHandler.ondisconnected = function (msg) {\n      _this._log.info(msg);\n\n      _this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n\n      _this.emit('warning', 'ice-connectivity-lost');\n\n      _this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n\n    _this._mediaHandler.onfailed = function (msg) {\n      _this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n\n    _this._mediaHandler.onconnected = function () {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (_this._status === Call.State.Reconnecting) {\n        _this._onMediaReconnected();\n      }\n    };\n\n    _this._mediaHandler.onreconnected = function (msg) {\n      _this._log.info(msg);\n\n      _this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n\n      _this.emit('warning-cleared', 'ice-connectivity-lost');\n\n      _this._onMediaReconnected();\n    };\n\n    _this._mediaHandler.onerror = function (e) {\n      if (e.disconnect === true) {\n        _this._disconnect(e.info && e.info.message);\n      }\n\n      var error = e.info.twilioError || new errors_1.GeneralErrors.UnknownError(e.info.message);\n\n      _this._log.error('Received an error from MediaStream:', e);\n\n      _this.emit('error', error);\n    };\n\n    _this._mediaHandler.onopen = function () {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (_this._status === Call.State.Open || _this._status === Call.State.Reconnecting) {\n        return;\n      } else if (_this._status === Call.State.Ringing || _this._status === Call.State.Connecting) {\n        _this.mute(false);\n\n        _this._mediaStatus = Call.State.Open;\n\n        _this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        _this._mediaHandler.close();\n      }\n    };\n\n    _this._mediaHandler.onclose = function () {\n      _this._status = Call.State.Closed;\n\n      if (_this._options.shouldPlayDisconnect && _this._options.shouldPlayDisconnect() // Don't play disconnect sound if this was from a cancel event. i.e. the call\n      // was ignored or hung up even before it was answered.\n      && !_this._isCancelled) {\n        _this._soundcache.get(device_1.default.SoundName.Disconnect).play();\n      }\n\n      monitor.disable();\n\n      _this._publishMetrics();\n\n      if (!_this._isCancelled) {\n        // tslint:disable no-console\n        _this.emit('disconnect', _this);\n      }\n    };\n\n    _this._pstream = config.pstream;\n\n    _this._pstream.on('cancel', _this._onCancel);\n\n    _this._pstream.on('ringing', _this._onRinging);\n\n    _this._pstream.on('transportClose', _this._onTransportClose);\n\n    _this._pstream.on('connected', _this._onConnected);\n\n    _this.on('error', function (error) {\n      _this._publisher.error('connection', 'error', {\n        code: error.code,\n        message: error.message\n      }, _this);\n\n      if (_this._pstream && _this._pstream.status === 'disconnected') {\n        _this._cleanupEventListeners();\n      }\n    });\n\n    _this.on('disconnect', function () {\n      _this._cleanupEventListeners();\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(Call.prototype, \"direction\", {\n    /**\n     * Whether this {@link Call} is incoming or outgoing.\n     */\n    get: function () {\n      return this._direction;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Call.prototype, \"codec\", {\n    /**\n     * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n     * will copy whatever we get from RTC stats.\n     */\n    get: function () {\n      return this._codec;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n\n  Call.prototype._setInputTracksFromStream = function (stream) {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  };\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n\n\n  Call.prototype._setSinkIds = function (sinkIds) {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  };\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n\n\n  Call.prototype.accept = function (options) {\n    var _this = this;\n\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    options = options || {};\n    var rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    var rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || {};\n    var audioConstraints = rtcConstraints.audio || {\n      audio: true\n    };\n    this._status = Call.State.Connecting;\n\n    var connect = function () {\n      if (_this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        _this._cleanupEventListeners();\n\n        _this._mediaHandler.close();\n\n        return;\n      }\n\n      var onAnswer = function (pc, reconnectToken) {\n        // Report that the call was answered, and directionality\n        var eventName = _this._direction === Call.CallDirection.Incoming ? 'accepted-by-local' : 'accepted-by-remote';\n\n        _this._publisher.info('connection', eventName, null, _this);\n\n        if (typeof reconnectToken === 'string') {\n          _this._signalingReconnectToken = reconnectToken;\n        } // Report the preferred codec and params as they appear in the SDP\n\n\n        var _a = getPreferredCodecInfo(_this._mediaHandler.version.getSDP()),\n            codecName = _a.codecName,\n            codecParams = _a.codecParams;\n\n        _this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName\n        }, _this); // Enable RTC monitoring\n\n\n        _this._monitor.enable(pc);\n      };\n\n      var sinkIds = typeof _this._options.getSinkIds === 'function' && _this._options.getSinkIds();\n\n      if (Array.isArray(sinkIds)) {\n        _this._mediaHandler._setSinkIds(sinkIds).catch(function () {// (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n\n      _this._pstream.addListener('hangup', _this._onHangup);\n\n      if (_this._direction === Call.CallDirection.Incoming) {\n        _this._isAnswered = true;\n\n        _this._pstream.on('answer', _this._onAnswer.bind(_this));\n\n        _this._mediaHandler.answerIncomingCall(_this.parameters.CallSid, _this._options.offerSdp, rtcConstraints, rtcConfiguration, onAnswer);\n      } else {\n        var params = Array.from(_this.customParameters.entries()).map(function (pair) {\n          return encodeURIComponent(pair[0]) + \"=\" + encodeURIComponent(pair[1]);\n        }).join('&');\n\n        _this._pstream.on('answer', _this._onAnswer.bind(_this));\n\n        _this._mediaHandler.makeOutgoingCall(_this._pstream.token, params, _this.outboundConnectionId, rtcConstraints, rtcConfiguration, onAnswer);\n      }\n    };\n\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n\n    var inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n\n    var promise = inputStream ? this._mediaHandler.setInputTracksFromStream(inputStream) : this._mediaHandler.openWithConstraints(audioConstraints);\n    promise.then(function () {\n      _this._publisher.info('get-user-media', 'succeeded', {\n        data: {\n          audioConstraints: audioConstraints\n        }\n      }, _this);\n\n      connect();\n    }, function (error) {\n      var twilioError;\n\n      if (error.code === 31208 || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new errors_1.UserMediaErrors.PermissionDeniedError();\n\n        _this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      } else {\n        twilioError = new errors_1.UserMediaErrors.AcquisitionFailedError();\n\n        _this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      }\n\n      _this._disconnect();\n\n      _this.emit('error', twilioError);\n    });\n  };\n  /**\n   * Disconnect from the {@link Call}.\n   */\n\n\n  Call.prototype.disconnect = function () {\n    this._disconnect();\n  };\n  /**\n   * Get the local MediaStream, if set.\n   */\n\n\n  Call.prototype.getLocalStream = function () {\n    return this._mediaHandler && this._mediaHandler.stream;\n  };\n  /**\n   * Get the remote MediaStream, if set.\n   */\n\n\n  Call.prototype.getRemoteStream = function () {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  };\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n\n\n  Call.prototype.ignore = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._status = Call.State.Closed;\n\n    this._mediaHandler.ignore(this.parameters.CallSid);\n\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  };\n  /**\n   * Check whether call is muted\n   */\n\n\n  Call.prototype.isMuted = function () {\n    return this._mediaHandler.isMuted;\n  };\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n\n\n  Call.prototype.mute = function (shouldMute) {\n    if (shouldMute === void 0) {\n      shouldMute = true;\n    }\n\n    var wasMuted = this._mediaHandler.isMuted;\n\n    this._mediaHandler.mute(shouldMute);\n\n    var isMuted = this._mediaHandler.isMuted;\n\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n\n      this.emit('mute', isMuted, this);\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n\n\n  Call.prototype.postFeedback = function (score, issue) {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback score must be one of: \" + Object.values(Call.FeedbackScore));\n    }\n\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback issue must be one of: \" + Object.values(Call.FeedbackIssue));\n    }\n\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score\n    }, this, true);\n  };\n  /**\n   * Reject the incoming {@link Call}.\n   */\n\n\n  Call.prototype.reject = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._pstream.reject(this.parameters.CallSid);\n\n    this._status = Call.State.Closed;\n    this.emit('reject');\n\n    this._mediaHandler.reject(this.parameters.CallSid);\n\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n  };\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n\n\n  Call.prototype.sendDigits = function (digits) {\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new errors_1.InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n\n    var sequence = [];\n    digits.split('').forEach(function (digit) {\n      var dtmf = digit !== 'w' ? \"dtmf\" + digit : '';\n\n      if (dtmf === 'dtmf*') {\n        dtmf = 'dtmfs';\n      }\n\n      if (dtmf === 'dtmf#') {\n        dtmf = 'dtmfh';\n      }\n\n      sequence.push(dtmf);\n    }); // Binds soundCache to be used in recursion until all digits have been played.\n\n    (function playNextDigit(soundCache, dialtonePlayer) {\n      var digit = sequence.shift();\n\n      if (digit) {\n        if (dialtonePlayer) {\n          dialtonePlayer.play(digit);\n        } else {\n          soundCache.get(digit).play();\n        }\n      }\n\n      if (sequence.length) {\n        setTimeout(playNextDigit.bind(null, soundCache), 200);\n      }\n    })(this._soundcache, this._options.dialtonePlayer);\n\n    var dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n\n    function insertDTMF(dtmfs) {\n      if (!dtmfs.length) {\n        return;\n      }\n\n      var dtmf = dtmfs.shift();\n\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender'); // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n\n\n        insertDTMF(digits.split('w'));\n        return;\n      }\n\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    } // send pstream message to send DTMF\n\n\n    this._log.info('Sending digits over PStream');\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      var error = new errors_1.GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this.emit('error', error);\n    }\n  };\n  /**\n   * Get the current {@link Call} status.\n   */\n\n\n  Call.prototype.status = function () {\n    return this._status;\n  };\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n\n\n  Call.prototype._checkVolume = function (currentVolume, currentStreak, lastValue, direction) {\n    var wasWarningRaised = currentStreak >= 10;\n    var newStreak = 0;\n\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, true);\n    }\n\n    return newStreak;\n  };\n  /**\n   * Clean up event listeners.\n   */\n\n\n  Call.prototype._cleanupEventListeners = function () {\n    var _this = this;\n\n    var cleanup = function () {\n      if (!_this._pstream) {\n        return;\n      }\n\n      _this._pstream.removeListener('answer', _this._onAnswer);\n\n      _this._pstream.removeListener('cancel', _this._onCancel);\n\n      _this._pstream.removeListener('hangup', _this._onHangup);\n\n      _this._pstream.removeListener('ringing', _this._onRinging);\n\n      _this._pstream.removeListener('transportClose', _this._onTransportClose);\n\n      _this._pstream.removeListener('connected', _this._onConnected);\n    }; // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n\n\n    cleanup();\n    setTimeout(cleanup, 0);\n  };\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n\n\n  Call.prototype._createMetricPayload = function () {\n    var payload = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: C.RELEASE_VERSION,\n      selected_region: this._options.selectedRegion\n    };\n\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n\n    if (this._options.region) {\n      payload.region = this._options.region;\n    }\n\n    payload.direction = this._direction;\n    return payload;\n  };\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n\n\n  Call.prototype._disconnect = function (message, wasRemote) {\n    message = typeof message === 'string' ? message : null;\n\n    if (this._status !== Call.State.Open && this._status !== Call.State.Connecting && this._status !== Call.State.Reconnecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    this._log.info('Disconnecting...'); // send pstream hangup message\n\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      var callsid = this.parameters.CallSid || this.outboundConnectionId;\n\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n\n    this._cleanupEventListeners();\n\n    this._mediaHandler.close();\n\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  };\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n\n\n  Call.prototype._maybeTransitionToOpen = function () {\n    var wasConnected = this._wasConnected;\n\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n\n      this._signalingStatus = Call.State.Open;\n\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this.emit('accept', this);\n        }\n      }\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n\n\n  Call.prototype._postFeedbackDeclined = function () {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  };\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n\n\n  Call.prototype._publishMetrics = function () {\n    var _this = this;\n\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n\n    this._publisher.postMetrics('quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this).catch(function (e) {\n      _this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  };\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n\n\n  Call.prototype._setCallSid = function (payload) {\n    var callSid = payload.callsid;\n\n    if (!callSid) {\n      return;\n    }\n\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  };\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n\n\n  Call.toString = function () {\n    return '[Twilio.Call class]';\n  };\n\n  return Call;\n}(events_1.EventEmitter);\n\n(function (Call) {\n  /**\n   * Possible states of the {@link Call}.\n   */\n  var State;\n\n  (function (State) {\n    State[\"Closed\"] = \"closed\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Open\"] = \"open\";\n    State[\"Pending\"] = \"pending\";\n    State[\"Reconnecting\"] = \"reconnecting\";\n    State[\"Ringing\"] = \"ringing\";\n  })(State = Call.State || (Call.State = {}));\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n\n\n  var FeedbackIssue;\n\n  (function (FeedbackIssue) {\n    FeedbackIssue[\"AudioLatency\"] = \"audio-latency\";\n    FeedbackIssue[\"ChoppyAudio\"] = \"choppy-audio\";\n    FeedbackIssue[\"DroppedCall\"] = \"dropped-call\";\n    FeedbackIssue[\"Echo\"] = \"echo\";\n    FeedbackIssue[\"NoisyCall\"] = \"noisy-call\";\n    FeedbackIssue[\"OneWayAudio\"] = \"one-way-audio\";\n  })(FeedbackIssue = Call.FeedbackIssue || (Call.FeedbackIssue = {}));\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n\n\n  var FeedbackScore;\n\n  (function (FeedbackScore) {\n    FeedbackScore[FeedbackScore[\"One\"] = 1] = \"One\";\n    FeedbackScore[FeedbackScore[\"Two\"] = 2] = \"Two\";\n    FeedbackScore[FeedbackScore[\"Three\"] = 3] = \"Three\";\n    FeedbackScore[FeedbackScore[\"Four\"] = 4] = \"Four\";\n    FeedbackScore[FeedbackScore[\"Five\"] = 5] = \"Five\";\n  })(FeedbackScore = Call.FeedbackScore || (Call.FeedbackScore = {}));\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n\n\n  var CallDirection;\n\n  (function (CallDirection) {\n    CallDirection[\"Incoming\"] = \"INCOMING\";\n    CallDirection[\"Outgoing\"] = \"OUTGOING\";\n  })(CallDirection = Call.CallDirection || (Call.CallDirection = {}));\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n\n\n  var Codec;\n\n  (function (Codec) {\n    Codec[\"Opus\"] = \"opus\";\n    Codec[\"PCMU\"] = \"pcmu\";\n  })(Codec = Call.Codec || (Call.Codec = {}));\n  /**\n   * Possible ICE Gathering failures\n   */\n\n\n  var IceGatheringFailureReason;\n\n  (function (IceGatheringFailureReason) {\n    IceGatheringFailureReason[\"None\"] = \"none\";\n    IceGatheringFailureReason[\"Timeout\"] = \"timeout\";\n  })(IceGatheringFailureReason = Call.IceGatheringFailureReason || (Call.IceGatheringFailureReason = {}));\n  /**\n   * Possible media failures\n   */\n\n\n  var MediaFailure;\n\n  (function (MediaFailure) {\n    MediaFailure[\"ConnectionDisconnected\"] = \"ConnectionDisconnected\";\n    MediaFailure[\"ConnectionFailed\"] = \"ConnectionFailed\";\n    MediaFailure[\"IceGatheringFailed\"] = \"IceGatheringFailed\";\n    MediaFailure[\"LowBytes\"] = \"LowBytes\";\n  })(MediaFailure = Call.MediaFailure || (Call.MediaFailure = {}));\n})(Call || (Call = {}));\n\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    /* tslint:disable:no-bitwise */\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    /* tslint:enable:no-bitwise */\n\n    return v.toString(16);\n  });\n}\n\nexports.default = Call; //# sourceMappingURL=call.js.map","map":null,"metadata":{},"sourceType":"script"}