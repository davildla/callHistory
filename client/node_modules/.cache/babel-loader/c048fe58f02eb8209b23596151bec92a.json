{"ast":null,"code":"import { Grammar } from \"../grammar/grammar.js\";\nimport { C } from \"../core/messages/methods/constants.js\";\nimport { SignalingState } from \"../core/session/session.js\";\nimport { getReasonPhrase, newTag } from \"../core/messages/utils.js\";\nimport { Session } from \"./session.js\";\nimport { SessionState } from \"./session-state.js\";\nimport { SIPExtension } from \"./user-agent-options.js\";\n/**\n * An inviter offers to establish a {@link Session} (outgoing INVITE).\n * @public\n */\n\nexport class Inviter extends Session {\n  /**\n   * Constructs a new instance of the `Inviter` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - Request URI identifying the target of the message.\n   * @param options - Options bucket. See {@link InviterOptions} for details.\n   */\n  constructor(userAgent, targetURI) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    super(userAgent, options);\n    /** True if dispose() has been called. */\n\n    this.disposed = false;\n    /** True if early media use is enabled. */\n\n    this.earlyMedia = false;\n    /** The early media session description handlers. */\n\n    this.earlyMediaSessionDescriptionHandlers = new Map();\n    /** True if cancel() was called. */\n\n    this.isCanceled = false;\n    /** True if initial INVITE without SDP. */\n\n    this.inviteWithoutSdp = false;\n    this.logger = userAgent.getLogger(\"sip.Inviter\"); // Early media\n\n    this.earlyMedia = options.earlyMedia !== undefined ? options.earlyMedia : this.earlyMedia; // From tag\n\n    this.fromTag = newTag(); // Invite without SDP\n\n    this.inviteWithoutSdp = options.inviteWithoutSdp !== undefined ? options.inviteWithoutSdp : this.inviteWithoutSdp; // Inviter options (could do better copying these options)\n\n    const inviterOptions = Object.assign({}, options);\n    inviterOptions.params = Object.assign({}, options.params); // Anonymous call\n\n    const anonymous = options.anonymous || false; // Contact\n\n    const contact = userAgent.contact.toString({\n      anonymous,\n      // Do not add ;ob in initial forming dialog requests if the\n      // registration over the current connection got a GRUU URI.\n      outbound: anonymous ? !userAgent.contact.tempGruu : !userAgent.contact.pubGruu\n    }); // FIXME: TODO: We should not be parsing URIs here as if it fails we have to throw an exception\n    // which is not something we want our constructor to do. URIs should be passed in as params.\n    // URIs\n\n    if (anonymous && userAgent.configuration.uri) {\n      inviterOptions.params.fromDisplayName = \"Anonymous\";\n      inviterOptions.params.fromUri = \"sip:anonymous@anonymous.invalid\";\n    }\n\n    let fromURI = userAgent.userAgentCore.configuration.aor;\n\n    if (inviterOptions.params.fromUri) {\n      fromURI = typeof inviterOptions.params.fromUri === \"string\" ? Grammar.URIParse(inviterOptions.params.fromUri) : inviterOptions.params.fromUri;\n    }\n\n    if (!fromURI) {\n      throw new TypeError(\"Invalid from URI: \" + inviterOptions.params.fromUri);\n    }\n\n    let toURI = targetURI;\n\n    if (inviterOptions.params.toUri) {\n      toURI = typeof inviterOptions.params.toUri === \"string\" ? Grammar.URIParse(inviterOptions.params.toUri) : inviterOptions.params.toUri;\n    }\n\n    if (!toURI) {\n      throw new TypeError(\"Invalid to URI: \" + inviterOptions.params.toUri);\n    } // Params\n\n\n    const messageOptions = Object.assign({}, inviterOptions.params);\n    messageOptions.fromTag = this.fromTag; // Extra headers\n\n    const extraHeaders = (inviterOptions.extraHeaders || []).slice();\n\n    if (anonymous && userAgent.configuration.uri) {\n      extraHeaders.push(\"P-Preferred-Identity: \" + userAgent.configuration.uri.toString());\n      extraHeaders.push(\"Privacy: id\");\n    }\n\n    extraHeaders.push(\"Contact: \" + contact);\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n\n    if (userAgent.configuration.sipExtension100rel === SIPExtension.Required) {\n      extraHeaders.push(\"Require: 100rel\");\n    }\n\n    if (userAgent.configuration.sipExtensionReplaces === SIPExtension.Required) {\n      extraHeaders.push(\"Require: replaces\");\n    }\n\n    inviterOptions.extraHeaders = extraHeaders; // Body\n\n    const body = undefined; // Make initial outgoing request message\n\n    this.outgoingRequestMessage = userAgent.userAgentCore.makeOutgoingRequestMessage(C.INVITE, targetURI, fromURI, toURI, messageOptions, extraHeaders, body); // Session parent properties\n\n    this._contact = contact;\n    this._referralInviterOptions = inviterOptions;\n    this._renderbody = options.renderbody;\n    this._rendertype = options.rendertype; // Modifiers and options for initial INVITE transaction\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // Modifiers and options for re-INVITE transactions\n\n\n    if (options.sessionDescriptionHandlerModifiersReInvite) {\n      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiersReInvite;\n    }\n\n    if (options.sessionDescriptionHandlerOptionsReInvite) {\n      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptionsReInvite;\n    } // Identifier\n\n\n    this._id = this.outgoingRequestMessage.callId + this.fromTag; // Add to the user agent's session collection.\n\n    this.userAgent._sessions[this._id] = this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    // Only run through this once. It can and does get called multiple times\n    // depending on the what the sessions state is when first called.\n    // For example, if called when \"establishing\" it will be called again\n    // at least once when the session transitions to \"terminated\".\n    // Regardless, running through this more than once is pointless.\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true; // Dispose of early dialog media\n\n    this.disposeEarlyMedia(); // If the final response for the initial INVITE not yet been received, cancel it\n\n    switch (this.state) {\n      case SessionState.Initial:\n        return this.cancel().then(() => super.dispose());\n\n      case SessionState.Establishing:\n        return this.cancel().then(() => super.dispose());\n\n      case SessionState.Established:\n        return super.dispose();\n\n      case SessionState.Terminating:\n        return super.dispose();\n\n      case SessionState.Terminated:\n        return super.dispose();\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n  }\n  /**\n   * Initial outgoing INVITE request message body.\n   */\n\n\n  get body() {\n    return this.outgoingRequestMessage.body;\n  }\n  /**\n   * The identity of the local user.\n   */\n\n\n  get localIdentity() {\n    return this.outgoingRequestMessage.from;\n  }\n  /**\n   * The identity of the remote user.\n   */\n\n\n  get remoteIdentity() {\n    return this.outgoingRequestMessage.to;\n  }\n  /**\n   * Initial outgoing INVITE request message.\n   */\n\n\n  get request() {\n    return this.outgoingRequestMessage;\n  }\n  /**\n   * Cancels the INVITE request.\n   *\n   * @remarks\n   * Sends a CANCEL request.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * After sending a CANCEL request the expectation is that a 487 final response\n   * will be received for the INVITE. However a 200 final response to the INVITE\n   * may nonetheless arrive (it's a race between the CANCEL reaching the UAS before\n   * the UAS sends a 200) in which case an ACK & BYE will be sent. The net effect\n   * is that this method will terminate the session regardless of the race.\n   * @param options - Options bucket.\n   */\n\n\n  cancel() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Inviter.cancel\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // flag canceled\n\n\n    this.isCanceled = true; // transition state\n\n    this.stateTransition(SessionState.Terminating); // helper function\n\n    function getCancelReason(code, reason) {\n      if (code && code < 200 || code > 699) {\n        throw new TypeError(\"Invalid statusCode: \" + code);\n      } else if (code) {\n        const cause = code;\n        const text = getReasonPhrase(code) || reason;\n        return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n      }\n    }\n\n    if (this.outgoingInviteRequest) {\n      // the CANCEL may not be respected by peer(s), so don't transition to terminated\n      let cancelReason;\n\n      if (options.statusCode && options.reasonPhrase) {\n        cancelReason = getCancelReason(options.statusCode, options.reasonPhrase);\n      }\n\n      this.outgoingInviteRequest.cancel(cancelReason, options);\n    } else {\n      this.logger.warn(\"Canceled session before INVITE was sent\");\n      this.stateTransition(SessionState.Terminated);\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Sends the INVITE request.\n   *\n   * @remarks\n   * TLDR...\n   *  1) Only one offer/answer exchange permitted during initial INVITE.\n   *  2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n   *  3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n   *\n   * 1) Only one offer/answer exchange permitted during initial INVITE.\n   *\n   * Our implementation replaces the following bullet point...\n   *\n   * o  After having sent or received an answer to the first offer, the\n   *    UAC MAY generate subsequent offers in requests based on rules\n   *    specified for that method, but only if it has received answers\n   *    to any previous offers, and has not sent any offers to which it\n   *    hasn't gotten an answer.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * ...with...\n   *\n   * o  After having sent or received an answer to the first offer, the\n   *    UAC MUST NOT generate subsequent offers in requests based on rules\n   *    specified for that method.\n   *\n   * ...which in combination with this bullet point...\n   *\n   * o  Once the UAS has sent or received an answer to the initial\n   *    offer, it MUST NOT generate subsequent offers in any responses\n   *    to the initial INVITE.  This means that a UAS based on this\n   *    specification alone can never generate subsequent offers until\n   *    completion of the initial transaction.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * ...ensures that EXACTLY ONE offer/answer exchange will occur\n   * during an initial out of dialog INVITE request made by our UAC.\n   *\n   *\n   * 2) No \"early media\" if the initial offer is in an INVITE (default behavior).\n   *\n   * While our implementation adheres to the following bullet point...\n   *\n   * o  If the initial offer is in an INVITE, the answer MUST be in a\n   *    reliable non-failure message from UAS back to UAC which is\n   *    correlated to that INVITE.  For this specification, that is\n   *    only the final 2xx response to that INVITE.  That same exact\n   *    answer MAY also be placed in any provisional responses sent\n   *    prior to the answer.  The UAC MUST treat the first session\n   *    description it receives as the answer, and MUST ignore any\n   *    session descriptions in subsequent responses to the initial\n   *    INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   *\n   * We have made the following implementation decision with regard to early media...\n   *\n   * o  If the initial offer is in the INVITE, the answer from the\n   *    UAS back to the UAC will establish a media session only\n   *    only after the final 2xx response to that INVITE is received.\n   *\n   * The reason for this decision is rooted in a restriction currently\n   * inherent in WebRTC. Specifically, while a SIP INVITE request with an\n   * initial offer may fork resulting in more than one provisional answer,\n   * there is currently no easy/good way to to \"fork\" an offer generated\n   * by a peer connection. In particular, a WebRTC offer currently may only\n   * be matched with one answer and we have no good way to know which\n   * \"provisional answer\" is going to be the \"final answer\". So we have\n   * decided to punt and not create any \"early media\" sessions in this case.\n   *\n   * The upshot is that if you want \"early media\", you must not put the\n   * initial offer in the INVITE. Instead, force the UAS to provide the\n   * initial offer by sending an INVITE without an offer. In the WebRTC\n   * case this allows us to create a unique peer connection with a unique\n   * answer for every provisional offer with \"early media\" on all of them.\n   *\n   *\n   * 3) If \"early media\" and the initial offer is in an INVITE, no INVITE forking.\n   *\n   * The default behavior may be altered and \"early media\" utilized if the\n   * initial offer is in the an INVITE by setting the `earlyMedia` options.\n   * However in that case the INVITE request MUST NOT fork. This allows for\n   * \"early media\" in environments where the forking behavior of the SIP\n   * servers being utilized is configured to disallow forking.\n   */\n\n\n  invite() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Inviter.invite\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      // re-invite\n      return super.invite(options);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // just send an INVITE with no sdp...\n\n\n    if (options.withoutSdp || this.inviteWithoutSdp) {\n      if (this._renderbody && this._rendertype) {\n        this.outgoingRequestMessage.body = {\n          contentType: this._rendertype,\n          body: this._renderbody\n        };\n      } // transition state\n\n\n      this.stateTransition(SessionState.Establishing);\n      return Promise.resolve(this.sendInvite(options));\n    } // get an offer and send it in an INVITE\n\n\n    const offerOptions = {\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n    };\n    return this.getOffer(offerOptions).then(body => {\n      this.outgoingRequestMessage.body = {\n        body: body.content,\n        contentType: body.contentType\n      }; // transition state\n\n      this.stateTransition(SessionState.Establishing);\n      return this.sendInvite(options);\n    }).catch(error => {\n      this.logger.log(error.message); // It's possible we are already terminated,\n      // so don't throw trying to transition again.\n\n      if (this.state !== SessionState.Terminated) {\n        this.stateTransition(SessionState.Terminated);\n      }\n\n      throw error;\n    });\n  }\n  /**\n   * 13.2.1 Creating the Initial INVITE\n   *\n   * Since the initial INVITE represents a request outside of a dialog,\n   * its construction follows the procedures of Section 8.1.1.  Additional\n   * processing is required for the specific case of INVITE.\n   *\n   * An Allow header field (Section 20.5) SHOULD be present in the INVITE.\n   * It indicates what methods can be invoked within a dialog, on the UA\n   * sending the INVITE, for the duration of the dialog.  For example, a\n   * UA capable of receiving INFO requests within a dialog [34] SHOULD\n   * include an Allow header field listing the INFO method.\n   *\n   * A Supported header field (Section 20.37) SHOULD be present in the\n   * INVITE.  It enumerates all the extensions understood by the UAC.\n   *\n   * An Accept (Section 20.1) header field MAY be present in the INVITE.\n   * It indicates which Content-Types are acceptable to the UA, in both\n   * the response received by it, and in any subsequent requests sent to\n   * it within dialogs established by the INVITE.  The Accept header field\n   * is especially useful for indicating support of various session\n   * description formats.\n   *\n   * The UAC MAY add an Expires header field (Section 20.19) to limit the\n   * validity of the invitation.  If the time indicated in the Expires\n   * header field is reached and no final answer for the INVITE has been\n   * received, the UAC core SHOULD generate a CANCEL request for the\n   * INVITE, as per Section 9.\n   *\n   * A UAC MAY also find it useful to add, among others, Subject (Section\n   * 20.36), Organization (Section 20.25) and User-Agent (Section 20.41)\n   * header fields.  They all contain information related to the INVITE.\n   *\n   * The UAC MAY choose to add a message body to the INVITE.  Section\n   * 8.1.1.10 deals with how to construct the header fields -- Content-\n   * Type among others -- needed to describe the message body.\n   *\n   * https://tools.ietf.org/html/rfc3261#section-13.2.1\n   */\n\n\n  sendInvite() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    //    There are special rules for message bodies that contain a session\n    //    description - their corresponding Content-Disposition is \"session\".\n    //    SIP uses an offer/answer model where one UA sends a session\n    //    description, called the offer, which contains a proposed description\n    //    of the session.  The offer indicates the desired communications means\n    //    (audio, video, games), parameters of those means (such as codec\n    //    types) and addresses for receiving media from the answerer.  The\n    //    other UA responds with another session description, called the\n    //    answer, which indicates which communications means are accepted, the\n    //    parameters that apply to those means, and addresses for receiving\n    //    media from the offerer. An offer/answer exchange is within the\n    //    context of a dialog, so that if a SIP INVITE results in multiple\n    //    dialogs, each is a separate offer/answer exchange.  The offer/answer\n    //    model defines restrictions on when offers and answers can be made\n    //    (for example, you cannot make a new offer while one is in progress).\n    //    This results in restrictions on where the offers and answers can\n    //    appear in SIP messages.  In this specification, offers and answers\n    //    can only appear in INVITE requests and responses, and ACK.  The usage\n    //    of offers and answers is further restricted.  For the initial INVITE\n    //    transaction, the rules are:\n    //\n    //       o  The initial offer MUST be in either an INVITE or, if not there,\n    //          in the first reliable non-failure message from the UAS back to\n    //          the UAC.  In this specification, that is the final 2xx\n    //          response.\n    //\n    //       o  If the initial offer is in an INVITE, the answer MUST be in a\n    //          reliable non-failure message from UAS back to UAC which is\n    //          correlated to that INVITE.  For this specification, that is\n    //          only the final 2xx response to that INVITE.  That same exact\n    //          answer MAY also be placed in any provisional responses sent\n    //          prior to the answer.  The UAC MUST treat the first session\n    //          description it receives as the answer, and MUST ignore any\n    //          session descriptions in subsequent responses to the initial\n    //          INVITE.\n    //\n    //       o  If the initial offer is in the first reliable non-failure\n    //          message from the UAS back to UAC, the answer MUST be in the\n    //          acknowledgement for that message (in this specification, ACK\n    //          for a 2xx response).\n    //\n    //       o  After having sent or received an answer to the first offer, the\n    //          UAC MAY generate subsequent offers in requests based on rules\n    //          specified for that method, but only if it has received answers\n    //          to any previous offers, and has not sent any offers to which it\n    //          hasn't gotten an answer.\n    //\n    //       o  Once the UAS has sent or received an answer to the initial\n    //          offer, it MUST NOT generate subsequent offers in any responses\n    //          to the initial INVITE.  This means that a UAS based on this\n    //          specification alone can never generate subsequent offers until\n    //          completion of the initial transaction.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n    // 5 The Offer/Answer Model and PRACK\n    //\n    //    RFC 3261 describes guidelines for the sets of messages in which\n    //    offers and answers [3] can appear.  Based on those guidelines, this\n    //    extension provides additional opportunities for offer/answer\n    //    exchanges.\n    //    If the INVITE contained an offer, the UAS MAY generate an answer in a\n    //    reliable provisional response (assuming these are supported by the\n    //    UAC).  That results in the establishment of the session before\n    //    completion of the call.  Similarly, if a reliable provisional\n    //    response is the first reliable message sent back to the UAC, and the\n    //    INVITE did not contain an offer, one MUST appear in that reliable\n    //    provisional response.\n    //    If the UAC receives a reliable provisional response with an offer\n    //    (this would occur if the UAC sent an INVITE without an offer, in\n    //    which case the first reliable provisional response will contain the\n    //    offer), it MUST generate an answer in the PRACK.  If the UAC receives\n    //    a reliable provisional response with an answer, it MAY generate an\n    //    additional offer in the PRACK.  If the UAS receives a PRACK with an\n    //    offer, it MUST place the answer in the 2xx to the PRACK.\n    //    Once an answer has been sent or received, the UA SHOULD establish the\n    //    session based on the parameters of the offer and answer, even if the\n    //    original INVITE itself has not been responded to.\n    //    If the UAS had placed a session description in any reliable\n    //    provisional response that is unacknowledged when the INVITE is\n    //    accepted, the UAS MUST delay sending the 2xx until the provisional\n    //    response is acknowledged.  Otherwise, the reliability of the 1xx\n    //    cannot be guaranteed, and reliability is needed for proper operation\n    //    of the offer/answer exchange.\n    //    All user agents that support this extension MUST support all\n    //    offer/answer exchanges that are possible based on the rules in\n    //    Section 13.2 of RFC 3261, based on the existence of INVITE and PRACK\n    //    as requests, and 2xx and reliable 1xx as non-failure reliable\n    //    responses.\n    //\n    // https://tools.ietf.org/html/rfc3262#section-5\n    ////\n    // The Offer/Answer Model Implementation\n    //\n    // The offer/answer model is straight forward, but one MUST READ the specifications...\n    //\n    // 13.2.1 Creating the Initial INVITE (paragraph 8 in particular)\n    // https://tools.ietf.org/html/rfc3261#section-13.2.1\n    //\n    // 5 The Offer/Answer Model and PRACK\n    // https://tools.ietf.org/html/rfc3262#section-5\n    //\n    // Session Initiation Protocol (SIP) Usage of the Offer/Answer Model\n    // https://tools.ietf.org/html/rfc6337\n    ////\n    ////\n    // TODO: The Offer/Answer Model Implementation\n    //\n    // Currently if `earlyMedia` is enabled and the INVITE request forks,\n    // the session is terminated if the early dialog does not match the\n    // confirmed dialog. This restriction make sense in a WebRTC environment,\n    // but there are other environments where this restriction does not hold.\n    //\n    // So while we currently cannot make the offer in INVITE+forking+webrtc\n    // case work, we propose doing the following...\n    //\n    // OPTION 1\n    // - add a `earlyMediaForking` option and\n    // - require SDH.setDescription() to be callable multiple times.\n    //\n    // OPTION 2\n    // 1) modify SDH Factory to provide an initial offer without giving us the SDH, and then...\n    // 2) stick that offer in the initial INVITE, and when 183 with initial answer is received...\n    // 3) ask SDH Factory if it supports \"earlyRemoteAnswer\"\n    //   a) if true, ask SDH Factory to createSDH(localOffer).then((sdh) => sdh.setDescription(remoteAnswer)\n    //   b) if false, defer getting a SDH until 2xx response is received\n    //\n    // Our supplied WebRTC SDH will default to behavior 3b which works in forking environment (without)\n    // early media if initial offer is in the INVITE). We will, however, provide an \"inviteWillNotFork\"\n    // option which if set to \"true\" will have our supplied WebRTC SDH behave in the 3a manner.\n    // That will result in\n    //  - early media working with initial offer in the INVITE, and...\n    //  - if the INVITE forks, the session terminating with an ERROR that reads like\n    //    \"You set 'inviteWillNotFork' to true but the INVITE forked. You can't eat your cake, and have it too.\"\n    //  - furthermore, we accept that users will report that error to us as \"bug\" regardless\n    //\n    // So, SDH Factory is going to end up with a new interface along the lines of...\n    //\n    // interface SessionDescriptionHandlerFactory {\n    //   makeLocalOffer(): Promise<ContentTypeAndBody>;\n    //   makeSessionDescriptionHandler(\n    //     initialOffer: ContentTypeAndBody, offerType: \"local\" | \"remote\"\n    //   ): Promise<SessionDescriptionHandler>;\n    //   supportsEarlyRemoteAnswer: boolean;\n    //   supportsContentType(contentType: string): boolean;\n    //   getDescription(description: ContentTypeAndBody): Promise<ContentTypeAndBody>\n    //   setDescription(description: ContentTypeAndBody): Promise<void>\n    // }\n    ////\n    // Send the INVITE request.\n    this.outgoingInviteRequest = this.userAgent.userAgentCore.invite(this.outgoingRequestMessage, {\n      onAccept: inviteResponse => {\n        // Our transaction layer is \"non-standard\" in that it will only\n        // pass us a 2xx response once per branch, so there is no need to\n        // worry about dealing with 2xx retransmissions. However, we can\n        // and do still get 2xx responses for multiple branches (when an\n        // INVITE is forked) which may create multiple confirmed dialogs.\n        // Herein we are acking and sending a bye to any confirmed dialogs\n        // which arrive beyond the first one. This is the desired behavior\n        // for most applications (but certainly not all).\n        // If we already received a confirmed dialog, ack & bye this additional confirmed session.\n        if (this.dialog) {\n          this.logger.log(\"Additional confirmed dialog, sending ACK and BYE\");\n          this.ackAndBye(inviteResponse); // We do NOT transition state in this case (this is an \"extra\" dialog)\n\n          return;\n        } // If the user requested cancellation, ack & bye this session.\n\n\n        if (this.isCanceled) {\n          this.logger.log(\"Canceled session accepted, sending ACK and BYE\");\n          this.ackAndBye(inviteResponse);\n          this.stateTransition(SessionState.Terminated);\n          return;\n        }\n\n        this.notifyReferer(inviteResponse);\n        this.onAccept(inviteResponse).then(() => {\n          this.disposeEarlyMedia();\n        }).catch(() => {\n          this.disposeEarlyMedia();\n        }).then(() => {\n          if (options.requestDelegate && options.requestDelegate.onAccept) {\n            options.requestDelegate.onAccept(inviteResponse);\n          }\n        });\n      },\n      onProgress: inviteResponse => {\n        // If the user requested cancellation, ignore response.\n        if (this.isCanceled) {\n          return;\n        }\n\n        this.notifyReferer(inviteResponse);\n        this.onProgress(inviteResponse).catch(() => {\n          this.disposeEarlyMedia();\n        }).then(() => {\n          if (options.requestDelegate && options.requestDelegate.onProgress) {\n            options.requestDelegate.onProgress(inviteResponse);\n          }\n        });\n      },\n      onRedirect: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onRedirect(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(inviteResponse);\n        }\n      },\n      onReject: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onReject(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(inviteResponse);\n        }\n      },\n      onTrying: inviteResponse => {\n        this.notifyReferer(inviteResponse);\n        this.onTrying(inviteResponse);\n\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(inviteResponse);\n        }\n      }\n    });\n    return this.outgoingInviteRequest;\n  }\n\n  disposeEarlyMedia() {\n    this.earlyMediaSessionDescriptionHandlers.forEach(sessionDescriptionHandler => {\n      sessionDescriptionHandler.close();\n    });\n    this.earlyMediaSessionDescriptionHandlers.clear();\n  }\n\n  notifyReferer(response) {\n    if (!this._referred) {\n      return;\n    }\n\n    if (!(this._referred instanceof Session)) {\n      throw new Error(\"Referred session not instance of session\");\n    }\n\n    if (!this._referred.dialog) {\n      return;\n    }\n\n    if (!response.message.statusCode) {\n      throw new Error(\"Status code undefined.\");\n    }\n\n    if (!response.message.reasonPhrase) {\n      throw new Error(\"Reason phrase undefined.\");\n    }\n\n    const statusCode = response.message.statusCode;\n    const reasonPhrase = response.message.reasonPhrase;\n    const body = `SIP/2.0 ${statusCode} ${reasonPhrase}`.trim();\n\n    const outgoingNotifyRequest = this._referred.dialog.notify(undefined, {\n      extraHeaders: [\"Event: refer\", \"Subscription-State: terminated\"],\n      body: {\n        contentDisposition: \"render\",\n        contentType: \"message/sipfrag\",\n        content: body\n      }\n    }); // The implicit subscription created by a REFER is the same as a\n    // subscription created with a SUBSCRIBE request.  The agent issuing the\n    // REFER can terminate this subscription prematurely by unsubscribing\n    // using the mechanisms described in [2].  Terminating a subscription,\n    // either by explicitly unsubscribing or rejecting NOTIFY, is not an\n    // indication that the referenced request should be withdrawn or\n    // abandoned.\n    // https://tools.ietf.org/html/rfc3515#section-2.4.4\n    // FIXME: TODO: This should be done in a subscribe dialog to satisfy the above.\n    // If the notify is rejected, stop sending NOTIFY requests.\n\n\n    outgoingNotifyRequest.delegate = {\n      onReject: () => {\n        this._referred = undefined;\n      }\n    };\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 2xx response.\n   */\n\n\n  onAccept(inviteResponse) {\n    this.logger.log(\"Inviter.onAccept\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Accept received while in state ${this.state}, dropping response`);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const response = inviteResponse.message;\n    const session = inviteResponse.session; // Ported behavior.\n\n    if (response.hasHeader(\"P-Asserted-Identity\")) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n    } // We have a confirmed dialog.\n\n\n    session.delegate = {\n      onAck: ackRequest => this.onAckRequest(ackRequest),\n      onBye: byeRequest => this.onByeRequest(byeRequest),\n      onInfo: infoRequest => this.onInfoRequest(infoRequest),\n      onInvite: inviteRequest => this.onInviteRequest(inviteRequest),\n      onMessage: messageRequest => this.onMessageRequest(messageRequest),\n      onNotify: notifyRequest => this.onNotifyRequest(notifyRequest),\n      onPrack: prackRequest => this.onPrackRequest(prackRequest),\n      onRefer: referRequest => this.onReferRequest(referRequest)\n    };\n    this._dialog = session;\n\n    switch (session.signalingState) {\n      case SignalingState.Initial:\n        // INVITE without offer, so MUST have offer at this point, so invalid state.\n        this.logger.error(\"Received 2xx response to INVITE without a session description\");\n        this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n        this.stateTransition(SessionState.Terminated);\n        return Promise.reject(new Error(\"Bad Media Description\"));\n\n      case SignalingState.HaveLocalOffer:\n        // INVITE with offer, so MUST have answer at this point, so invalid state.\n        this.logger.error(\"Received 2xx response to INVITE without a session description\");\n        this.ackAndBye(inviteResponse, 400, \"Missing session description\");\n        this.stateTransition(SessionState.Terminated);\n        return Promise.reject(new Error(\"Bad Media Description\"));\n\n      case SignalingState.HaveRemoteOffer:\n        {\n          // INVITE without offer, received offer in 2xx, so MUST send answer in ACK.\n          if (!this._dialog.offer) {\n            throw new Error(`Session offer undefined in signaling state ${this._dialog.signalingState}.`);\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setOfferAndGetAnswer(this._dialog.offer, options).then(body => {\n            inviteResponse.ack({\n              body\n            });\n            this.stateTransition(SessionState.Established);\n          }).catch(error => {\n            this.ackAndBye(inviteResponse, 488, \"Invalid session description\");\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Stable:\n        {\n          // If INVITE without offer and we have already completed the initial exchange.\n          if (this.earlyMediaSessionDescriptionHandlers.size > 0) {\n            const sdh = this.earlyMediaSessionDescriptionHandlers.get(session.id);\n\n            if (!sdh) {\n              throw new Error(\"Session description handler undefined.\");\n            }\n\n            this.setSessionDescriptionHandler(sdh);\n            this.earlyMediaSessionDescriptionHandlers.delete(session.id);\n            inviteResponse.ack();\n            this.stateTransition(SessionState.Established);\n            return Promise.resolve();\n          } // If INVITE with offer and we used an \"early\" answer in a provisional response for media\n\n\n          if (this.earlyMediaDialog) {\n            // If early media dialog doesn't match confirmed dialog, we must unfortunately fail.\n            // This limitation stems from how WebRTC currently implements its offer/answer model.\n            // There are details elsewhere, but in short a WebRTC offer cannot be forked.\n            if (this.earlyMediaDialog !== session) {\n              if (this.earlyMedia) {\n                const message = \"You have set the 'earlyMedia' option to 'true' which requires that your INVITE requests \" + \"do not fork and yet this INVITE request did in fact fork. Consequentially and not surprisingly \" + \"the end point which accepted the INVITE (confirmed dialog) does not match the end point with \" + \"which early media has been setup (early dialog) and thus this session is unable to proceed. \" + \"In accordance with the SIP specifications, the SIP servers your end point is connected to \" + \"determine if an INVITE forks and the forking behavior of those servers cannot be controlled \" + \"by this library. If you wish to use early media with this library you must configure those \" + \"servers accordingly. Alternatively you may set the 'earlyMedia' to 'false' which will allow \" + \"this library to function with any INVITE requests which do fork.\";\n                this.logger.error(message);\n              }\n\n              const error = new Error(\"Early media dialog does not equal confirmed dialog, terminating session\");\n              this.logger.error(error.message);\n              this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n              this.stateTransition(SessionState.Terminated);\n              return Promise.reject(error);\n            } // Otherwise we are good to go.\n\n\n            inviteResponse.ack();\n            this.stateTransition(SessionState.Established);\n            return Promise.resolve();\n          } // If INVITE with offer and we have been waiting till now to apply the answer.\n\n\n          const answer = session.answer;\n\n          if (!answer) {\n            throw new Error(\"Answer is undefined.\");\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setAnswer(answer, options).then(() => {\n            // This session has completed an initial offer/answer exchange...\n            let ackOptions;\n\n            if (this._renderbody && this._rendertype) {\n              ackOptions = {\n                body: {\n                  contentDisposition: \"render\",\n                  contentType: this._rendertype,\n                  content: this._renderbody\n                }\n              };\n            }\n\n            inviteResponse.ack(ackOptions);\n            this.stateTransition(SessionState.Established);\n          }).catch(error => {\n            this.logger.error(error.message);\n            this.ackAndBye(inviteResponse, 488, \"Not Acceptable Here\");\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Closed:\n        // Dialog has terminated.\n        return Promise.reject(new Error(\"Terminated.\"));\n\n      default:\n        throw new Error(\"Unknown session signaling state.\");\n    }\n  }\n  /**\n   * Handle provisional response to initial INVITE.\n   * @param inviteResponse - 1xx response.\n   */\n\n\n  onProgress(inviteResponse) {\n    var _a;\n\n    this.logger.log(\"Inviter.onProgress\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Progress received while in state ${this.state}, dropping response`);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    if (!this.outgoingInviteRequest) {\n      throw new Error(\"Outgoing INVITE request undefined.\");\n    }\n\n    const response = inviteResponse.message;\n    const session = inviteResponse.session; // Ported - Set assertedIdentity.\n\n    if (response.hasHeader(\"P-Asserted-Identity\")) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(response.getHeader(\"P-Asserted-Identity\"));\n    } // If a provisional response is received for an initial request, and\n    // that response contains a Require header field containing the option\n    // tag 100rel, the response is to be sent reliably.  If the response is\n    // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n    // ignored, and the procedures below MUST NOT be used.\n    // https://tools.ietf.org/html/rfc3262#section-4\n\n\n    const requireHeader = response.getHeader(\"require\");\n    const rseqHeader = response.getHeader(\"rseq\");\n    const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n    const responseReliable = !!rseq;\n    const extraHeaders = [];\n\n    if (responseReliable) {\n      extraHeaders.push(\"RAck: \" + response.getHeader(\"rseq\") + \" \" + response.getHeader(\"cseq\"));\n    }\n\n    switch (session.signalingState) {\n      case SignalingState.Initial:\n        // INVITE without offer and session still has no offer (and no answer).\n        if (responseReliable) {\n          // Similarly, if a reliable provisional\n          // response is the first reliable message sent back to the UAC, and the\n          // INVITE did not contain an offer, one MUST appear in that reliable\n          // provisional response.\n          // https://tools.ietf.org/html/rfc3262#section-5\n          this.logger.warn(\"First reliable provisional response received MUST contain an offer when INVITE does not contain an offer.\"); // FIXME: Known popular UA's currently end up here...\n\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.HaveLocalOffer:\n        // INVITE with offer and session only has that initial local offer.\n        if (responseReliable) {\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.HaveRemoteOffer:\n        if (!responseReliable) {\n          // The initial offer MUST be in either an INVITE or, if not there,\n          // in the first reliable non-failure message from the UAS back to\n          // the UAC.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // According to Section 13.2.1 of [RFC3261], 'The first reliable\n          // non-failure message' must have an offer if there is no offer in the\n          // INVITE request.  This means that the User Agent (UA) that receives\n          // the INVITE request without an offer must include an offer in the\n          // first reliable response with 100rel extension.  If no reliable\n          // provisional response has been sent, the User Agent Server (UAS) must\n          // include an offer when sending 2xx response.\n          // https://tools.ietf.org/html/rfc6337#section-2.2\n          this.logger.warn(\"Non-reliable provisional response MUST NOT contain an initial offer, discarding response.\");\n          return Promise.resolve();\n        }\n\n        {\n          // If the initial offer is in the first reliable non-failure\n          // message from the UAS back to UAC, the answer MUST be in the\n          // acknowledgement for that message\n          const sdh = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions || {});\n\n          if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n            this.delegate.onSessionDescriptionHandler(sdh, true);\n          }\n\n          this.earlyMediaSessionDescriptionHandlers.set(session.id, sdh);\n          return sdh.setDescription(response.body, this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers).then(() => sdh.getDescription(this.sessionDescriptionHandlerOptions, this.sessionDescriptionHandlerModifiers)).then(description => {\n            const body = {\n              contentDisposition: \"session\",\n              contentType: description.contentType,\n              content: description.body\n            };\n            inviteResponse.prack({\n              extraHeaders,\n              body\n            });\n          }).catch(error => {\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n      case SignalingState.Stable:\n        // This session has completed an initial offer/answer exchange, so...\n        // - INVITE with SDP and this provisional response MAY be reliable\n        // - INVITE without SDP and this provisional response MAY be reliable\n        if (responseReliable) {\n          inviteResponse.prack({\n            extraHeaders\n          });\n        }\n\n        if (this.earlyMedia && !this.earlyMediaDialog) {\n          this.earlyMediaDialog = session;\n          const answer = session.answer;\n\n          if (!answer) {\n            throw new Error(\"Answer is undefined.\");\n          }\n\n          const options = {\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers,\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions\n          };\n          return this.setAnswer(answer, options).catch(error => {\n            this.stateTransition(SessionState.Terminated);\n            throw error;\n          });\n        }\n\n        return Promise.resolve();\n\n      case SignalingState.Closed:\n        // Dialog has terminated.\n        return Promise.reject(new Error(\"Terminated.\"));\n\n      default:\n        throw new Error(\"Unknown session signaling state.\");\n    }\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 3xx response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onRedirect(inviteResponse) {\n    this.logger.log(\"Inviter.onRedirect\"); // validate state\n\n    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n      this.logger.error(`Redirect received while in state ${this.state}, dropping response`);\n      return;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 4xx, 5xx, or 6xx response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onReject(inviteResponse) {\n    this.logger.log(\"Inviter.onReject\"); // validate state\n\n    if (this.state !== SessionState.Establishing && this.state !== SessionState.Terminating) {\n      this.logger.error(`Reject received while in state ${this.state}, dropping response`);\n      return;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle final response to initial INVITE.\n   * @param inviteResponse - 100 response.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onTrying(inviteResponse) {\n    this.logger.log(\"Inviter.onTrying\"); // validate state\n\n    if (this.state !== SessionState.Establishing) {\n      this.logger.error(`Trying received while in state ${this.state}, dropping response`);\n      return;\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}