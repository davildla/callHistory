{"ast":null,"code":"import { Invitation } from \"../../../api/invitation.js\";\nimport { Inviter } from \"../../../api/inviter.js\";\nimport { Messager } from \"../../../api/messager.js\";\nimport { Registerer } from \"../../../api/registerer.js\";\nimport { RegistererState } from \"../../../api/registerer-state.js\";\nimport { RequestPendingError } from \"../../../api/exceptions/request-pending.js\";\nimport { Session } from \"../../../api/session.js\";\nimport { SessionState } from \"../../../api/session-state.js\";\nimport { UserAgent } from \"../../../api/user-agent.js\";\nimport { UserAgentState } from \"../../../api/user-agent-state.js\";\nimport { SessionDescriptionHandler } from \"../session-description-handler/session-description-handler.js\";\nimport { Transport } from \"../transport/transport.js\";\nimport { defaultManagedSessionFactory } from \"./managed-session-factory-default.js\";\n/**\n * A session manager for SIP.js sessions.\n * @public\n */\n\nexport class SessionManager {\n  /**\n   * Constructs a new instance of the `SessionManager` class.\n   * @param server - SIP WebSocket Server URL.\n   * @param options - Options bucket. See {@link SessionManagerOptions} for details.\n   */\n  constructor(server) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** Sessions being managed. */\n    this.managedSessions = [];\n    this.attemptingReconnection = false;\n    this.optionsPingFailure = false;\n    this.optionsPingRunning = false;\n    this.shouldBeConnected = false;\n    this.shouldBeRegistered = false; // Delegate\n\n    this.delegate = options.delegate; // Copy options\n\n    this.options = Object.assign({\n      aor: \"\",\n      autoStop: true,\n      delegate: {},\n      iceStopWaitingOnServerReflexive: false,\n      managedSessionFactory: defaultManagedSessionFactory(),\n      maxSimultaneousSessions: 2,\n      media: {},\n      optionsPingInterval: -1,\n      optionsPingRequestURI: \"\",\n      reconnectionAttempts: 3,\n      reconnectionDelay: 4,\n      registrationRetry: false,\n      registrationRetryInterval: 3,\n      registerGuard: null,\n      registererOptions: {},\n      registererRegisterOptions: {},\n      sendDTMFUsingSessionDescriptionHandler: false,\n      userAgentOptions: {}\n    }, SessionManager.stripUndefinedProperties(options)); // UserAgentOptions\n\n    const userAgentOptions = Object.assign({}, options.userAgentOptions); // Transport\n\n    if (!userAgentOptions.transportConstructor) {\n      userAgentOptions.transportConstructor = Transport;\n    } // TransportOptions\n\n\n    if (!userAgentOptions.transportOptions) {\n      userAgentOptions.transportOptions = {\n        server\n      };\n    } // URI\n\n\n    if (!userAgentOptions.uri) {\n      // If an AOR was provided, convert it to a URI\n      if (options.aor) {\n        const uri = UserAgent.makeURI(options.aor);\n\n        if (!uri) {\n          throw new Error(`Failed to create valid URI from ${options.aor}`);\n        }\n\n        userAgentOptions.uri = uri;\n      }\n    } // UserAgent\n\n\n    this.userAgent = new UserAgent(userAgentOptions); // UserAgent's delegate\n\n    this.userAgent.delegate = {\n      // Handle connection with server established\n      onConnect: () => {\n        this.logger.log(`Connected`);\n\n        if (this.delegate && this.delegate.onServerConnect) {\n          this.delegate.onServerConnect();\n        } // Attempt to register if we are supposed to be registered\n\n\n        if (this.shouldBeRegistered) {\n          this.register();\n        } // Start OPTIONS pings if we are to be pinging\n\n\n        if (this.options.optionsPingInterval > 0) {\n          this.optionsPingStart();\n        }\n      },\n      // Handle connection with server lost\n      onDisconnect: async error => {\n        this.logger.log(`Disconnected`); // Stop OPTIONS ping if need be.\n\n        let optionsPingFailure = false;\n\n        if (this.options.optionsPingInterval > 0) {\n          optionsPingFailure = this.optionsPingFailure;\n          this.optionsPingFailure = false;\n          this.optionsPingStop();\n        } // Let delgate know we have disconnected\n\n\n        if (this.delegate && this.delegate.onServerDisconnect) {\n          this.delegate.onServerDisconnect(error);\n        } // If the user called `disconnect` a graceful cleanup will be done therein.\n        // Only cleanup if network/server dropped the connection.\n        // Only reconnect if network/server dropped the connection\n\n\n        if (error || optionsPingFailure) {\n          // There is no transport at this point, so we are not expecting to be able to\n          // send messages much less get responses. So just dispose of everything without\n          // waiting for anything to succeed.\n          if (this.registerer) {\n            this.logger.log(`Disposing of registerer...`);\n            this.registerer.dispose().catch(e => {\n              this.logger.debug(`Error occurred disposing of registerer after connection with server was lost.`);\n              this.logger.debug(e.toString());\n            });\n            this.registerer = undefined;\n          }\n\n          this.managedSessions.slice().map(el => el.session).forEach(async session => {\n            this.logger.log(`Disposing of session...`);\n            session.dispose().catch(e => {\n              this.logger.debug(`Error occurred disposing of a session after connection with server was lost.`);\n              this.logger.debug(e.toString());\n            });\n          }); // Attempt to reconnect if we are supposed to be connected.\n\n          if (this.shouldBeConnected) {\n            this.attemptReconnection();\n          }\n        }\n      },\n      // Handle incoming invitations\n      onInvite: invitation => {\n        this.logger.log(`[${invitation.id}] Received INVITE`); // Guard against a maximum number of pre-existing sessions.\n        // An incoming INVITE request may be received at any time and/or while in the process\n        // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n\n        const maxSessions = this.options.maxSimultaneousSessions;\n\n        if (maxSessions !== 0 && this.managedSessions.length > maxSessions) {\n          this.logger.warn(`[${invitation.id}] Session already in progress, rejecting INVITE...`);\n          invitation.reject().then(() => {\n            this.logger.log(`[${invitation.id}] Rejected INVITE`);\n          }).catch(error => {\n            this.logger.error(`[${invitation.id}] Failed to reject INVITE`);\n            this.logger.error(error.toString());\n          });\n          return;\n        } // Use our configured constraints as options for any Inviter created as result of a REFER\n\n\n        const referralInviterOptions = {\n          sessionDescriptionHandlerOptions: {\n            constraints: this.constraints\n          }\n        }; // Initialize our session\n\n        this.initSession(invitation, referralInviterOptions); // Delegate\n\n        if (this.delegate && this.delegate.onCallReceived) {\n          this.delegate.onCallReceived(invitation);\n        } else {\n          this.logger.warn(`[${invitation.id}] No handler available, rejecting INVITE...`);\n          invitation.reject().then(() => {\n            this.logger.log(`[${invitation.id}] Rejected INVITE`);\n          }).catch(error => {\n            this.logger.error(`[${invitation.id}] Failed to reject INVITE`);\n            this.logger.error(error.toString());\n          });\n        }\n      },\n      // Handle incoming messages\n      onMessage: message => {\n        message.accept().then(() => {\n          if (this.delegate && this.delegate.onMessageReceived) {\n            this.delegate.onMessageReceived(message);\n          }\n        });\n      },\n      // Handle incoming notifications\n      onNotify: notification => {\n        notification.accept().then(() => {\n          if (this.delegate && this.delegate.onNotificationReceived) {\n            this.delegate.onNotificationReceived(notification);\n          }\n        });\n      }\n    }; // RegistererOptions\n\n    this.registererOptions = Object.assign({}, options.registererOptions); // RegistererRegisterOptions\n\n    this.registererRegisterOptions = Object.assign({}, options.registererRegisterOptions); // Retry registration on failure or rejection.\n\n    if (this.options.registrationRetry) {\n      // If the register request is rejected, try again...\n      this.registererRegisterOptions.requestDelegate = this.registererRegisterOptions.requestDelegate || {};\n      const existingOnReject = this.registererRegisterOptions.requestDelegate.onReject;\n\n      this.registererRegisterOptions.requestDelegate.onReject = response => {\n        existingOnReject && existingOnReject(response); // If at first we don't succeed, try try again...\n\n        this.attemptRegistration();\n      };\n    } // Use the SIP.js logger\n\n\n    this.logger = this.userAgent.getLogger(\"sip.SessionManager\"); // Monitor network connectivity and attempt reconnection and reregistration when we come online\n\n    window.addEventListener(\"online\", () => {\n      this.logger.log(`Online`);\n\n      if (this.shouldBeConnected) {\n        this.connect();\n      }\n    }); // NOTE: The autoStop option does not currently work as one likley expects.\n    //       This code is here because the \"autoStop behavior\" and this assoicated\n    //       implemenation has been a recurring request. So instead of removing\n    //       the implementation again (because it doesn't work) and then having\n    //       to explain agian the issue over and over again to those who want it,\n    //       we have included it here to break that cycle. The implementation is\n    //       harmless and serves to provide an explaination for those interested.\n\n    if (this.options.autoStop) {\n      // Standard operation workflow will resume after this callback exits, meaning\n      // that any asynchronous operations are likely not going to be finished, especially\n      // if they are guaranteed to not be executed in the current tick (promises fall\n      // under this category, they will never be resolved synchronously by design).\n      window.addEventListener(\"beforeunload\", async () => {\n        this.shouldBeConnected = false;\n        this.shouldBeRegistered = false;\n\n        if (this.userAgent.state !== UserAgentState.Stopped) {\n          // The stop() method returns a promise which will not resolve before the page unloads.\n          await this.userAgent.stop();\n        }\n      });\n    }\n  }\n  /**\n   * Strip properties with undefined values from options.\n   * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n   * https://github.com/Microsoft/TypeScript/issues/13195\n   * @param options - Options to reduce\n   */\n\n\n  static stripUndefinedProperties(options) {\n    return Object.keys(options).reduce((object, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (options[key] !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        object[key] = options[key];\n      }\n\n      return object;\n    }, {});\n  }\n  /**\n   * The local media stream. Undefined if call not answered.\n   * @param session - Session to get the media stream from.\n   */\n\n\n  getLocalMediaStream(session) {\n    const sdh = session.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n    }\n\n    return sdh.localMediaStream;\n  }\n  /**\n   * The remote media stream. Undefined if call not answered.\n   * @param session - Session to get the media stream from.\n   */\n\n\n  getRemoteMediaStream(session) {\n    const sdh = session.sessionDescriptionHandler;\n\n    if (!sdh) {\n      return undefined;\n    }\n\n    if (!(sdh instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session description handler not instance of web SessionDescriptionHandler\");\n    }\n\n    return sdh.remoteMediaStream;\n  }\n  /**\n   * The local audio track, if available.\n   * @param session - Session to get track from.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  getLocalAudioTrack(session) {\n    var _a;\n\n    return (_a = this.getLocalMediaStream(session)) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"audio\");\n  }\n  /**\n   * The local video track, if available.\n   * @param session - Session to get track from.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  getLocalVideoTrack(session) {\n    var _a;\n\n    return (_a = this.getLocalMediaStream(session)) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"video\");\n  }\n  /**\n   * The remote audio track, if available.\n   * @param session - Session to get track from.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  getRemoteAudioTrack(session) {\n    var _a;\n\n    return (_a = this.getRemoteMediaStream(session)) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"audio\");\n  }\n  /**\n   * The remote video track, if available.\n   * @param session - Session to get track from.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  getRemoteVideoTrack(session) {\n    var _a;\n\n    return (_a = this.getRemoteMediaStream(session)) === null || _a === void 0 ? void 0 : _a.getTracks().find(track => track.kind === \"video\");\n  }\n  /**\n   * Connect.\n   * @remarks\n   * If not started, starts the UserAgent connecting the WebSocket Transport.\n   * Otherwise reconnects the UserAgent's WebSocket Transport.\n   * Attempts will be made to reconnect as needed.\n   */\n\n\n  async connect() {\n    this.logger.log(`Connecting UserAgent...`);\n    this.shouldBeConnected = true;\n\n    if (this.userAgent.state !== UserAgentState.Started) {\n      return this.userAgent.start();\n    }\n\n    return this.userAgent.reconnect();\n  }\n  /**\n   * Disconnect.\n   * @remarks\n   * If not stopped, stops the UserAgent disconnecting the WebSocket Transport.\n   */\n\n\n  async disconnect() {\n    this.logger.log(`Disconnecting UserAgent...`);\n\n    if (this.userAgent.state === UserAgentState.Stopped) {\n      return Promise.resolve();\n    }\n\n    this.shouldBeConnected = false;\n    this.shouldBeRegistered = false;\n    this.registerer = undefined;\n    return this.userAgent.stop();\n  }\n  /**\n   * Return true if transport is connected.\n   */\n\n\n  isConnected() {\n    return this.userAgent.isConnected();\n  }\n  /**\n   * Start receiving incoming calls.\n   * @remarks\n   * Send a REGISTER request for the UserAgent's AOR.\n   * Resolves when the REGISTER request is sent, otherwise rejects.\n   * Attempts will be made to re-register as needed.\n   */\n\n\n  async register(registererRegisterOptions) {\n    this.logger.log(`Registering UserAgent...`);\n    this.shouldBeRegistered = true;\n\n    if (registererRegisterOptions !== undefined) {\n      this.registererRegisterOptions = Object.assign({}, registererRegisterOptions);\n    }\n\n    if (!this.registerer) {\n      this.registerer = new Registerer(this.userAgent, this.registererOptions);\n      this.registerer.stateChange.addListener(state => {\n        switch (state) {\n          case RegistererState.Initial:\n            break;\n\n          case RegistererState.Registered:\n            if (this.delegate && this.delegate.onRegistered) {\n              this.delegate.onRegistered();\n            }\n\n            break;\n\n          case RegistererState.Unregistered:\n            if (this.delegate && this.delegate.onUnregistered) {\n              this.delegate.onUnregistered();\n            } // If we transition to an unregister state, attempt to get back to a registered state.\n\n\n            if (this.shouldBeRegistered) {\n              this.attemptRegistration();\n            }\n\n            break;\n\n          case RegistererState.Terminated:\n            break;\n\n          default:\n            throw new Error(\"Unknown registerer state.\");\n        }\n      });\n    }\n\n    return this.attemptRegistration(true);\n  }\n  /**\n   * Stop receiving incoming calls.\n   * @remarks\n   * Send an un-REGISTER request for the UserAgent's AOR.\n   * Resolves when the un-REGISTER request is sent, otherwise rejects.\n   */\n\n\n  async unregister(registererUnregisterOptions) {\n    this.logger.log(`Unregistering UserAgent...`);\n    this.shouldBeRegistered = false;\n\n    if (!this.registerer) {\n      this.logger.warn(`No registerer to unregister.`);\n      return Promise.resolve();\n    }\n\n    return this.registerer.unregister(registererUnregisterOptions).then(() => {\n      return;\n    });\n  }\n  /**\n   * Make an outgoing call.\n   * @remarks\n   * Send an INVITE request to create a new Session.\n   * Resolves when the INVITE request is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if Session is established.\n   * @param destination - The target destination to call. A SIP address to send the INVITE to.\n   * @param inviterOptions - Optional options for Inviter constructor.\n   * @param inviterInviteOptions - Optional options for Inviter.invite().\n   */\n\n\n  async call(destination, inviterOptions, inviterInviteOptions) {\n    this.logger.log(`Beginning Session...`); // Guard against a maximum number of pre-existing sessions.\n    // An incoming INVITE request may be received at any time and/or while in the process\n    // of sending an outgoing INVITE request. So we reject any incoming INVITE in those cases.\n\n    const maxSessions = this.options.maxSimultaneousSessions;\n\n    if (maxSessions !== 0 && this.managedSessions.length > maxSessions) {\n      return Promise.reject(new Error(\"Maximum number of sessions already exists.\"));\n    }\n\n    const target = UserAgent.makeURI(destination);\n\n    if (!target) {\n      return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n    } // Use our configured constraints as InviterOptions if none provided\n\n\n    if (!inviterOptions) {\n      inviterOptions = {};\n    }\n\n    if (!inviterOptions.sessionDescriptionHandlerOptions) {\n      inviterOptions.sessionDescriptionHandlerOptions = {};\n    }\n\n    if (!inviterOptions.sessionDescriptionHandlerOptions.constraints) {\n      inviterOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n    } // If utilizing early media, add a handler to catch 183 Session Progress\n    // messages and then to play the associated remote media (the early media).\n\n\n    if (inviterOptions.earlyMedia) {\n      inviterInviteOptions = inviterInviteOptions || {};\n      inviterInviteOptions.requestDelegate = inviterInviteOptions.requestDelegate || {};\n      const existingOnProgress = inviterInviteOptions.requestDelegate.onProgress;\n\n      inviterInviteOptions.requestDelegate.onProgress = response => {\n        if (response.message.statusCode === 183) {\n          this.setupRemoteMedia(inviter);\n        }\n\n        existingOnProgress && existingOnProgress(response);\n      };\n    } // TODO: Any existing onSessionDescriptionHandler is getting clobbered here.\n    // If we get a server reflexive candidate, stop waiting on ICE gathering to complete.\n    // The candidate is a server reflexive candidate; the ip indicates an intermediary\n    // address assigned by the STUN server to represent the candidate's peer anonymously.\n\n\n    if (this.options.iceStopWaitingOnServerReflexive) {\n      inviterOptions.delegate = inviterOptions.delegate || {};\n\n      inviterOptions.delegate.onSessionDescriptionHandler = sessionDescriptionHandler => {\n        if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n          throw new Error(\"Session description handler not instance of SessionDescriptionHandler\");\n        }\n\n        sessionDescriptionHandler.peerConnectionDelegate = {\n          onicecandidate: event => {\n            var _a;\n\n            if (((_a = event.candidate) === null || _a === void 0 ? void 0 : _a.type) === \"srflx\") {\n              this.logger.log(`[${inviter.id}] Found srflx ICE candidate, stop waiting...`); // In sip.js > 0.20.1 this cast should be removed as iceGatheringComplete will be public\n\n              const sdh = sessionDescriptionHandler;\n              sdh.iceGatheringComplete();\n            }\n          }\n        };\n      };\n    } // Create a new Inviter for the outgoing Session\n\n\n    const inviter = new Inviter(this.userAgent, target, inviterOptions); // Send INVITE\n\n    return this.sendInvite(inviter, inviterOptions, inviterInviteOptions).then(() => {\n      return inviter;\n    });\n  }\n  /**\n   * Hangup a call.\n   * @param session - Session to hangup.\n   * @remarks\n   * Send a BYE request, CANCEL request or reject response to end the current Session.\n   * Resolves when the request/response is sent, otherwise rejects.\n   * Use `onCallHangup` delegate method to determine if and when call is ended.\n   */\n\n\n  async hangup(session) {\n    this.logger.log(`[${session.id}] Hangup...`);\n\n    if (!this.sessionExists(session)) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.terminate(session);\n  }\n  /**\n   * Answer an incoming call.\n   * @param session - Session to answer.\n   * @remarks\n   * Accept an incoming INVITE request creating a new Session.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if and when call is established.\n   * @param invitationAcceptOptions - Optional options for Inviter.accept().\n   */\n\n\n  async answer(session, invitationAcceptOptions) {\n    this.logger.log(`[${session.id}] Accepting Invitation...`);\n\n    if (!this.sessionExists(session)) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    if (!(session instanceof Invitation)) {\n      return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n    } // Use our configured constraints as InvitationAcceptOptions if none provided\n\n\n    if (!invitationAcceptOptions) {\n      invitationAcceptOptions = {};\n    }\n\n    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions) {\n      invitationAcceptOptions.sessionDescriptionHandlerOptions = {};\n    }\n\n    if (!invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints) {\n      invitationAcceptOptions.sessionDescriptionHandlerOptions.constraints = this.constraints;\n    }\n\n    return session.accept(invitationAcceptOptions);\n  }\n  /**\n   * Decline an incoming call.\n   * @param session - Session to decline.\n   * @remarks\n   * Reject an incoming INVITE request.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallHangup` delegate method to determine if and when call is ended.\n   */\n\n\n  async decline(session) {\n    this.logger.log(`[${session.id}] Rejecting Invitation...`);\n\n    if (!this.sessionExists(session)) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    if (!(session instanceof Invitation)) {\n      return Promise.reject(new Error(\"Session not instance of Invitation.\"));\n    }\n\n    return session.reject();\n  }\n  /**\n   * Hold call\n   * @param session - Session to hold.\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"hold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  async hold(session) {\n    this.logger.log(`[${session.id}] Holding session...`);\n    return this.setHold(session, true);\n  }\n  /**\n   * Unhold call.\n   * @param session - Session to unhold.\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"unhold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  async unhold(session) {\n    this.logger.log(`[${session.id}] Unholding session...`);\n    return this.setHold(session, false);\n  }\n  /**\n   * Hold state.\n   * @param session - Session to check.\n   * @remarks\n   * True if session is on hold.\n   */\n\n\n  isHeld(session) {\n    const managedSession = this.sessionManaged(session);\n    return managedSession ? managedSession.held : false;\n  }\n  /**\n   * Mute call.\n   * @param session - Session to mute.\n   * @remarks\n   * Disable sender's media tracks.\n   */\n\n\n  mute(session) {\n    this.logger.log(`[${session.id}] Disabling media tracks...`);\n    this.setMute(session, true);\n  }\n  /**\n   * Unmute call.\n   * @param session - Session to unmute.\n   * @remarks\n   * Enable sender's media tracks.\n   */\n\n\n  unmute(session) {\n    this.logger.log(`[${session.id}] Enabling media tracks...`);\n    this.setMute(session, false);\n  }\n  /**\n   * Mute state.\n   * @param session - Session to check.\n   * @remarks\n   * True if sender's media track is disabled.\n   */\n\n\n  isMuted(session) {\n    const managedSession = this.sessionManaged(session);\n    return managedSession ? managedSession.muted : false;\n  }\n  /**\n   * Send DTMF.\n   * @param session - Session to send on.\n   * @remarks\n   * Send an INFO request with content type application/dtmf-relay.\n   * @param tone - Tone to send.\n   */\n\n\n  async sendDTMF(session, tone) {\n    this.logger.log(`[${session.id}] Sending DTMF...`); // Validate tone\n\n    if (!/^[0-9A-D#*,]$/.exec(tone)) {\n      return Promise.reject(new Error(\"Invalid DTMF tone.\"));\n    }\n\n    if (!this.sessionExists(session)) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    this.logger.log(`[${session.id}] Sending DTMF tone: ${tone}`);\n\n    if (this.options.sendDTMFUsingSessionDescriptionHandler) {\n      if (!session.sessionDescriptionHandler) {\n        return Promise.reject(new Error(\"Session desciption handler undefined.\"));\n      }\n\n      if (!session.sessionDescriptionHandler.sendDtmf(tone)) {\n        return Promise.reject(new Error(\"Failed to send DTMF\"));\n      }\n\n      return Promise.resolve();\n    } else {\n      // As RFC 6086 states, sending DTMF via INFO is not standardized...\n      //\n      // Companies have been using INFO messages in order to transport\n      // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n      // proprietary and have not been standardized.\n      // https://tools.ietf.org/html/rfc6086#section-2\n      //\n      // It is however widely supported based on this draft:\n      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n      // The UA MUST populate the \"application/dtmf-relay\" body, as defined\n      // earlier, with the button pressed and the duration it was pressed\n      // for.  Technically, this actually requires the INFO to be generated\n      // when the user *releases* the button, however if the user has still\n      // not released a button after 5 seconds, which is the maximum duration\n      // supported by this mechanism, the UA should generate the INFO at that\n      // time.\n      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00#section-5.3\n      const dtmf = tone;\n      const duration = 2000;\n      const body = {\n        contentDisposition: \"render\",\n        contentType: \"application/dtmf-relay\",\n        content: \"Signal=\" + dtmf + \"\\r\\nDuration=\" + duration\n      };\n      const requestOptions = {\n        body\n      };\n      return session.info({\n        requestOptions\n      }).then(() => {\n        return;\n      });\n    }\n  }\n  /**\n   * Transfer.\n   * @param session - Session with the transferee to transfer.\n   * @param target - The referral target.\n   * @remarks\n   * If target is a Session this is an attended transfer completion (REFER with Replaces),\n   * otherwise this is a blind transfer (REFER). Attempting an attended transfer\n   * completion on a call that has not been answered will be rejected. To implement\n   * an attended transfer with early completion, hangup the call with the target\n   * and execute a blind transfer to the target.\n   */\n\n\n  async transfer(session, target, options) {\n    this.logger.log(`[${session.id}] Referring session...`);\n\n    if (target instanceof Session) {\n      return session.refer(target, options).then(() => {\n        return;\n      });\n    }\n\n    const uri = UserAgent.makeURI(target);\n\n    if (!uri) {\n      return Promise.reject(new Error(`Failed to create a valid URI from \"${target}\"`));\n    }\n\n    return session.refer(uri, options).then(() => {\n      return;\n    });\n  }\n  /**\n   * Send a message.\n   * @remarks\n   * Send a MESSAGE request.\n   * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n   */\n\n\n  async message(destination, message) {\n    this.logger.log(`Sending message...`);\n    const target = UserAgent.makeURI(destination);\n\n    if (!target) {\n      return Promise.reject(new Error(`Failed to create a valid URI from \"${destination}\"`));\n    }\n\n    return new Messager(this.userAgent, target, message).message();\n  }\n  /** Media constraints. */\n\n\n  get constraints() {\n    let constraints = {\n      audio: true,\n      video: false\n    }; // default to audio only calls\n\n    if (this.options.media.constraints) {\n      constraints = Object.assign({}, this.options.media.constraints);\n    }\n\n    return constraints;\n  }\n  /**\n   * Attempt reconnection up to `reconnectionAttempts` times.\n   * @param reconnectionAttempt - Current attempt number.\n   */\n\n\n  attemptReconnection() {\n    let reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const reconnectionAttempts = this.options.reconnectionAttempts;\n    const reconnectionDelay = this.options.reconnectionDelay;\n\n    if (!this.shouldBeConnected) {\n      this.logger.log(`Should not be connected currently`);\n      return; // If intentionally disconnected, don't reconnect.\n    }\n\n    if (this.attemptingReconnection) {\n      this.logger.log(`Reconnection attempt already in progress`);\n    }\n\n    if (reconnectionAttempt > reconnectionAttempts) {\n      this.logger.log(`Reconnection maximum attempts reached`);\n      return;\n    }\n\n    if (reconnectionAttempt === 1) {\n      this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n    } else {\n      this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying in ${reconnectionDelay} seconds`);\n    }\n\n    this.attemptingReconnection = true;\n    setTimeout(() => {\n      if (!this.shouldBeConnected) {\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - aborted`);\n        this.attemptingReconnection = false;\n        return; // If intentionally disconnected, don't reconnect.\n      }\n\n      this.userAgent.reconnect().then(() => {\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n        this.attemptingReconnection = false;\n      }).catch(error => {\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n        this.logger.error(error.message);\n        this.attemptingReconnection = false;\n        this.attemptReconnection(++reconnectionAttempt);\n      });\n    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n  }\n  /**\n   * Register to receive calls.\n   * @param withoutDelay - If true attempt immediately, otherwise wait `registrationRetryInterval`.\n   */\n\n\n  attemptRegistration() {\n    let withoutDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.logger.log(`Registration attempt ${withoutDelay ? \"without delay\" : \"\"}`);\n\n    if (!this.shouldBeRegistered) {\n      this.logger.log(`Should not be registered currently`);\n      return Promise.resolve();\n    } // It only makes sense to have one attempt in progress at a time.\n    // Perhaps we shall (or should) try once again.\n\n\n    if (this.registrationAttemptTimeout !== undefined) {\n      this.logger.log(`Registration attempt already in progress`);\n      return Promise.resolve();\n    } // Helper function to send the register request.\n\n\n    const _register = () => {\n      // If we do not have a registerer, it is not worth trying to register.\n      if (!this.registerer) {\n        this.logger.log(`Registerer undefined`);\n        return Promise.resolve();\n      } // If the WebSocket transport is not connected, it is not worth trying to register.\n      // Perhpas we shall (or should) try once we are connected.\n\n\n      if (!this.isConnected()) {\n        this.logger.log(`User agent not connected`);\n        return Promise.resolve();\n      } // If the UserAgent is stopped, it is not worth trying to register.\n      // Perhaps we shall (or should) try once the UserAgent is running.\n\n\n      if (this.userAgent.state === UserAgentState.Stopped) {\n        this.logger.log(`User agent stopped`);\n        return Promise.resolve();\n      } // If no guard defined, we are good to proceed without any further ado.\n\n\n      if (!this.options.registerGuard) {\n        return this.registerer.register(this.registererRegisterOptions).then(() => {\n          return;\n        });\n      } // Otherwise check to make sure the guard does not want us halt.\n\n\n      return this.options.registerGuard().catch(error => {\n        this.logger.log(`Register guard rejected will making registration attempt`);\n        throw error;\n      }).then(halt => {\n        if (halt || !this.registerer) {\n          return Promise.resolve();\n        }\n\n        return this.registerer.register(this.registererRegisterOptions).then(() => {\n          return;\n        });\n      });\n    }; // Compute an amount of time in seconds to wait before sending another register request.\n    // This is a small attempt to avoid DOS attacking our own backend in the event that a\n    // relatively large number of clients sychonously keep retrying register reqeusts.\n    // This is known to happen when the backend goes down for a period and all clients\n    // are attempting to register again - the backend gets slammed with synced reqeusts.\n\n\n    const computeRegistrationTimeout = lowerBound => {\n      const upperBound = lowerBound * 2;\n      return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n    }; // Send register request after a delay\n\n\n    return new Promise((resolve, reject) => {\n      this.registrationAttemptTimeout = setTimeout(() => {\n        _register().then(() => {\n          this.registrationAttemptTimeout = undefined;\n          resolve();\n        }).catch(error => {\n          this.registrationAttemptTimeout = undefined;\n\n          if (error instanceof RequestPendingError) {\n            resolve();\n          } else {\n            reject(error);\n          }\n        });\n      }, withoutDelay ? 0 : computeRegistrationTimeout(this.options.registrationRetryInterval));\n    });\n  }\n  /** Helper function to remove media from html elements. */\n\n\n  cleanupMedia(session) {\n    const managedSession = this.sessionManaged(session);\n\n    if (!managedSession) {\n      throw new Error(\"Managed session does not exist.\");\n    }\n\n    if (managedSession.mediaLocal) {\n      if (managedSession.mediaLocal.video) {\n        managedSession.mediaLocal.video.srcObject = null;\n        managedSession.mediaLocal.video.pause();\n      }\n    }\n\n    if (managedSession.mediaRemote) {\n      if (managedSession.mediaRemote.audio) {\n        managedSession.mediaRemote.audio.srcObject = null;\n        managedSession.mediaRemote.audio.pause();\n      }\n\n      if (managedSession.mediaRemote.video) {\n        managedSession.mediaRemote.video.srcObject = null;\n        managedSession.mediaRemote.video.pause();\n      }\n    }\n  }\n  /** Helper function to enable/disable media tracks. */\n\n\n  enableReceiverTracks(session, enable) {\n    if (!this.sessionExists(session)) {\n      throw new Error(\"Session does not exist.\");\n    }\n\n    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    sessionDescriptionHandler.enableReceiverTracks(enable);\n  }\n  /** Helper function to enable/disable media tracks. */\n\n\n  enableSenderTracks(session, enable) {\n    if (!this.sessionExists(session)) {\n      throw new Error(\"Session does not exist.\");\n    }\n\n    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    sessionDescriptionHandler.enableSenderTracks(enable);\n  }\n  /**\n   * Setup session delegate and state change handler.\n   * @param session - Session to setup.\n   * @param referralInviterOptions - Options for any Inviter created as result of a REFER.\n   */\n\n\n  initSession(session, referralInviterOptions) {\n    // Add the session\n    this.sessionAdd(session); // Call session created callback\n\n    if (this.delegate && this.delegate.onCallCreated) {\n      this.delegate.onCallCreated(session);\n    } // Setup session state change handler\n\n\n    session.stateChange.addListener(state => {\n      this.logger.log(`[${session.id}] Session state changed to ${state}`);\n\n      switch (state) {\n        case SessionState.Initial:\n          break;\n\n        case SessionState.Establishing:\n          break;\n\n        case SessionState.Established:\n          this.setupLocalMedia(session);\n          this.setupRemoteMedia(session);\n\n          if (this.delegate && this.delegate.onCallAnswered) {\n            this.delegate.onCallAnswered(session);\n          }\n\n          break;\n\n        case SessionState.Terminating: // fall through\n\n        case SessionState.Terminated:\n          // This will already have executed if/when we fall\n          // through from Terminating and thus the managed\n          // session may already have been cleaned up.\n          if (this.sessionExists(session)) {\n            this.cleanupMedia(session);\n            this.sessionRemove(session);\n\n            if (this.delegate && this.delegate.onCallHangup) {\n              this.delegate.onCallHangup(session);\n            }\n          }\n\n          break;\n\n        default:\n          throw new Error(\"Unknown session state.\");\n      }\n    }); // TODO: Any existing onInfo or onRefer delegate gets clobbered here.\n    // Setup delegate\n\n    session.delegate = session.delegate || {};\n\n    session.delegate.onInfo = info => {\n      // As RFC 6086 states, sending DTMF via INFO is not standardized...\n      //\n      // Companies have been using INFO messages in order to transport\n      // Dual-Tone Multi-Frequency (DTMF) tones.  All mechanisms are\n      // proprietary and have not been standardized.\n      // https://tools.ietf.org/html/rfc6086#section-2\n      //\n      // It is however widely supported based on this draft:\n      // https://tools.ietf.org/html/draft-kaplan-dispatch-info-dtmf-package-00\n      var _a; // FIXME: TODO: We should reject correctly...\n      //\n      // If a UA receives an INFO request associated with an Info Package that\n      // the UA has not indicated willingness to receive, the UA MUST send a\n      // 469 (Bad Info Package) response (see Section 11.6), which contains a\n      // Recv-Info header field with Info Packages for which the UA is willing\n      // to receive INFO requests.\n      // https://tools.ietf.org/html/rfc6086#section-4.2.2\n      // No delegate\n\n\n      if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === undefined) {\n        info.reject();\n        return;\n      } // Invalid content type\n\n\n      const contentType = info.request.getHeader(\"content-type\");\n\n      if (!contentType || !/^application\\/dtmf-relay/i.exec(contentType)) {\n        info.reject();\n        return;\n      } // Invalid body\n\n\n      const body = info.request.body.split(\"\\r\\n\", 2);\n\n      if (body.length !== 2) {\n        info.reject();\n        return;\n      } // Invalid tone\n\n\n      let tone;\n      const toneRegExp = /^(Signal\\s*?=\\s*?)([0-9A-D#*]{1})(\\s)?.*/;\n\n      if (body[0] !== undefined && toneRegExp.test(body[0])) {\n        tone = body[0].replace(toneRegExp, \"$2\");\n      }\n\n      if (!tone) {\n        info.reject();\n        return;\n      } // Invalid duration\n\n\n      let duration;\n      const durationRegExp = /^(Duration\\s?=\\s?)([0-9]{1,4})(\\s)?.*/;\n\n      if (body[1] !== undefined && durationRegExp.test(body[1])) {\n        duration = parseInt(body[1].replace(durationRegExp, \"$2\"), 10);\n      }\n\n      if (!duration) {\n        info.reject();\n        return;\n      }\n\n      info.accept().then(() => {\n        if (this.delegate && this.delegate.onCallDTMFReceived) {\n          if (!tone || !duration) {\n            throw new Error(\"Tone or duration undefined.\");\n          }\n\n          this.delegate.onCallDTMFReceived(session, tone, duration);\n        }\n      }).catch(error => {\n        this.logger.error(error.message);\n      });\n    };\n\n    session.delegate.onRefer = referral => {\n      referral.accept().then(() => this.sendInvite(referral.makeInviter(referralInviterOptions), referralInviterOptions)).catch(error => {\n        this.logger.error(error.message);\n      });\n    };\n  }\n  /**\n   * Periodically send OPTIONS pings and disconnect when a ping fails.\n   * @param requestURI - Request URI to target\n   * @param fromURI - From URI\n   * @param toURI - To URI\n   */\n\n\n  optionsPingRun(requestURI, fromURI, toURI) {\n    // Guard against nvalid interval\n    if (this.options.optionsPingInterval < 1) {\n      throw new Error(\"Invalid options ping interval.\");\n    } // Guard against sending a ping when there is one outstanading\n\n\n    if (this.optionsPingRunning) {\n      return;\n    }\n\n    this.optionsPingRunning = true; // Setup next ping to run in future\n\n    this.optionsPingTimeout = setTimeout(() => {\n      this.optionsPingTimeout = undefined; // If ping succeeds...\n\n      const onPingSuccess = () => {\n        // record success or failure\n        this.optionsPingFailure = false; // if we are still running, queue up the next ping\n\n        if (this.optionsPingRunning) {\n          this.optionsPingRunning = false;\n          this.optionsPingRun(requestURI, fromURI, toURI);\n        }\n      }; // If ping fails...\n\n\n      const onPingFailure = () => {\n        this.logger.error(\"OPTIONS ping failed\"); // record success or failure\n\n        this.optionsPingFailure = true; // stop running\n\n        this.optionsPingRunning = false; // disconnect the transport\n\n        this.userAgent.transport.disconnect().catch(error => this.logger.error(error));\n      }; // Create an OPTIONS request message\n\n\n      const core = this.userAgent.userAgentCore;\n      const message = core.makeOutgoingRequestMessage(\"OPTIONS\", requestURI, fromURI, toURI, {}); // Send the request message\n\n      this.optionsPingRequest = core.request(message, {\n        onAccept: () => {\n          this.optionsPingRequest = undefined;\n          onPingSuccess();\n        },\n        onReject: response => {\n          this.optionsPingRequest = undefined; // Ping fails on following responses...\n          // - 408 Request Timeout (no response was received)\n          // - 503 Service Unavailable (a transport layer error occured)\n\n          if (response.message.statusCode === 408 || response.message.statusCode === 503) {\n            onPingFailure();\n          } else {\n            onPingSuccess();\n          }\n        }\n      });\n    }, this.options.optionsPingInterval * 1000);\n  }\n  /**\n   * Start sending OPTIONS pings.\n   */\n\n\n  optionsPingStart() {\n    this.logger.log(`OPTIONS pings started`); // Create the URIs needed to send OPTIONS pings\n\n    let requestURI, fromURI, toURI;\n\n    if (this.options.optionsPingRequestURI) {\n      // Use whatever specific RURI is provided.\n      requestURI = UserAgent.makeURI(this.options.optionsPingRequestURI);\n\n      if (!requestURI) {\n        throw new Error(\"Failed to create Request URI.\");\n      } // Use the user agent's contact URI for From and To URIs\n\n\n      fromURI = this.userAgent.contact.uri.clone();\n      toURI = this.userAgent.contact.uri.clone();\n    } else if (this.options.aor) {\n      // Otherwise use the AOR provided to target the assocated registrar server.\n      const uri = UserAgent.makeURI(this.options.aor);\n\n      if (!uri) {\n        throw new Error(\"Failed to create URI.\");\n      }\n\n      requestURI = uri.clone();\n      requestURI.user = undefined; // target the registrar server\n\n      fromURI = uri.clone();\n      toURI = uri.clone();\n    } else {\n      this.logger.error(\"You have enabled sending OPTIONS pings and as such you must provide either \" + \"a) an AOR to register, or b) an RURI to use for the target of the OPTIONS ping requests. \");\n      return;\n    } // Send the OPTIONS pings\n\n\n    this.optionsPingRun(requestURI, fromURI, toURI);\n  }\n  /**\n   * Stop sending OPTIONS pings.\n   */\n\n\n  optionsPingStop() {\n    this.logger.log(`OPTIONS pings stopped`);\n    this.optionsPingRunning = false;\n    this.optionsPingFailure = false;\n\n    if (this.optionsPingRequest) {\n      this.optionsPingRequest.dispose();\n      this.optionsPingRequest = undefined;\n    }\n\n    if (this.optionsPingTimeout) {\n      clearTimeout(this.optionsPingTimeout);\n      this.optionsPingTimeout = undefined;\n    }\n  }\n  /** Helper function to init send then send invite. */\n\n\n  async sendInvite(inviter, inviterOptions, inviterInviteOptions) {\n    // Initialize our session\n    this.initSession(inviter, inviterOptions); // Send the INVITE\n\n    return inviter.invite(inviterInviteOptions).then(() => {\n      this.logger.log(`[${inviter.id}] Sent INVITE`);\n    });\n  }\n  /** Helper function to add a session to the ones we are managing. */\n\n\n  sessionAdd(session) {\n    const managedSession = this.options.managedSessionFactory(this, session);\n    this.managedSessions.push(managedSession);\n  }\n  /** Helper function to check if the session is one we are managing. */\n\n\n  sessionExists(session) {\n    return this.sessionManaged(session) !== undefined;\n  }\n  /** Helper function to check if the session is one we are managing. */\n\n\n  sessionManaged(session) {\n    return this.managedSessions.find(el => el.session.id === session.id);\n  }\n  /** Helper function to remoce a session from the ones we are managing. */\n\n\n  sessionRemove(session) {\n    this.managedSessions = this.managedSessions.filter(el => el.session.id !== session.id);\n  }\n  /**\n   * Puts Session on hold.\n   * @param session - The session to set.\n   * @param hold - Hold on if true, off if false.\n   */\n\n\n  async setHold(session, hold) {\n    if (!this.sessionExists(session)) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    } // Just resolve if we are already in correct state\n\n\n    if (this.isHeld(session) === hold) {\n      return Promise.resolve();\n    }\n\n    const sessionDescriptionHandler = session.sessionDescriptionHandler;\n\n    if (!(sessionDescriptionHandler instanceof SessionDescriptionHandler)) {\n      throw new Error(\"Session's session description handler not instance of SessionDescriptionHandler.\");\n    }\n\n    const options = {\n      requestDelegate: {\n        onAccept: () => {\n          const managedSession = this.sessionManaged(session);\n\n          if (managedSession !== undefined) {\n            managedSession.held = hold;\n            this.enableReceiverTracks(session, !managedSession.held);\n            this.enableSenderTracks(session, !managedSession.held && !managedSession.muted);\n\n            if (this.delegate && this.delegate.onCallHold) {\n              this.delegate.onCallHold(session, managedSession.held);\n            }\n          }\n        },\n        onReject: () => {\n          this.logger.warn(`[${session.id}] Re-invite request was rejected`);\n          const managedSession = this.sessionManaged(session);\n\n          if (managedSession !== undefined) {\n            managedSession.held = !hold; // this was preemptively set so undo on failure\n\n            this.enableReceiverTracks(session, !managedSession.held);\n            this.enableSenderTracks(session, !managedSession.held && !managedSession.muted);\n\n            if (this.delegate && this.delegate.onCallHold) {\n              this.delegate.onCallHold(session, managedSession.held);\n            }\n          }\n        }\n      }\n    }; // Session properties used to pass options to the SessionDescriptionHandler:\n    //\n    // 1) Session.sessionDescriptionHandlerOptions\n    //    SDH options for the initial INVITE transaction.\n    //    - Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n    //\n    // 2) Session.sessionDescriptionHandlerOptionsReInvite\n    //    SDH options for re-INVITE transactions.\n    //    - Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n    //    - May be set directly at anytime.\n    //    - May optionally be set via constructor option.\n    //    - May optionally be set via options passed to Session.invite().\n\n    const sessionDescriptionHandlerOptions = session.sessionDescriptionHandlerOptionsReInvite;\n    sessionDescriptionHandlerOptions.hold = hold;\n    session.sessionDescriptionHandlerOptionsReInvite = sessionDescriptionHandlerOptions; // Preemptively and optimistically set held state (but do not call delegate).\n\n    const managedSession = this.sessionManaged(session);\n\n    if (!managedSession) {\n      throw new Error(\"Managed session is undefiend.\");\n    }\n\n    managedSession.held = hold; // Send re-INVITE\n\n    return session.invite(options).then(() => {\n      // Preemptively enable/disable tracks\n      const managedSession = this.sessionManaged(session);\n\n      if (managedSession !== undefined) {\n        this.enableReceiverTracks(session, !managedSession.held);\n        this.enableSenderTracks(session, !managedSession.held && !managedSession.muted);\n      }\n    }).catch(error => {\n      managedSession.held = !hold; // was preemptively set so undo on failure\n\n      if (error instanceof RequestPendingError) {\n        this.logger.error(`[${session.id}] A hold request is already in progress.`);\n      }\n\n      throw error;\n    });\n  }\n  /**\n   * Puts Session on mute.\n   * @param session - The session to mute.\n   * @param mute - Mute on if true, off if false.\n   */\n\n\n  setMute(session, mute) {\n    if (!this.sessionExists(session)) {\n      this.logger.warn(`[${session.id}] A session is required to enabled/disable media tracks`);\n      return;\n    }\n\n    if (session.state !== SessionState.Established) {\n      this.logger.warn(`[${session.id}] An established session is required to enable/disable media tracks`);\n      return;\n    }\n\n    const managedSession = this.sessionManaged(session);\n\n    if (managedSession !== undefined) {\n      managedSession.muted = mute;\n      this.enableSenderTracks(session, !managedSession.held && !managedSession.muted);\n    }\n  }\n  /** Helper function to attach local media to html elements. */\n\n\n  setupLocalMedia(session) {\n    const managedSession = this.sessionManaged(session);\n\n    if (!managedSession) {\n      throw new Error(\"Managed session does not exist.\");\n    } // Get the local media element, if any, from the and configuraiton options\n    // and save the info with the managed session so we can clean it up later.\n\n\n    const mediaLocal = typeof this.options.media.local === \"function\" ? this.options.media.local(session) : this.options.media.local;\n    managedSession.mediaLocal = mediaLocal;\n    const mediaElement = mediaLocal === null || mediaLocal === void 0 ? void 0 : mediaLocal.video;\n\n    if (mediaElement) {\n      const localStream = this.getLocalMediaStream(session);\n\n      if (!localStream) {\n        throw new Error(\"Local media stream undefiend.\");\n      }\n\n      mediaElement.srcObject = localStream;\n      mediaElement.volume = 0;\n      mediaElement.play().catch(error => {\n        this.logger.error(`[${session.id}] Failed to play local media`);\n        this.logger.error(error.message);\n      });\n    }\n  }\n  /** Helper function to attach remote media to html elements. */\n\n\n  setupRemoteMedia(session) {\n    const managedSession = this.sessionManaged(session);\n\n    if (!managedSession) {\n      throw new Error(\"Managed session does not exist.\");\n    } // Get the remote media element, if any, from the and configuraiton options\n    // and save the info with the managed session so we can clean it up later.\n\n\n    const mediaRemote = typeof this.options.media.remote === \"function\" ? this.options.media.remote(session) : this.options.media.remote;\n    managedSession.mediaRemote = mediaRemote;\n    const mediaElement = (mediaRemote === null || mediaRemote === void 0 ? void 0 : mediaRemote.video) || (mediaRemote === null || mediaRemote === void 0 ? void 0 : mediaRemote.audio);\n\n    if (mediaElement) {\n      const remoteStream = this.getRemoteMediaStream(session);\n\n      if (!remoteStream) {\n        throw new Error(\"Remote media stream undefiend.\");\n      }\n\n      mediaElement.autoplay = true; // Safari hack, because you cannot call .play() from a non user action\n\n      mediaElement.srcObject = remoteStream;\n      mediaElement.play().catch(error => {\n        this.logger.error(`[${session.id}] Failed to play remote media`);\n        this.logger.error(error.message);\n      });\n\n      remoteStream.onaddtrack = () => {\n        this.logger.log(`Remote media onaddtrack`);\n        mediaElement.load(); // Safari hack, as it doesn't work otheriwse\n\n        mediaElement.play().catch(error => {\n          this.logger.error(`[${session.id}] Failed to play remote media`);\n          this.logger.error(error.message);\n        });\n      };\n    }\n  }\n  /**\n   * End a session.\n   * @param session - The session to terminate.\n   * @remarks\n   * Send a BYE request, CANCEL request or reject response to end the current Session.\n   * Resolves when the request/response is sent, otherwise rejects.\n   * Use `onCallHangup` delegate method to determine if and when Session is terminated.\n   */\n\n\n  async terminate(session) {\n    this.logger.log(`[${session.id}] Terminating...`);\n\n    switch (session.state) {\n      case SessionState.Initial:\n        if (session instanceof Inviter) {\n          return session.cancel().then(() => {\n            this.logger.log(`[${session.id}] Inviter never sent INVITE (canceled)`);\n          });\n        } else if (session instanceof Invitation) {\n          return session.reject().then(() => {\n            this.logger.log(`[${session.id}] Invitation rejected (sent 480)`);\n          });\n        } else {\n          throw new Error(\"Unknown session type.\");\n        }\n\n      case SessionState.Establishing:\n        if (session instanceof Inviter) {\n          return session.cancel().then(() => {\n            this.logger.log(`[${session.id}] Inviter canceled (sent CANCEL)`);\n          });\n        } else if (session instanceof Invitation) {\n          return session.reject().then(() => {\n            this.logger.log(`[${session.id}] Invitation rejected (sent 480)`);\n          });\n        } else {\n          throw new Error(\"Unknown session type.\");\n        }\n\n      case SessionState.Established:\n        return session.bye().then(() => {\n          this.logger.log(`[${session.id}] Session ended (sent BYE)`);\n        });\n\n      case SessionState.Terminating:\n        break;\n\n      case SessionState.Terminated:\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    this.logger.log(`[${session.id}] Terminating in state ${session.state}, no action taken`);\n    return Promise.resolve();\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}