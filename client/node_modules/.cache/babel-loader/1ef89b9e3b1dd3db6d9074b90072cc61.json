{"ast":null,"code":"import { NameAddrHeader } from \"../../grammar/name-addr-header.js\";\nimport { getBody, isBody } from \"../messages/body.js\";\nimport { C } from \"../messages/methods/constants.js\";\nimport { IncomingRequestMessage } from \"../messages/incoming-request-message.js\";\nimport { IncomingResponseMessage } from \"../messages/incoming-response-message.js\";\nimport { OutgoingRequestMessage } from \"../messages/outgoing-request-message.js\";\nimport { SessionState } from \"../session/session.js\";\nimport { SignalingState } from \"../session/session.js\";\nimport { Timers } from \"../timers.js\";\nimport { InviteClientTransaction } from \"../transactions/invite-client-transaction.js\";\nimport { InviteServerTransaction } from \"../transactions/invite-server-transaction.js\";\nimport { TransactionState } from \"../transactions/transaction-state.js\";\nimport { ByeUserAgentClient } from \"../user-agents/bye-user-agent-client.js\";\nimport { ByeUserAgentServer } from \"../user-agents/bye-user-agent-server.js\";\nimport { InfoUserAgentClient } from \"../user-agents/info-user-agent-client.js\";\nimport { InfoUserAgentServer } from \"../user-agents/info-user-agent-server.js\";\nimport { MessageUserAgentClient } from \"../user-agents/message-user-agent-client.js\";\nimport { MessageUserAgentServer } from \"../user-agents/message-user-agent-server.js\";\nimport { NotifyUserAgentClient } from \"../user-agents/notify-user-agent-client.js\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server.js\";\nimport { PrackUserAgentClient } from \"../user-agents/prack-user-agent-client.js\";\nimport { PrackUserAgentServer } from \"../user-agents/prack-user-agent-server.js\";\nimport { ReInviteUserAgentClient } from \"../user-agents/re-invite-user-agent-client.js\";\nimport { ReInviteUserAgentServer } from \"../user-agents/re-invite-user-agent-server.js\";\nimport { ReferUserAgentClient } from \"../user-agents/refer-user-agent-client.js\";\nimport { ReferUserAgentServer } from \"../user-agents/refer-user-agent-server.js\";\nimport { Dialog } from \"./dialog.js\";\n/**\n * Session Dialog.\n * @public\n */\n\nexport class SessionDialog extends Dialog {\n  constructor(initialTransaction, core, state, delegate) {\n    super(core, state);\n    this.initialTransaction = initialTransaction;\n    /** The state of the offer/answer exchange. */\n\n    this._signalingState = SignalingState.Initial;\n    /** True if waiting for an ACK to the initial transaction 2xx (UAS only). */\n\n    this.ackWait = false;\n    /** True if processing an ACK to the initial transaction 2xx (UAS only). */\n\n    this.ackProcessing = false;\n    this.delegate = delegate;\n\n    if (initialTransaction instanceof InviteServerTransaction) {\n      // If we're created by an invite server transaction, we're\n      // going to be waiting for an ACK if are to be confirmed.\n      this.ackWait = true;\n    } // If we're confirmed upon creation start the retransmitting whatever\n    // the 2xx final response was that confirmed us into existence.\n\n\n    if (!this.early) {\n      this.start2xxRetransmissionTimer();\n    }\n\n    this.signalingStateTransition(initialTransaction.request);\n    this.logger = core.loggerFactory.getLogger(\"sip.invite-dialog\");\n    this.logger.log(`INVITE dialog ${this.id} constructed`);\n  }\n\n  dispose() {\n    super.dispose();\n    this._signalingState = SignalingState.Closed;\n    this._offer = undefined;\n    this._answer = undefined;\n\n    if (this.invite2xxTimer) {\n      clearTimeout(this.invite2xxTimer);\n      this.invite2xxTimer = undefined;\n    } // The UAS MUST still respond to any pending requests received for that\n    // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n    // be generated to those pending requests.\n    // https://tools.ietf.org/html/rfc3261#section-15.1.2\n    // TODO:\n    // this.userAgentServers.forEach((uas) => uas.reply(487));\n\n\n    this.logger.log(`INVITE dialog ${this.id} destroyed`);\n  } // FIXME: Need real state machine\n\n\n  get sessionState() {\n    if (this.early) {\n      return SessionState.Early;\n    } else if (this.ackWait) {\n      return SessionState.AckWait;\n    } else if (this._signalingState === SignalingState.Closed) {\n      return SessionState.Terminated;\n    } else {\n      return SessionState.Confirmed;\n    }\n  }\n  /** The state of the offer/answer exchange. */\n\n\n  get signalingState() {\n    return this._signalingState;\n  }\n  /** The current offer. Undefined unless signaling state HaveLocalOffer, HaveRemoteOffer, of Stable. */\n\n\n  get offer() {\n    return this._offer;\n  }\n  /** The current answer. Undefined unless signaling state Stable. */\n\n\n  get answer() {\n    return this._answer;\n  }\n  /** Confirm the dialog. Only matters if dialog is currently early. */\n\n\n  confirm() {\n    // When we're confirmed start the retransmitting whatever\n    // the 2xx final response that may have confirmed us.\n    if (this.early) {\n      this.start2xxRetransmissionTimer();\n    }\n\n    super.confirm();\n  }\n  /** Re-confirm the dialog. Only matters if handling re-INVITE request. */\n\n\n  reConfirm() {\n    // When we're confirmed start the retransmitting whatever\n    // the 2xx final response that may have confirmed us.\n    if (this.reinviteUserAgentServer) {\n      this.startReInvite2xxRetransmissionTimer();\n    }\n  }\n  /**\n   * The UAC core MUST generate an ACK request for each 2xx received from\n   * the transaction layer.  The header fields of the ACK are constructed\n   * in the same way as for any request sent within a dialog (see Section\n   * 12) with the exception of the CSeq and the header fields related to\n   * authentication.  The sequence number of the CSeq header field MUST be\n   * the same as the INVITE being acknowledged, but the CSeq method MUST\n   * be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n   * the 2xx contains an offer (based on the rules above), the ACK MUST\n   * carry an answer in its body.  If the offer in the 2xx response is not\n   * acceptable, the UAC core MUST generate a valid answer in the ACK and\n   * then send a BYE immediately.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n   * @param options - ACK options bucket.\n   */\n\n\n  ack() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(`INVITE dialog ${this.id} sending ACK request`);\n    let transaction;\n\n    if (this.reinviteUserAgentClient) {\n      // We're sending ACK for a re-INVITE\n      if (!(this.reinviteUserAgentClient.transaction instanceof InviteClientTransaction)) {\n        throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n      }\n\n      transaction = this.reinviteUserAgentClient.transaction;\n      this.reinviteUserAgentClient = undefined;\n    } else {\n      // We're sending ACK for the initial INVITE\n      if (!(this.initialTransaction instanceof InviteClientTransaction)) {\n        throw new Error(\"Initial transaction not instance of InviteClientTransaction.\");\n      }\n\n      transaction = this.initialTransaction;\n    }\n\n    const message = this.createOutgoingRequestMessage(C.ACK, {\n      cseq: transaction.request.cseq,\n      extraHeaders: options.extraHeaders,\n      body: options.body\n    });\n    transaction.ackResponse(message); // See InviteClientTransaction for details.\n\n    this.signalingStateTransition(message);\n    return {\n      message\n    };\n  }\n  /**\n   * Terminating a Session\n   *\n   * This section describes the procedures for terminating a session\n   * established by SIP.  The state of the session and the state of the\n   * dialog are very closely related.  When a session is initiated with an\n   * INVITE, each 1xx or 2xx response from a distinct UAS creates a\n   * dialog, and if that response completes the offer/answer exchange, it\n   * also creates a session.  As a result, each session is \"associated\"\n   * with a single dialog - the one which resulted in its creation.  If an\n   * initial INVITE generates a non-2xx final response, that terminates\n   * all sessions (if any) and all dialogs (if any) that were created\n   * through responses to the request.  By virtue of completing the\n   * transaction, a non-2xx final response also prevents further sessions\n   * from being created as a result of the INVITE.  The BYE request is\n   * used to terminate a specific session or attempted session.  In this\n   * case, the specific session is the one with the peer UA on the other\n   * side of the dialog.  When a BYE is received on a dialog, any session\n   * associated with that dialog SHOULD terminate.  A UA MUST NOT send a\n   * BYE outside of a dialog.  The caller's UA MAY send a BYE for either\n   * confirmed or early dialogs, and the callee's UA MAY send a BYE on\n   * confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n   *\n   * However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n   * until it has received an ACK for its 2xx response or until the server\n   * transaction times out.  If no SIP extensions have defined other\n   * application layer states associated with the dialog, the BYE also\n   * terminates the dialog.\n   *\n   * https://tools.ietf.org/html/rfc3261#section-15\n   * FIXME: Make these proper Exceptions...\n   * @param options - BYE options bucket.\n   * @returns\n   * Throws `Error` if callee's UA attempts a BYE on an early dialog.\n   * Throws `Error` if callee's UA attempts a BYE on a confirmed dialog\n   *                while it's waiting on the ACK for its 2xx response.\n   */\n\n\n  bye(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending BYE request`); // The caller's UA MAY send a BYE for either\n    // confirmed or early dialogs, and the callee's UA MAY send a BYE on\n    // confirmed dialogs, but MUST NOT send a BYE on early dialogs.\n    //\n    // However, the callee's UA MUST NOT send a BYE on a confirmed dialog\n    // until it has received an ACK for its 2xx response or until the server\n    // transaction times out.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n    if (this.initialTransaction instanceof InviteServerTransaction) {\n      if (this.early) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"UAS MUST NOT send a BYE on early dialogs.\");\n      }\n\n      if (this.ackWait && this.initialTransaction.state !== TransactionState.Terminated) {\n        // FIXME: TODO: This should throw a proper exception.\n        throw new Error(\"UAS MUST NOT send a BYE on a confirmed dialog \" + \"until it has received an ACK for its 2xx response \" + \"or until the server transaction times out.\");\n      }\n    } // A BYE request is constructed as would any other request within a\n    // dialog, as described in Section 12.\n    //\n    // Once the BYE is constructed, the UAC core creates a new non-INVITE\n    // client transaction, and passes it the BYE request.  The UAC MUST\n    // consider the session terminated (and therefore stop sending or\n    // listening for media) as soon as the BYE request is passed to the\n    // client transaction.  If the response for the BYE is a 481\n    // (Call/Transaction Does Not Exist) or a 408 (Request Timeout) or no\n    // response at all is received for the BYE (that is, a timeout is\n    // returned by the client transaction), the UAC MUST consider the\n    // session and the dialog terminated.\n    // https://tools.ietf.org/html/rfc3261#section-15.1.1\n\n\n    return new ByeUserAgentClient(this, delegate, options);\n  }\n  /**\n   * An INFO request can be associated with an Info Package (see\n   * Section 5), or associated with a legacy INFO usage (see Section 2).\n   *\n   * The construction of the INFO request is the same as any other\n   * non-target refresh request within an existing invite dialog usage as\n   * described in Section 12.2 of RFC 3261.\n   * https://tools.ietf.org/html/rfc6086#section-4.2.1\n   * @param options - Options bucket.\n   */\n\n\n  info(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending INFO request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    return new InfoUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Modifying an Existing Session\n   *\n   * A successful INVITE request (see Section 13) establishes both a\n   * dialog between two user agents and a session using the offer-answer\n   * model.  Section 12 explains how to modify an existing dialog using a\n   * target refresh request (for example, changing the remote target URI\n   * of the dialog).  This section describes how to modify the actual\n   * session.  This modification can involve changing addresses or ports,\n   * adding a media stream, deleting a media stream, and so on.  This is\n   * accomplished by sending a new INVITE request within the same dialog\n   * that established the session.  An INVITE request sent within an\n   * existing dialog is known as a re-INVITE.\n   *\n   *    Note that a single re-INVITE can modify the dialog and the\n   *    parameters of the session at the same time.\n   *\n   * Either the caller or callee can modify an existing session.\n   * https://tools.ietf.org/html/rfc3261#section-14\n   * @param options - Options bucket\n   */\n\n\n  invite(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending INVITE request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    } // Note that a UAC MUST NOT initiate a new INVITE transaction within a\n    // dialog while another INVITE transaction is in progress in either\n    // direction.\n    //\n    //    1. If there is an ongoing INVITE client transaction, the TU MUST\n    //       wait until the transaction reaches the completed or terminated\n    //       state before initiating the new INVITE.\n    //\n    //    2. If there is an ongoing INVITE server transaction, the TU MUST\n    //       wait until the transaction reaches the confirmed or terminated\n    //       state before initiating the new INVITE.\n    //\n    // However, a UA MAY initiate a regular transaction while an INVITE\n    // transaction is in progress.  A UA MAY also initiate an INVITE\n    // transaction while a regular transaction is in progress.\n    // https://tools.ietf.org/html/rfc3261#section-14.1\n\n\n    if (this.reinviteUserAgentClient) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"There is an ongoing re-INVITE client transaction.\");\n    }\n\n    if (this.reinviteUserAgentServer) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"There is an ongoing re-INVITE server transaction.\");\n    }\n\n    return new ReInviteUserAgentClient(this, delegate, options);\n  }\n  /**\n   * A UAC MAY associate a MESSAGE request with an existing dialog.  If a\n   * MESSAGE request is sent within a dialog, it is \"associated\" with any\n   * media session or sessions associated with that dialog.\n   * https://tools.ietf.org/html/rfc3428#section-4\n   * @param options - Options bucket.\n   */\n\n\n  message(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending MESSAGE request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    const message = this.createOutgoingRequestMessage(C.MESSAGE, options);\n    return new MessageUserAgentClient(this.core, message, delegate);\n  }\n  /**\n   * The NOTIFY mechanism defined in [2] MUST be used to inform the agent\n   * sending the REFER of the status of the reference.\n   * https://tools.ietf.org/html/rfc3515#section-2.4.4\n   * @param options - Options bucket.\n   */\n\n\n  notify(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending NOTIFY request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    }\n\n    return new NotifyUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Assuming the response is to be transmitted reliably, the UAC MUST\n   * create a new request with method PRACK.  This request is sent within\n   * the dialog associated with the provisional response (indeed, the\n   * provisional response may have created the dialog).  PRACK requests\n   * MAY contain bodies, which are interpreted according to their type and\n   * disposition.\n   * https://tools.ietf.org/html/rfc3262#section-4\n   * @param options - Options bucket.\n   */\n\n\n  prack(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending PRACK request`);\n    return new PrackUserAgentClient(this, delegate, options);\n  }\n  /**\n   * REFER is a SIP request and is constructed as defined in [1].  A REFER\n   * request MUST contain exactly one Refer-To header field value.\n   * https://tools.ietf.org/html/rfc3515#section-2.4.1\n   * @param options - Options bucket.\n   */\n\n\n  refer(delegate, options) {\n    this.logger.log(`INVITE dialog ${this.id} sending REFER request`);\n\n    if (this.early) {\n      // FIXME: TODO: This should throw a proper exception.\n      throw new Error(\"Dialog not confirmed.\");\n    } // FIXME: TODO: Validate Refer-To header field value.\n\n\n    return new ReferUserAgentClient(this, delegate, options);\n  }\n  /**\n   * Requests sent within a dialog, as any other requests, are atomic.  If\n   * a particular request is accepted by the UAS, all the state changes\n   * associated with it are performed.  If the request is rejected, none\n   * of the state changes are performed.\n   * https://tools.ietf.org/html/rfc3261#section-12.2.2\n   * @param message - Incoming request message within this dialog.\n   */\n\n\n  receiveRequest(message) {\n    this.logger.log(`INVITE dialog ${this.id} received ${message.method} request`); // Response retransmissions cease when an ACK request for the\n    // response is received.  This is independent of whatever transport\n    // protocols are used to send the response.\n    // https://tools.ietf.org/html/rfc6026#section-8.1\n\n    if (message.method === C.ACK) {\n      // If ackWait is true, then this is the ACK to the initial INVITE,\n      // otherwise this is an ACK to an in dialog INVITE. In either case,\n      // guard to make sure the sequence number of the ACK matches the INVITE.\n      if (this.ackWait) {\n        if (this.initialTransaction instanceof InviteClientTransaction) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        if (this.initialTransaction.request.cseq !== message.cseq) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        } // Update before the delegate has a chance to handle the\n        // message as delegate may callback into this dialog.\n\n\n        this.ackWait = false;\n      } else {\n        if (!this.reinviteUserAgentServer) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        if (this.reinviteUserAgentServer.transaction.request.cseq !== message.cseq) {\n          this.logger.warn(`INVITE dialog ${this.id} received unexpected ${message.method} request, dropping.`);\n          return;\n        }\n\n        this.reinviteUserAgentServer = undefined;\n      }\n\n      this.signalingStateTransition(message);\n\n      if (this.delegate && this.delegate.onAck) {\n        const promiseOrVoid = this.delegate.onAck({\n          message\n        });\n\n        if (promiseOrVoid instanceof Promise) {\n          this.ackProcessing = true; // make sure this is always reset to false\n\n          promiseOrVoid.then(() => this.ackProcessing = false).catch(() => this.ackProcessing = false);\n        }\n      }\n\n      return;\n    } // Request within a dialog out of sequence guard.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    if (!this.sequenceGuard(message)) {\n      this.logger.log(`INVITE dialog ${this.id} rejected out of order ${message.method} request.`);\n      return;\n    } // Request within a dialog common processing.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    super.receiveRequest(message); // Handle various INVITE related cross-over, glare and race conditions\n\n    if (message.method === C.INVITE) {\n      // Hopefully this message is helpful...\n      const warning = () => {\n        const reason = this.ackWait ? \"waiting for initial ACK\" : \"processing initial ACK\";\n        this.logger.warn(`INVITE dialog ${this.id} received re-INVITE while ${reason}`);\n        let msg = \"RFC 5407 suggests the following to avoid this race condition... \";\n        msg += \" Note: Implementation issues are outside the scope of this document,\";\n        msg += \" but the following tip is provided for avoiding race conditions of\";\n        msg += \" this type.  The caller can delay sending re-INVITE F6 for some period\";\n        msg += \" of time (2 seconds, perhaps), after which the caller can reasonably\";\n        msg += \" assume that its ACK has been received.  Implementors can decouple the\";\n        msg += \" actions of the user (e.g., pressing the hold button) from the actions\";\n        msg += \" of the protocol (the sending of re-INVITE F6), so that the UA can\";\n        msg += \" behave like this.  In this case, it is the implementor's choice as to\";\n        msg += \" how long to wait.  In most cases, such an implementation may be\";\n        msg += \" useful to prevent the type of race condition shown in this section.\";\n        msg += \" This document expresses no preference about whether or not they\";\n        msg += \" should wait for an ACK to be delivered.  After considering the impact\";\n        msg += \" on user experience, implementors should decide whether or not to wait\";\n        msg += \" for a while, because the user experience depends on the\";\n        msg += \" implementation and has no direct bearing on protocol behavior.\";\n        this.logger.warn(msg);\n        return; // drop re-INVITE request message\n      }; // A UAS that receives a second INVITE before it sends the final\n      // response to a first INVITE with a lower CSeq sequence number on the\n      // same dialog MUST return a 500 (Server Internal Error) response to the\n      // second INVITE and MUST include a Retry-After header field with a\n      // randomly chosen value of between 0 and 10 seconds.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      const retryAfter = Math.floor(Math.random() * 10) + 1;\n      const extraHeaders = [`Retry-After: ${retryAfter}`]; // There may be ONLY ONE offer/answer negotiation in progress for a\n      // single dialog at any point in time.  Section 4 explains how to ensure\n      // this.\n      // https://tools.ietf.org/html/rfc6337#section-2.2\n\n      if (this.ackProcessing) {\n        // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n        //           transaction associated with an offer/answer is incomplete,\n        //           a UA must reject another INVITE request with a 500\n        //           response.\n        // https://tools.ietf.org/html/rfc6337#section-4.3\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        warning();\n        return;\n      } // 3.1.4.  Callee Receives re-INVITE (Established State)  While in the\n      // Moratorium State (Case 1)\n      // https://tools.ietf.org/html/rfc5407#section-3.1.4\n      // 3.1.5.  Callee Receives re-INVITE (Established State) While in the\n      // Moratorium State (Case 2)\n      // https://tools.ietf.org/html/rfc5407#section-3.1.5\n\n\n      if (this.ackWait && this.signalingState !== SignalingState.Stable) {\n        // This scenario is basically the same as that of Section 3.1.4, but\n        // differs in sending an offer in the 200 and an answer in the ACK.  In\n        // contrast to the previous case, the offer in the 200 (F3) and the\n        // offer in the re-INVITE (F6) collide with each other.\n        //\n        // Bob sends a 491 to the re-INVITE (F6) since he is not able to\n        // properly handle a new request until he receives an answer.  (Note:\n        // 500 with a Retry-After header may be returned if the 491 response is\n        // understood to indicate request collision.  However, 491 is\n        // recommended here because 500 applies to so many cases that it is\n        // difficult to determine what the real problem was.)\n        // https://tools.ietf.org/html/rfc5407#section-3.1.5\n        // UAS-IsI:  While an INVITE server transaction is incomplete or ACK\n        //           transaction associated with an offer/answer is incomplete,\n        //           a UA must reject another INVITE request with a 500\n        //           response.\n        // https://tools.ietf.org/html/rfc6337#section-4.3\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        warning();\n        return;\n      } // A UAS that receives a second INVITE before it sends the final\n      // response to a first INVITE with a lower CSeq sequence number on the\n      // same dialog MUST return a 500 (Server Internal Error) response to the\n      // second INVITE and MUST include a Retry-After header field with a\n      // randomly chosen value of between 0 and 10 seconds.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      if (this.reinviteUserAgentServer) {\n        this.core.replyStateless(message, {\n          statusCode: 500,\n          extraHeaders\n        });\n        return;\n      } // A UAS that receives an INVITE on a dialog while an INVITE it had sent\n      // on that dialog is in progress MUST return a 491 (Request Pending)\n      // response to the received INVITE.\n      // https://tools.ietf.org/html/rfc3261#section-14.2\n\n\n      if (this.reinviteUserAgentClient) {\n        this.core.replyStateless(message, {\n          statusCode: 491\n        });\n        return;\n      }\n    } // Requests within a dialog MAY contain Record-Route and Contact header\n    // fields.  However, these requests do not cause the dialog's route set\n    // to be modified, although they may modify the remote target URI.\n    // Specifically, requests that are not target refresh requests do not\n    // modify the dialog's remote target URI, and requests that are target\n    // refresh requests do.  For dialogs that have been established with an\n    // INVITE, the only target refresh request defined is re-INVITE (see\n    // Section 14).  Other extensions may define different target refresh\n    // requests for dialogs established in other ways.\n    //\n    //    Note that an ACK is NOT a target refresh request.\n    //\n    // Target refresh requests only update the dialog's remote target URI,\n    // and not the route set formed from the Record-Route.  Updating the\n    // latter would introduce severe backwards compatibility problems with\n    // RFC 2543-compliant systems.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n\n    if (message.method === C.INVITE) {\n      // FIXME: parser needs to be typed...\n      const contact = message.parseHeader(\"contact\");\n\n      if (!contact) {\n        // TODO: Review to make sure this will never happen\n        throw new Error(\"Contact undefined.\");\n      }\n\n      if (!(contact instanceof NameAddrHeader)) {\n        throw new Error(\"Contact not instance of NameAddrHeader.\");\n      }\n\n      this.dialogState.remoteTarget = contact.uri;\n    } // Switch on method and then delegate.\n\n\n    switch (message.method) {\n      case C.BYE:\n        // A UAS core receiving a BYE request for an existing dialog MUST follow\n        // the procedures of Section 12.2.2 to process the request.  Once done,\n        // the UAS SHOULD terminate the session (and therefore stop sending and\n        // listening for media).  The only case where it can elect not to are\n        // multicast sessions, where participation is possible even if the other\n        // participant in the dialog has terminated its involvement in the\n        // session.  Whether or not it ends its participation on the session,\n        // the UAS core MUST generate a 2xx response to the BYE, and MUST pass\n        // that to the server transaction for transmission.\n        //\n        // The UAS MUST still respond to any pending requests received for that\n        // dialog.  It is RECOMMENDED that a 487 (Request Terminated) response\n        // be generated to those pending requests.\n        // https://tools.ietf.org/html/rfc3261#section-15.1.2\n        {\n          const uas = new ByeUserAgentServer(this, message);\n          this.delegate && this.delegate.onBye ? this.delegate.onBye(uas) : uas.accept();\n          this.dispose();\n        }\n        break;\n\n      case C.INFO:\n        // If a UA receives an INFO request associated with an Info Package that\n        // the UA has not indicated willingness to receive, the UA MUST send a\n        // 469 (Bad Info Package) response (see Section 11.6), which contains a\n        // Recv-Info header field with Info Packages for which the UA is willing\n        // to receive INFO requests.\n        {\n          const uas = new InfoUserAgentServer(this, message);\n          this.delegate && this.delegate.onInfo ? this.delegate.onInfo(uas) : uas.reject({\n            statusCode: 469,\n            extraHeaders: [\"Recv-Info:\"]\n          });\n        }\n        break;\n\n      case C.INVITE:\n        // If the new session description is not acceptable, the UAS can reject\n        // it by returning a 488 (Not Acceptable Here) response for the re-\n        // INVITE.  This response SHOULD include a Warning header field.\n        // https://tools.ietf.org/html/rfc3261#section-14.2\n        {\n          const uas = new ReInviteUserAgentServer(this, message);\n          this.signalingStateTransition(message);\n          this.delegate && this.delegate.onInvite ? this.delegate.onInvite(uas) : uas.reject({\n            statusCode: 488\n          }); // TODO: Warning header field.\n        }\n        break;\n\n      case C.MESSAGE:\n        {\n          const uas = new MessageUserAgentServer(this.core, message);\n          this.delegate && this.delegate.onMessage ? this.delegate.onMessage(uas) : uas.accept();\n        }\n        break;\n\n      case C.NOTIFY:\n        // https://tools.ietf.org/html/rfc3515#section-2.4.4\n        {\n          const uas = new NotifyUserAgentServer(this, message);\n          this.delegate && this.delegate.onNotify ? this.delegate.onNotify(uas) : uas.accept();\n        }\n        break;\n\n      case C.PRACK:\n        // https://tools.ietf.org/html/rfc3262#section-4\n        {\n          const uas = new PrackUserAgentServer(this, message);\n          this.delegate && this.delegate.onPrack ? this.delegate.onPrack(uas) : uas.accept();\n        }\n        break;\n\n      case C.REFER:\n        // https://tools.ietf.org/html/rfc3515#section-2.4.2\n        {\n          const uas = new ReferUserAgentServer(this, message);\n          this.delegate && this.delegate.onRefer ? this.delegate.onRefer(uas) : uas.reject();\n        }\n        break;\n\n      default:\n        {\n          this.logger.log(`INVITE dialog ${this.id} received unimplemented ${message.method} request`);\n          this.core.replyStateless(message, {\n            statusCode: 501\n          });\n        }\n        break;\n    }\n  }\n  /**\n   * Guard against out of order reliable provisional responses and retransmissions.\n   * Returns false if the response should be discarded, otherwise true.\n   * @param message - Incoming response message within this dialog.\n   */\n\n\n  reliableSequenceGuard(message) {\n    const statusCode = message.statusCode;\n\n    if (!statusCode) {\n      throw new Error(\"Status code undefined\");\n    }\n\n    if (statusCode > 100 && statusCode < 200) {\n      // If a provisional response is received for an initial request, and\n      // that response contains a Require header field containing the option\n      // tag 100rel, the response is to be sent reliably.  If the response is\n      // a 100 (Trying) (as opposed to 101 to 199), this option tag MUST be\n      // ignored, and the procedures below MUST NOT be used.\n      // https://tools.ietf.org/html/rfc3262#section-4\n      const requireHeader = message.getHeader(\"require\");\n      const rseqHeader = message.getHeader(\"rseq\");\n      const rseq = requireHeader && requireHeader.includes(\"100rel\") && rseqHeader ? Number(rseqHeader) : undefined;\n\n      if (rseq) {\n        // Handling of subsequent reliable provisional responses for the same\n        // initial request follows the same rules as above, with the following\n        // difference: reliable provisional responses are guaranteed to be in\n        // order.  As a result, if the UAC receives another reliable provisional\n        // response to the same request, and its RSeq value is not one higher\n        // than the value of the sequence number, that response MUST NOT be\n        // acknowledged with a PRACK, and MUST NOT be processed further by the\n        // UAC.  An implementation MAY discard the response, or MAY cache the\n        // response in the hopes of receiving the missing responses.\n        // https://tools.ietf.org/html/rfc3262#section-4\n        if (this.rseq && this.rseq + 1 !== rseq) {\n          return false;\n        } // Once a reliable provisional response is received, retransmissions of\n        // that response MUST be discarded.  A response is a retransmission when\n        // its dialog ID, CSeq, and RSeq match the original response.  The UAC\n        // MUST maintain a sequence number that indicates the most recently\n        // received in-order reliable provisional response for the initial\n        // request.  This sequence number MUST be maintained until a final\n        // response is received for the initial request.  Its value MUST be\n        // initialized to the RSeq header field in the first reliable\n        // provisional response received for the initial request.\n        // https://tools.ietf.org/html/rfc3262#section-4\n\n\n        this.rseq = this.rseq ? this.rseq + 1 : rseq;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * If not in a stable signaling state, rollback to prior stable signaling state.\n   */\n\n\n  signalingStateRollback() {\n    if (this._signalingState === SignalingState.HaveLocalOffer || this.signalingState === SignalingState.HaveRemoteOffer) {\n      if (this._rollbackOffer && this._rollbackAnswer) {\n        this._signalingState = SignalingState.Stable;\n        this._offer = this._rollbackOffer;\n        this._answer = this._rollbackAnswer;\n      }\n    }\n  }\n  /**\n   * Update the signaling state of the dialog.\n   * @param message - The message to base the update off of.\n   */\n\n\n  signalingStateTransition(message) {\n    const body = getBody(message); // No body, no session. No, woman, no cry.\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return;\n    } // We've got an existing offer and answer which we may wish to rollback to\n\n\n    if (this._signalingState === SignalingState.Stable) {\n      this._rollbackOffer = this._offer;\n      this._rollbackAnswer = this._answer;\n    } // We're in UAS role, receiving incoming request with session description\n\n\n    if (message instanceof IncomingRequestMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveRemoteOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAC role, receiving incoming response with session description\n\n\n    if (message instanceof IncomingResponseMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveRemoteOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAC role, sending outgoing request with session description\n\n\n    if (message instanceof OutgoingRequestMessage) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveLocalOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    } // We're in UAS role, sending outgoing response with session description\n\n\n    if (isBody(message)) {\n      switch (this._signalingState) {\n        case SignalingState.Initial:\n        case SignalingState.Stable:\n          this._signalingState = SignalingState.HaveLocalOffer;\n          this._offer = body;\n          this._answer = undefined;\n          break;\n\n        case SignalingState.HaveLocalOffer:\n          // You cannot make a new offer while one is in progress.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n          // FIXME: What to do here?\n          break;\n\n        case SignalingState.HaveRemoteOffer:\n          this._signalingState = SignalingState.Stable;\n          this._answer = body;\n          break;\n\n        case SignalingState.Closed:\n          break;\n\n        default:\n          throw new Error(\"Unexpected signaling state.\");\n      }\n    }\n  }\n\n  start2xxRetransmissionTimer() {\n    if (this.initialTransaction instanceof InviteServerTransaction) {\n      const transaction = this.initialTransaction; // Once the response has been constructed, it is passed to the INVITE\n      // server transaction.  In order to ensure reliable end-to-end\n      // transport of the response, it is necessary to periodically pass\n      // the response directly to the transport until the ACK arrives.  The\n      // 2xx response is passed to the transport with an interval that\n      // starts at T1 seconds and doubles for each retransmission until it\n      // reaches T2 seconds (T1 and T2 are defined in Section 17).\n      // Response retransmissions cease when an ACK request for the\n      // response is received.  This is independent of whatever transport\n      // protocols are used to send the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.1\n\n      let timeout = Timers.T1;\n\n      const retransmission = () => {\n        if (!this.ackWait) {\n          this.invite2xxTimer = undefined;\n          return;\n        }\n\n        this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n        transaction.retransmitAcceptedResponse();\n        timeout = Math.min(timeout * 2, Timers.T2);\n        this.invite2xxTimer = setTimeout(retransmission, timeout);\n      };\n\n      this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n      // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n      // terminated.  This is accomplished with a BYE, as described in Section 15.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n      const stateChanged = () => {\n        if (transaction.state === TransactionState.Terminated) {\n          transaction.removeStateChangeListener(stateChanged);\n\n          if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n          }\n\n          if (this.ackWait) {\n            if (this.delegate && this.delegate.onAckTimeout) {\n              this.delegate.onAckTimeout();\n            } else {\n              this.bye();\n            }\n          }\n        }\n      };\n\n      transaction.addStateChangeListener(stateChanged);\n    }\n  } // FIXME: Refactor\n\n\n  startReInvite2xxRetransmissionTimer() {\n    if (this.reinviteUserAgentServer && this.reinviteUserAgentServer.transaction instanceof InviteServerTransaction) {\n      const transaction = this.reinviteUserAgentServer.transaction; // Once the response has been constructed, it is passed to the INVITE\n      // server transaction.  In order to ensure reliable end-to-end\n      // transport of the response, it is necessary to periodically pass\n      // the response directly to the transport until the ACK arrives.  The\n      // 2xx response is passed to the transport with an interval that\n      // starts at T1 seconds and doubles for each retransmission until it\n      // reaches T2 seconds (T1 and T2 are defined in Section 17).\n      // Response retransmissions cease when an ACK request for the\n      // response is received.  This is independent of whatever transport\n      // protocols are used to send the response.\n      // https://tools.ietf.org/html/rfc6026#section-8.1\n\n      let timeout = Timers.T1;\n\n      const retransmission = () => {\n        if (!this.reinviteUserAgentServer) {\n          this.invite2xxTimer = undefined;\n          return;\n        }\n\n        this.logger.log(\"No ACK for 2xx response received, attempting retransmission\");\n        transaction.retransmitAcceptedResponse();\n        timeout = Math.min(timeout * 2, Timers.T2);\n        this.invite2xxTimer = setTimeout(retransmission, timeout);\n      };\n\n      this.invite2xxTimer = setTimeout(retransmission, timeout); // If the server retransmits the 2xx response for 64*T1 seconds without\n      // receiving an ACK, the dialog is confirmed, but the session SHOULD be\n      // terminated.  This is accomplished with a BYE, as described in Section 15.\n      // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n      const stateChanged = () => {\n        if (transaction.state === TransactionState.Terminated) {\n          transaction.removeStateChangeListener(stateChanged);\n\n          if (this.invite2xxTimer) {\n            clearTimeout(this.invite2xxTimer);\n            this.invite2xxTimer = undefined;\n          }\n\n          if (this.reinviteUserAgentServer) {// FIXME: TODO: What to do here\n          }\n        }\n      };\n\n      transaction.addStateChangeListener(stateChanged);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}