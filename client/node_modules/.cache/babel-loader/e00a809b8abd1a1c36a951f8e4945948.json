{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar mos_1 = require(\"./rtc/mos\");\n\nvar util_1 = require(\"./util\");\n\nvar getRTCStats = require('./rtc/stats').getRTCStats; // How many samples we use when testing metric thresholds\n\n\nvar SAMPLE_COUNT_METRICS = 5; // How many samples that need to cross the threshold to\n// raise or clear a warning.\n\nvar SAMPLE_COUNT_CLEAR = 0;\nvar SAMPLE_COUNT_RAISE = 3;\nvar SAMPLE_INTERVAL = 1000;\nvar WARNING_TIMEOUT = 5 * 1000;\nvar DEFAULT_THRESHOLDS = {\n  audioInputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  audioOutputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  bytesReceived: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  bytesSent: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  jitter: {\n    max: 30\n  },\n  mos: {\n    min: 3\n  },\n  packetsLostFraction: [{\n    max: 1\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7\n  }],\n  rtt: {\n    max: 400\n  }\n};\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\nfunction countHigh(max, values) {\n  return values.reduce(function (highCount, value) {\n    return highCount += value > max ? 1 : 0;\n  }, 0);\n}\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\n\nfunction countLow(min, values) {\n  return values.reduce(function (lowCount, value) {\n    return lowCount += value < min ? 1 : 0;\n  }, 0);\n}\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\n\n\nfunction calculateStandardDeviation(values) {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  var valueAverage = values.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / values.length;\n  var diffSquared = values.map(function (value) {\n    return Math.pow(value - valueAverage, 2);\n  });\n  var stdDev = Math.sqrt(diffSquared.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / diffSquared.length);\n  return stdDev;\n}\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\n\n\nfunction flattenSamples(sampleSets) {\n  return sampleSets.reduce(function (flat, current) {\n    return __spreadArrays(flat, current);\n  }, []);\n}\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\n\n\nvar StatsMonitor =\n/** @class */\nfunction (_super) {\n  __extends(StatsMonitor, _super);\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n\n\n  function StatsMonitor(options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A map of warnings with their raised time\n     */\n\n\n    _this._activeWarnings = new Map();\n    /**\n     * A map of stats with the number of exceeded thresholds\n     */\n\n    _this._currentStreaks = new Map();\n    /**\n     * Keeps track of input volumes in the last second\n     */\n\n    _this._inputVolumes = [];\n    /**\n     * Keeps track of output volumes in the last second\n     */\n\n    _this._outputVolumes = [];\n    /**\n     * Sample buffer. Saves most recent samples\n     */\n\n    _this._sampleBuffer = [];\n    /**\n     * Keeps track of supplemental sample values.\n     *\n     * Currently used for constant audio detection. Contains an array of volume\n     * samples for each sample interval.\n     */\n\n    _this._supplementalSampleBuffers = {\n      audioInputLevel: [],\n      audioOutputLevel: []\n    };\n    /**\n     * Whether warnings should be enabled\n     */\n\n    _this._warningsEnabled = true;\n    options = options || {};\n    _this._getRTCStats = options.getRTCStats || getRTCStats;\n    _this._mos = options.Mos || mos_1.default;\n    _this._peerConnection = options.peerConnection;\n    _this._thresholds = __assign(__assign({}, DEFAULT_THRESHOLDS), options.thresholds);\n    var thresholdSampleCounts = Object.values(_this._thresholds).map(function (threshold) {\n      return threshold.sampleCount;\n    }).filter(function (sampleCount) {\n      return !!sampleCount;\n    });\n    _this._maxSampleCount = Math.max.apply(Math, __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts));\n\n    if (_this._peerConnection) {\n      _this.enable(_this._peerConnection);\n    }\n\n    return _this;\n  }\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n\n\n  StatsMonitor.prototype.addVolumes = function (inputVolume, outputVolume) {\n    this._inputVolumes.push(inputVolume);\n\n    this._outputVolumes.push(outputVolume);\n  };\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disable = function () {\n    clearInterval(this._sampleInterval);\n    delete this._sampleInterval;\n    return this;\n  };\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disableWarnings = function () {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  };\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enable = function (peerConnection) {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new errors_1.InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new errors_1.InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval || setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n    return this;\n  };\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enableWarnings = function () {\n    this._warningsEnabled = true;\n    return this;\n  };\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n\n\n  StatsMonitor.prototype.hasActiveWarning = function (statName, thresholdName) {\n    var warningId = statName + \":\" + thresholdName;\n    return !!this._activeWarnings.get(warningId);\n  };\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n\n\n  StatsMonitor.prototype._addSample = function (sample) {\n    var samples = this._sampleBuffer;\n    samples.push(sample); // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  };\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._clearWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    var activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {\n      return;\n    }\n\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName]\n      }\n    }));\n  };\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._createSample = function (stats, previousSample) {\n    var previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    var previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n    var currentBytesSent = stats.bytesSent - previousBytesSent;\n    var currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    var currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    var currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    var currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    var currentPacketsLostFraction = currentInboundPackets > 0 ? currentPacketsLost / currentInboundPackets * 100 : 0;\n    var totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    var totalPacketsLostFraction = totalInboundPackets > 0 ? stats.packetsLost / totalInboundPackets * 100 : 100;\n    var rttValue = typeof stats.rtt === 'number' || !previousSample ? stats.rtt : previousSample.rtt;\n\n    var audioInputLevelValues = this._inputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    var audioOutputLevelValues = this._outputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(util_1.average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(util_1.average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent\n      }\n    };\n  };\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n\n\n  StatsMonitor.prototype._fetchSample = function () {\n    var _this = this;\n\n    this._getSample().then(function (sample) {\n      _this._addSample(sample);\n\n      _this._raiseWarnings();\n\n      _this.emit('sample', sample);\n    }).catch(function (error) {\n      _this.disable(); // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n\n\n      _this.emit('error', error);\n    });\n  };\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._getSample = function () {\n    var _this = this;\n\n    return this._getRTCStats(this._peerConnection).then(function (stats) {\n      var previousSample = null;\n\n      if (_this._sampleBuffer.length) {\n        previousSample = _this._sampleBuffer[_this._sampleBuffer.length - 1];\n      }\n\n      return _this._createSample(stats, previousSample);\n    });\n  };\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._raiseWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    if (this._activeWarnings.has(warningId)) {\n      return;\n    }\n\n    this._activeWarnings.set(warningId, {\n      timeRaised: Date.now()\n    });\n\n    var thresholds = this._thresholds[statName];\n    var thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      var foundThreshold = thresholds.find(function (threshold) {\n        return thresholdName in threshold;\n      });\n\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue\n      }\n    }));\n  };\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n\n\n  StatsMonitor.prototype._raiseWarnings = function () {\n    var _this = this;\n\n    if (!this._warningsEnabled) {\n      return;\n    }\n\n    Object.keys(this._thresholds).forEach(function (name) {\n      return _this._raiseWarningsForStat(name);\n    });\n  };\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n\n\n  StatsMonitor.prototype._raiseWarningsForStat = function (statName) {\n    var _this = this;\n\n    var limits = Array.isArray(this._thresholds[statName]) ? this._thresholds[statName] : [this._thresholds[statName]];\n    limits.forEach(function (limit) {\n      var samples = _this._sampleBuffer;\n      var clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      var raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      var sampleCount = limit.sampleCount || _this._maxSampleCount;\n      var relevantSamples = samples.slice(-sampleCount);\n      var values = relevantSamples.map(function (sample) {\n        return sample[statName];\n      }); // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n\n      var containsNull = values.some(function (value) {\n        return typeof value === 'undefined' || value === null;\n      });\n\n      if (containsNull) {\n        return;\n      }\n\n      var count;\n\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        var prevValue = relevantSamples[0][statName];\n        var curValue = relevantSamples[1][statName];\n        var prevStreak = _this._currentStreaks.get(statName) || 0;\n        var streak = prevValue === curValue ? prevStreak + 1 : 0;\n\n        _this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          _this._raiseWarning(statName, 'maxDuration', {\n            value: streak\n          });\n        } else if (streak === 0) {\n          _this._clearWarning(statName, 'maxDuration', {\n            value: prevStreak\n          });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        var sampleSets = _this._supplementalSampleBuffers[statName];\n\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n\n        var flatSamples = flattenSamples(sampleSets.slice(-sampleCount));\n        var stdDev = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          _this._raiseWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        } else {\n          _this._clearWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        }\n      }\n\n      [['maxAverage', function (x, y) {\n        return x > y;\n      }], ['minAverage', function (x, y) {\n        return x < y;\n      }]].forEach(function (_a) {\n        var thresholdName = _a[0],\n            comparator = _a[1];\n\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          var avg = util_1.average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            _this._raiseWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            _this._clearWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          }\n        }\n      });\n    });\n  };\n\n  return StatsMonitor;\n}(events_1.EventEmitter);\n\nexports.default = StatsMonitor; //# sourceMappingURL=statsMonitor.js.map","map":null,"metadata":{},"sourceType":"script"}