{"ast":null,"code":"'use strict';\n\nfunction _toConsumableArray(arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {\n      arr2[i] = arr[i];\n    }\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar C = require('./constants');\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar Log = require('./log').default;\n\nvar WSTransport = require('./wstransport').default;\n\nvar _require = require('./errors'),\n    GeneralErrors = _require.GeneralErrors,\n    SignalingErrors = _require.SignalingErrors;\n\nvar PSTREAM_VERSION = '1.6';\n/**\n * Constructor for PStream objects.\n *\n * @exports PStream as Twilio.PStream\n * @memberOf Twilio\n * @borrows EventEmitter#addListener as #addListener\n * @borrows EventEmitter#removeListener as #removeListener\n * @borrows EventEmitter#emit as #emit\n * @borrows EventEmitter#hasListener as #hasListener\n * @constructor\n * @param {string} token The Twilio capabilities JWT\n * @param {string[]} uris An array of PStream endpoint URIs\n * @param {object} [options]\n * @config {boolean} [options.backoffMaxMs=20000] Enable debugging\n */\n\nvar PStream = function (_EventEmitter) {\n  _inherits(PStream, _EventEmitter);\n\n  function PStream(token, uris, options) {\n    var _ret2;\n\n    _classCallCheck(this, PStream);\n\n    var _this = _possibleConstructorReturn(this, (PStream.__proto__ || Object.getPrototypeOf(PStream)).call(this));\n\n    if (!(_this instanceof PStream)) {\n      var _ret;\n\n      return _ret = new PStream(token, uris, options), _possibleConstructorReturn(_this, _ret);\n    }\n\n    var defaults = {\n      TransportFactory: WSTransport\n    };\n    options = options || {};\n\n    for (var prop in defaults) {\n      if (prop in options) continue;\n      options[prop] = defaults[prop];\n    }\n\n    _this.options = options;\n    _this.token = token || '';\n    _this.status = 'disconnected';\n    _this.gateway = null;\n    _this.region = null;\n    _this._messageQueue = [];\n    _this._preferredUri = null;\n    _this._uris = uris;\n    _this._handleTransportClose = _this._handleTransportClose.bind(_this);\n    _this._handleTransportError = _this._handleTransportError.bind(_this);\n    _this._handleTransportMessage = _this._handleTransportMessage.bind(_this);\n    _this._handleTransportOpen = _this._handleTransportOpen.bind(_this);\n    _this._log = Log.getInstance(); // NOTE(mroberts): EventEmitter requires that we catch all errors.\n\n    _this.on('error', function () {});\n    /*\n     *events used by device\n     *'invite',\n     *'ready',\n     *'error',\n     *'offline',\n     *\n     *'cancel',\n     *'presence',\n     *'roster',\n     *'answer',\n     *'candidate',\n     *'hangup'\n     */\n\n\n    var self = _this;\n\n    _this.addListener('ready', function () {\n      self.status = 'ready';\n    });\n\n    _this.addListener('offline', function () {\n      self.status = 'offline';\n    });\n\n    _this.addListener('close', function () {\n      self._log.info('Received \"close\" from server. Destroying PStream...');\n\n      self._destroy();\n    });\n\n    _this.transport = new _this.options.TransportFactory(_this._uris, {\n      backoffMaxMs: _this.options.backoffMaxMs,\n      maxPreferredDurationMs: _this.options.maxPreferredDurationMs\n    });\n    Object.defineProperties(_this, {\n      uri: {\n        enumerable: true,\n        get: function get() {\n          return this.transport.uri;\n        }\n      }\n    });\n\n    _this.transport.on('close', _this._handleTransportClose);\n\n    _this.transport.on('error', _this._handleTransportError);\n\n    _this.transport.on('message', _this._handleTransportMessage);\n\n    _this.transport.on('open', _this._handleTransportOpen);\n\n    _this.transport.open();\n\n    return _ret2 = _this, _possibleConstructorReturn(_this, _ret2);\n  }\n\n  return PStream;\n}(EventEmitter);\n\nPStream.prototype._handleTransportClose = function () {\n  this.emit('transportClose');\n\n  if (this.status !== 'disconnected') {\n    if (this.status !== 'offline') {\n      this.emit('offline', this);\n    }\n\n    this.status = 'disconnected';\n  }\n};\n\nPStream.prototype._handleTransportError = function (error) {\n  if (!error) {\n    this.emit('error', {\n      error: {\n        code: 31000,\n        message: 'Websocket closed without a provided reason',\n        twilioError: new SignalingErrors.ConnectionDisconnected()\n      }\n    });\n    return;\n  } // We receive some errors without call metadata (just the error). We need to convert these\n  // to be contained within the 'error' field so that these errors match the expected format.\n\n\n  this.emit('error', typeof error.code !== 'undefined' ? {\n    error: error\n  } : error);\n};\n\nPStream.prototype._handleTransportMessage = function (msg) {\n  if (!msg || !msg.data || typeof msg.data !== 'string') {\n    return;\n  }\n\n  var _JSON$parse = JSON.parse(msg.data),\n      type = _JSON$parse.type,\n      _JSON$parse$payload = _JSON$parse.payload,\n      payload = _JSON$parse$payload === undefined ? {} : _JSON$parse$payload;\n\n  this.gateway = payload.gateway || this.gateway;\n  this.region = payload.region || this.region;\n\n  if (type === 'error' && payload.error) {\n    payload.error.twilioError = new SignalingErrors.ConnectionError();\n  }\n\n  this.emit(type, payload);\n};\n\nPStream.prototype._handleTransportOpen = function () {\n  var _this2 = this;\n\n  this.status = 'connected';\n  this.setToken(this.token);\n  this.emit('transportOpen');\n\n  var messages = this._messageQueue.splice(0, this._messageQueue.length);\n\n  messages.forEach(function (message) {\n    return _this2._publish.apply(_this2, _toConsumableArray(message));\n  });\n};\n/**\n * @return {string}\n */\n\n\nPStream.toString = function () {\n  return '[Twilio.PStream class]';\n};\n\nPStream.prototype.toString = function () {\n  return '[Twilio.PStream instance]';\n};\n\nPStream.prototype.setToken = function (token) {\n  this._log.info('Setting token and publishing listen');\n\n  this.token = token;\n  var payload = {\n    token: token,\n    browserinfo: getBrowserInfo()\n  };\n\n  this._publish('listen', payload);\n};\n\nPStream.prototype.register = function (mediaCapabilities) {\n  var regPayload = {\n    media: mediaCapabilities\n  };\n\n  this._publish('register', regPayload, true);\n};\n\nPStream.prototype.invite = function (sdp, callsid, preflight, params) {\n  var payload = {\n    callsid: callsid,\n    sdp: sdp,\n    preflight: !!preflight,\n    twilio: params ? {\n      params: params\n    } : {}\n  };\n\n  this._publish('invite', payload, true);\n};\n\nPStream.prototype.reconnect = function (sdp, callsid, reconnect, params) {\n  var payload = {\n    callsid: callsid,\n    sdp: sdp,\n    reconnect: reconnect,\n    preflight: false,\n    twilio: params ? {\n      params: params\n    } : {}\n  };\n\n  this._publish('invite', payload, true);\n};\n\nPStream.prototype.answer = function (sdp, callsid) {\n  this._publish('answer', {\n    sdp: sdp,\n    callsid: callsid\n  }, true);\n};\n\nPStream.prototype.dtmf = function (callsid, digits) {\n  this._publish('dtmf', {\n    callsid: callsid,\n    dtmf: digits\n  }, true);\n};\n\nPStream.prototype.hangup = function (callsid, message) {\n  var payload = message ? {\n    callsid: callsid,\n    message: message\n  } : {\n    callsid: callsid\n  };\n\n  this._publish('hangup', payload, true);\n};\n\nPStream.prototype.reject = function (callsid) {\n  this._publish('reject', {\n    callsid: callsid\n  }, true);\n};\n\nPStream.prototype.reinvite = function (sdp, callsid) {\n  this._publish('reinvite', {\n    sdp: sdp,\n    callsid: callsid\n  }, false);\n};\n\nPStream.prototype._destroy = function () {\n  this.transport.removeListener('close', this._handleTransportClose);\n  this.transport.removeListener('error', this._handleTransportError);\n  this.transport.removeListener('message', this._handleTransportMessage);\n  this.transport.removeListener('open', this._handleTransportOpen);\n  this.transport.close();\n  this.emit('offline', this);\n};\n\nPStream.prototype.destroy = function () {\n  this._log.info('PStream.destroy() called...');\n\n  this._destroy();\n\n  return this;\n};\n\nPStream.prototype.updatePreferredURI = function (uri) {\n  this._preferredUri = uri;\n  this.transport.updatePreferredURI(uri);\n};\n\nPStream.prototype.updateURIs = function (uris) {\n  this._uris = uris;\n  this.transport.updateURIs(this._uris);\n};\n\nPStream.prototype.publish = function (type, payload) {\n  return this._publish(type, payload, true);\n};\n\nPStream.prototype._publish = function (type, payload, shouldRetry) {\n  var msg = JSON.stringify({\n    type: type,\n    version: PSTREAM_VERSION,\n    payload: payload\n  });\n  var isSent = !!this.transport.send(msg);\n\n  if (!isSent) {\n    this.emit('error', {\n      error: {\n        code: 31009,\n        message: 'No transport available to send or receive messages',\n        twilioError: new GeneralErrors.TransportError()\n      }\n    });\n\n    if (shouldRetry) {\n      this._messageQueue.push([type, payload, true]);\n    }\n  }\n};\n\nfunction getBrowserInfo() {\n  var nav = typeof navigator !== 'undefined' ? navigator : {};\n  var info = {\n    p: 'browser',\n    v: C.RELEASE_VERSION,\n    browser: {\n      userAgent: nav.userAgent || 'unknown',\n      platform: nav.platform || 'unknown'\n    },\n    plugin: 'rtc'\n  };\n  return info;\n}\n\nmodule.exports = PStream;","map":null,"metadata":{},"sourceType":"script"}