{"ast":null,"code":"import { Dialog } from \"../dialogs/dialog.js\";\nimport { SessionDialog } from \"../dialogs/session-dialog.js\";\nimport { TransactionStateError } from \"../exceptions/transaction-state-error.js\";\nimport { SignalingState } from \"../session/session.js\";\nimport { InviteServerTransaction } from \"../transactions/invite-server-transaction.js\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods.js\";\nimport { UserAgentServer } from \"./user-agent-server.js\";\n/**\n * INVITE UAS.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.3 UAS Processing\n * https://tools.ietf.org/html/rfc3261#section-13.3\n * @public\n */\n\nexport class InviteUserAgentServer extends UserAgentServer {\n  constructor(core, message, delegate) {\n    super(InviteServerTransaction, core, message, delegate);\n    this.core = core;\n  }\n\n  dispose() {\n    if (this.earlyDialog) {\n      this.earlyDialog.dispose();\n    }\n\n    super.dispose();\n  }\n  /**\n   * 13.3.1.4 The INVITE is Accepted\n   * The UAS core generates a 2xx response.  This response establishes a\n   * dialog, and therefore follows the procedures of Section 12.1.1 in\n   * addition to those of Section 8.2.6.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n   * @param options - Accept options bucket.\n   */\n\n\n  accept() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 200\n    };\n\n    if (!this.acceptable) {\n      throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n    } // This response establishes a dialog...\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n    if (!this.confirmedDialog) {\n      if (this.earlyDialog) {\n        this.earlyDialog.confirm();\n        this.confirmedDialog = this.earlyDialog;\n        this.earlyDialog = undefined;\n      } else {\n        const transaction = this.transaction;\n\n        if (!(transaction instanceof InviteServerTransaction)) {\n          throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n        }\n\n        const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag);\n        this.confirmedDialog = new SessionDialog(transaction, this.core, state);\n      }\n    } // When a UAS responds to a request with a response that establishes a\n    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n    // header field values from the request into the response (including the\n    // URIs, URI parameters, and any Record-Route header field parameters,\n    // whether they are known or unknown to the UAS) and MUST maintain the\n    // order of those values.  The UAS MUST add a Contact header field to\n    // the response.  The Contact header field contains an address where the\n    // UAS would like to be contacted for subsequent requests in the dialog\n    // (which includes the ACK for a 2xx response in the case of an INVITE).\n    // Generally, the host portion of this URI is the IP address or FQDN of\n    // the host.  The URI provided in the Contact header field MUST be a SIP\n    // or SIPS URI.  If the request that initiated the dialog contained a\n    // SIPS URI in the Request-URI or in the top Record-Route header field\n    // value, if there was any, or the Contact header field if there was no\n    // Record-Route header field, the Contact header field in the response\n    // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n    // same URI can be used in messages outside this dialog).  The same way,\n    // the scope of the URI in the Contact header field of the INVITE is not\n    // limited to this dialog either.  It can therefore be used in messages\n    // to the UAC even outside this dialog.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n    const recordRouteHeader = this.message.getHeaders(\"record-route\").map(header => `Record-Route: ${header}`);\n    const contactHeader = `Contact: ${this.core.configuration.contact.toString()}`; // A 2xx response to an INVITE SHOULD contain the Allow header field and\n    // the Supported header field, and MAY contain the Accept header field.\n    // Including these header fields allows the UAC to determine the\n    // features and extensions supported by the UAS for the duration of the\n    // call, without probing.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n    // FIXME: TODO: This should not be hard coded.\n\n    const allowHeader = \"Allow: \" + AllowedMethods.toString(); // FIXME: TODO: Supported header (see reply())\n    // FIXME: TODO: Accept header\n    // If the INVITE request contained an offer, and the UAS had not yet\n    // sent an answer, the 2xx MUST contain an answer.  If the INVITE did\n    // not contain an offer, the 2xx MUST contain an offer if the UAS had\n    // not yet sent an offer.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n    if (!options.body) {\n      if (this.confirmedDialog.signalingState === SignalingState.Stable) {\n        options.body = this.confirmedDialog.answer; // resend the answer sent in provisional response\n      } else if (this.confirmedDialog.signalingState === SignalingState.Initial || this.confirmedDialog.signalingState === SignalingState.HaveRemoteOffer) {\n        throw new Error(\"Response must have a body.\");\n      }\n    }\n\n    options.statusCode = options.statusCode || 200;\n    options.extraHeaders = options.extraHeaders || [];\n    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(contactHeader);\n    const response = super.accept(options);\n    const session = this.confirmedDialog;\n    const result = Object.assign(Object.assign({}, response), {\n      session\n    }); // Update dialog signaling state\n\n    if (options.body) {\n      // Once the UAS has sent or received an answer to the initial\n      // offer, it MUST NOT generate subsequent offers in any responses\n      // to the initial INVITE.  This means that a UAS based on this\n      // specification alone can never generate subsequent offers until\n      // completion of the initial transaction.\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      if (this.confirmedDialog.signalingState !== SignalingState.Stable) {\n        this.confirmedDialog.signalingStateTransition(options.body);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * 13.3.1.1 Progress\n   * If the UAS is not able to answer the invitation immediately, it can\n   * choose to indicate some kind of progress to the UAC (for example, an\n   * indication that a phone is ringing).  This is accomplished with a\n   * provisional response between 101 and 199.  These provisional\n   * responses establish early dialogs and therefore follow the procedures\n   * of Section 12.1.1 in addition to those of Section 8.2.6.  A UAS MAY\n   * send as many provisional responses as it likes.  Each of these MUST\n   * indicate the same dialog ID.  However, these will not be delivered\n   * reliably.\n   *\n   * If the UAS desires an extended period of time to answer the INVITE,\n   * it will need to ask for an \"extension\" in order to prevent proxies\n   * from canceling the transaction.  A proxy has the option of canceling\n   * a transaction when there is a gap of 3 minutes between responses in a\n   * transaction.  To prevent cancellation, the UAS MUST send a non-100\n   * provisional response at every minute, to handle the possibility of\n   * lost provisional responses.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.1\n   * @param options - Progress options bucket.\n   */\n\n\n  progress() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 180\n    };\n\n    if (!this.progressable) {\n      throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n    } // This response establishes a dialog...\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1.4\n\n\n    if (!this.earlyDialog) {\n      const transaction = this.transaction;\n\n      if (!(transaction instanceof InviteServerTransaction)) {\n        throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n      }\n\n      const state = Dialog.initialDialogStateForUserAgentServer(this.message, this.toTag, true);\n      this.earlyDialog = new SessionDialog(transaction, this.core, state);\n    } // When a UAS responds to a request with a response that establishes a\n    // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n    // header field values from the request into the response (including the\n    // URIs, URI parameters, and any Record-Route header field parameters,\n    // whether they are known or unknown to the UAS) and MUST maintain the\n    // order of those values.  The UAS MUST add a Contact header field to\n    // the response.  The Contact header field contains an address where the\n    // UAS would like to be contacted for subsequent requests in the dialog\n    // (which includes the ACK for a 2xx response in the case of an INVITE).\n    // Generally, the host portion of this URI is the IP address or FQDN of\n    // the host.  The URI provided in the Contact header field MUST be a SIP\n    // or SIPS URI.  If the request that initiated the dialog contained a\n    // SIPS URI in the Request-URI or in the top Record-Route header field\n    // value, if there was any, or the Contact header field if there was no\n    // Record-Route header field, the Contact header field in the response\n    // MUST be a SIPS URI.  The URI SHOULD have global scope (that is, the\n    // same URI can be used in messages outside this dialog).  The same way,\n    // the scope of the URI in the Contact header field of the INVITE is not\n    // limited to this dialog either.  It can therefore be used in messages\n    // to the UAC even outside this dialog.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.1\n\n\n    const recordRouteHeader = this.message.getHeaders(\"record-route\").map(header => `Record-Route: ${header}`);\n    const contactHeader = `Contact: ${this.core.configuration.contact}`;\n    options.extraHeaders = options.extraHeaders || [];\n    options.extraHeaders = options.extraHeaders.concat(recordRouteHeader);\n    options.extraHeaders.push(contactHeader);\n    const response = super.progress(options);\n    const session = this.earlyDialog;\n    const result = Object.assign(Object.assign({}, response), {\n      session\n    }); // Update dialog signaling state\n\n    if (options.body) {\n      // Once the UAS has sent or received an answer to the initial\n      // offer, it MUST NOT generate subsequent offers in any responses\n      // to the initial INVITE.  This means that a UAS based on this\n      // specification alone can never generate subsequent offers until\n      // completion of the initial transaction.\n      // https://tools.ietf.org/html/rfc3261#section-13.2.1\n      if (this.earlyDialog.signalingState !== SignalingState.Stable) {\n        this.earlyDialog.signalingStateTransition(options.body);\n      }\n    }\n\n    return result;\n  }\n  /**\n   * 13.3.1.2 The INVITE is Redirected\n   * If the UAS decides to redirect the call, a 3xx response is sent.  A\n   * 300 (Multiple Choices), 301 (Moved Permanently) or 302 (Moved\n   * Temporarily) response SHOULD contain a Contact header field\n   * containing one or more URIs of new addresses to be tried.  The\n   * response is passed to the INVITE server transaction, which will deal\n   * with its retransmissions.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.2\n   * @param contacts - Contacts to redirect to.\n   * @param options - Redirect options bucket.\n   */\n\n\n  redirect(contacts) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      statusCode: 302\n    };\n    return super.redirect(contacts, options);\n  }\n  /**\n   * 13.3.1.3 The INVITE is Rejected\n   * A common scenario occurs when the callee is currently not willing or\n   * able to take additional calls at this end system.  A 486 (Busy Here)\n   * SHOULD be returned in such a scenario.\n   * https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n   * @param options - Reject options bucket.\n   */\n\n\n  reject() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 486\n    };\n    return super.reject(options);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}