{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\n\nvar events_1 = require(\"events\");\n\nvar call_1 = require(\"../call\");\n\nvar device_1 = require(\"../device\");\n\nvar errors_1 = require(\"../errors\");\n\nvar stats_1 = require(\"../rtc/stats\");\n\nvar _a = require('../constants'),\n    COWBELL_AUDIO_URL = _a.COWBELL_AUDIO_URL,\n    ECHO_TEST_DURATION = _a.ECHO_TEST_DURATION;\n/**\n * Runs some tests to identify issues, if any, prohibiting successful calling.\n */\n\n\nvar PreflightTest =\n/** @class */\nfunction (_super) {\n  __extends(PreflightTest, _super);\n  /**\n   * Construct a {@link PreflightTest} instance.\n   * @constructor\n   * @param token - A Twilio JWT token string.\n   * @param options\n   */\n\n\n  function PreflightTest(token, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Whether this test has already logged an insights-connection-warning.\n     */\n\n\n    _this._hasInsightsErrored = false;\n    /**\n     * Network related timing measurements for this test\n     */\n\n    _this._networkTiming = {};\n    /**\n     * The options passed to {@link PreflightTest} constructor\n     */\n\n    _this._options = {\n      codecPreferences: [call_1.default.Codec.PCMU, call_1.default.Codec.Opus],\n      edge: 'roaming',\n      fakeMicInput: false,\n      logLevel: 'error',\n      signalingTimeoutMs: 10000\n    };\n    /**\n     * Current status of this test\n     */\n\n    _this._status = PreflightTest.Status.Connecting;\n    Object.assign(_this._options, options);\n    _this._samples = [];\n    _this._warnings = [];\n    _this._startTime = Date.now();\n\n    _this._initDevice(token, __assign(__assign({}, _this._options), {\n      fileInputStream: _this._options.fakeMicInput ? _this._getStreamFromFile() : undefined\n    }));\n\n    return _this;\n  }\n  /**\n   * Stops the current test and raises a failed event.\n   */\n\n\n  PreflightTest.prototype.stop = function () {\n    var _this = this;\n\n    var error = new errors_1.GeneralErrors.CallCancelledError();\n\n    if (this._device) {\n      this._device.once(device_1.default.EventName.Unregistered, function () {\n        return _this._onFailed(error);\n      });\n\n      this._device.destroy();\n    } else {\n      this._onFailed(error);\n    }\n  };\n  /**\n   * Emit a {PreflightTest.Warning}\n   */\n\n\n  PreflightTest.prototype._emitWarning = function (name, description, rtcWarning) {\n    var warning = {\n      name: name,\n      description: description\n    };\n\n    if (rtcWarning) {\n      warning.rtcWarning = rtcWarning;\n    }\n\n    this._warnings.push(warning);\n\n    this.emit(PreflightTest.Events.Warning, warning);\n  };\n  /**\n   * Returns call quality base on the RTC Stats\n   */\n\n\n  PreflightTest.prototype._getCallQuality = function (mos) {\n    if (mos > 4.2) {\n      return PreflightTest.CallQuality.Excellent;\n    } else if (mos >= 4.1 && mos <= 4.2) {\n      return PreflightTest.CallQuality.Great;\n    } else if (mos >= 3.7 && mos <= 4) {\n      return PreflightTest.CallQuality.Good;\n    } else if (mos >= 3.1 && mos <= 3.6) {\n      return PreflightTest.CallQuality.Fair;\n    } else {\n      return PreflightTest.CallQuality.Degraded;\n    }\n  };\n  /**\n   * Returns the report for this test.\n   */\n\n\n  PreflightTest.prototype._getReport = function () {\n    var stats = this._getRTCStats();\n\n    var testTiming = {\n      start: this._startTime\n    };\n\n    if (this._endTime) {\n      testTiming.end = this._endTime;\n      testTiming.duration = this._endTime - this._startTime;\n    }\n\n    var report = {\n      callSid: this._callSid,\n      edge: this._edge,\n      iceCandidateStats: this._rtcIceCandidateStatsReport.iceCandidateStats,\n      networkTiming: this._networkTiming,\n      samples: this._samples,\n      selectedEdge: this._options.edge,\n      stats: stats,\n      testTiming: testTiming,\n      totals: this._getRTCSampleTotals(),\n      warnings: this._warnings\n    };\n    var selectedIceCandidatePairStats = this._rtcIceCandidateStatsReport.selectedIceCandidatePairStats;\n\n    if (selectedIceCandidatePairStats) {\n      report.selectedIceCandidatePairStats = selectedIceCandidatePairStats;\n      report.isTurnRequired = selectedIceCandidatePairStats.localCandidate.candidateType === 'relay' || selectedIceCandidatePairStats.remoteCandidate.candidateType === 'relay';\n    }\n\n    if (stats) {\n      report.callQuality = this._getCallQuality(stats.mos.average);\n    }\n\n    return report;\n  };\n  /**\n   * Returns RTC stats totals for this test\n   */\n\n\n  PreflightTest.prototype._getRTCSampleTotals = function () {\n    if (!this._latestSample) {\n      return;\n    }\n\n    return __assign({}, this._latestSample.totals);\n  };\n  /**\n   * Returns RTC related stats captured during the test call\n   */\n\n\n  PreflightTest.prototype._getRTCStats = function () {\n    var firstMosSampleIdx = this._samples.findIndex(function (sample) {\n      return typeof sample.mos === 'number' && sample.mos > 0;\n    });\n\n    var samples = firstMosSampleIdx >= 0 ? this._samples.slice(firstMosSampleIdx) : [];\n\n    if (!samples || !samples.length) {\n      return;\n    }\n\n    return ['jitter', 'mos', 'rtt'].reduce(function (statObj, stat) {\n      var _a;\n\n      var values = samples.map(function (s) {\n        return s[stat];\n      });\n      return __assign(__assign({}, statObj), (_a = {}, _a[stat] = {\n        average: Number((values.reduce(function (total, value) {\n          return total + value;\n        }) / values.length).toPrecision(5)),\n        max: Math.max.apply(Math, values),\n        min: Math.min.apply(Math, values)\n      }, _a));\n    }, {});\n  };\n  /**\n   * Returns a MediaStream from a media file\n   */\n\n\n  PreflightTest.prototype._getStreamFromFile = function () {\n    var audioContext = this._options.audioContext;\n\n    if (!audioContext) {\n      throw new errors_1.NotSupportedError('Cannot fake input audio stream: AudioContext is not supported by this browser.');\n    }\n\n    var audioEl = new Audio(COWBELL_AUDIO_URL);\n    audioEl.addEventListener('canplaythrough', function () {\n      return audioEl.play();\n    });\n\n    if (typeof audioEl.setAttribute === 'function') {\n      audioEl.setAttribute('crossorigin', 'anonymous');\n    }\n\n    var src = audioContext.createMediaElementSource(audioEl);\n    var dest = audioContext.createMediaStreamDestination();\n    src.connect(dest);\n    return dest.stream;\n  };\n  /**\n   * Initialize the device\n   */\n\n\n  PreflightTest.prototype._initDevice = function (token, options) {\n    var _this = this;\n\n    try {\n      this._device = new (options.deviceFactory || device_1.default)(token, {\n        codecPreferences: options.codecPreferences,\n        edge: options.edge,\n        fileInputStream: options.fileInputStream,\n        logLevel: options.logLevel,\n        preflight: true\n      });\n\n      this._device.once(device_1.default.EventName.Registered, function () {\n        _this._onDeviceRegistered();\n      });\n\n      this._device.once(device_1.default.EventName.Error, function (error) {\n        _this._onDeviceError(error);\n      });\n\n      this._device.register();\n    } catch (error) {\n      // We want to return before failing so the consumer can capture the event\n      setTimeout(function () {\n        _this._onFailed(error);\n      });\n      return;\n    }\n\n    this._signalingTimeoutTimer = setTimeout(function () {\n      _this._onDeviceError(new errors_1.SignalingErrors.ConnectionError('WebSocket Connection Timeout'));\n    }, options.signalingTimeoutMs);\n  };\n  /**\n   * Called on {@link Device} error event\n   * @param error\n   */\n\n\n  PreflightTest.prototype._onDeviceError = function (error) {\n    this._device.destroy();\n\n    this._onFailed(error);\n  };\n  /**\n   * Called on {@link Device} ready event\n   */\n\n\n  PreflightTest.prototype._onDeviceRegistered = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var _a, audio, publisher;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            clearTimeout(this._echoTimer);\n            clearTimeout(this._signalingTimeoutTimer);\n            _a = this;\n            return [4\n            /*yield*/\n            , this._device.connect({\n              rtcConfiguration: this._options.rtcConfiguration\n            })];\n\n          case 1:\n            _a._call = _b.sent();\n            this._networkTiming.signaling = {\n              start: Date.now()\n            };\n\n            this._setupCallHandlers(this._call);\n\n            this._edge = this._device.edge || undefined;\n\n            if (this._options.fakeMicInput) {\n              this._echoTimer = setTimeout(function () {\n                return _this._device.disconnectAll();\n              }, ECHO_TEST_DURATION);\n              audio = this._device.audio;\n\n              if (audio) {\n                audio.disconnect(false);\n                audio.outgoing(false);\n              }\n            }\n\n            this._call.once('disconnect', function () {\n              _this._device.once(device_1.default.EventName.Unregistered, function () {\n                return _this._onUnregistered();\n              });\n\n              _this._device.destroy();\n            });\n\n            publisher = this._call['_publisher'];\n            publisher.on('error', function () {\n              if (!_this._hasInsightsErrored) {\n                _this._emitWarning('insights-connection-error', 'Received an error when attempting to connect to Insights gateway');\n              }\n\n              _this._hasInsightsErrored = true;\n            });\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Called when there is a fatal error\n   * @param error\n   */\n\n\n  PreflightTest.prototype._onFailed = function (error) {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n\n    this._releaseHandlers();\n\n    this._endTime = Date.now();\n    this._status = PreflightTest.Status.Failed;\n    this.emit(PreflightTest.Events.Failed, error);\n  };\n  /**\n   * Called when the device goes offline.\n   * This indicates that the test has been completed, but we won't know if it failed or not.\n   * The onError event will be the indicator whether the test failed.\n   */\n\n\n  PreflightTest.prototype._onUnregistered = function () {\n    var _this = this; // We need to make sure we always execute preflight.on('completed') last\n    // as client SDK sometimes emits 'offline' event before emitting fatal errors.\n\n\n    setTimeout(function () {\n      if (_this._status === PreflightTest.Status.Failed) {\n        return;\n      }\n\n      clearTimeout(_this._echoTimer);\n      clearTimeout(_this._signalingTimeoutTimer);\n\n      _this._releaseHandlers();\n\n      _this._endTime = Date.now();\n      _this._status = PreflightTest.Status.Completed;\n      _this._report = _this._getReport();\n\n      _this.emit(PreflightTest.Events.Completed, _this._report);\n    }, 10);\n  };\n  /**\n   * Clean up all handlers for device and call\n   */\n\n\n  PreflightTest.prototype._releaseHandlers = function () {\n    [this._device, this._call].forEach(function (emitter) {\n      if (emitter) {\n        emitter.eventNames().forEach(function (name) {\n          return emitter.removeAllListeners(name);\n        });\n      }\n    });\n  };\n  /**\n   * Setup the event handlers for the {@link Call} of the test call\n   * @param call\n   */\n\n\n  PreflightTest.prototype._setupCallHandlers = function (call) {\n    var _this = this;\n\n    if (this._options.fakeMicInput) {\n      // When volume events start emitting, it means all audio outputs have been created.\n      // Let's mute them if we're using fake mic input.\n      call.once('volume', function () {\n        call['_mediaHandler'].outputs.forEach(function (output) {\n          return output.audio.muted = true;\n        });\n      });\n    }\n\n    call.on('warning', function (name, data) {\n      _this._emitWarning(name, 'Received an RTCWarning. See .rtcWarning for the RTCWarning', data);\n    });\n    call.once('accept', function () {\n      _this._callSid = call['_mediaHandler'].callSid;\n      _this._status = PreflightTest.Status.Connected;\n\n      _this.emit(PreflightTest.Events.Connected);\n    });\n    call.on('sample', function (sample) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var _a;\n\n        return __generator(this, function (_b) {\n          switch (_b.label) {\n            case 0:\n              if (!!this._latestSample) return [3\n              /*break*/\n              , 2];\n              _a = this;\n              return [4\n              /*yield*/\n              , (this._options.getRTCIceCandidateStatsReport || stats_1.getRTCIceCandidateStatsReport)(call['_mediaHandler'].version.pc)];\n\n            case 1:\n              _a._rtcIceCandidateStatsReport = _b.sent();\n              _b.label = 2;\n\n            case 2:\n              this._latestSample = sample;\n\n              this._samples.push(sample);\n\n              this.emit(PreflightTest.Events.Sample, sample);\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    }); // TODO: Update the following once the SDK supports emitting these events\n    // Let's shim for now\n\n    [{\n      reportLabel: 'peerConnection',\n      type: 'pcconnection'\n    }, {\n      reportLabel: 'ice',\n      type: 'iceconnection'\n    }, {\n      reportLabel: 'dtls',\n      type: 'dtlstransport'\n    }, {\n      reportLabel: 'signaling',\n      type: 'signaling'\n    }].forEach(function (_a) {\n      var type = _a.type,\n          reportLabel = _a.reportLabel;\n      var handlerName = \"on\" + type + \"statechange\";\n      var originalHandler = call['_mediaHandler'][handlerName];\n\n      call['_mediaHandler'][handlerName] = function (state) {\n        var timing = _this._networkTiming[reportLabel] = _this._networkTiming[reportLabel] || {\n          start: 0\n        };\n\n        if (state === 'connecting' || state === 'checking') {\n          timing.start = Date.now();\n        } else if ((state === 'connected' || state === 'stable') && !timing.duration) {\n          timing.end = Date.now();\n          timing.duration = timing.end - timing.start;\n        }\n\n        originalHandler(state);\n      };\n    });\n  };\n\n  Object.defineProperty(PreflightTest.prototype, \"callSid\", {\n    /**\n     * The callsid generated for the test call.\n     */\n    get: function () {\n      return this._callSid;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"endTime\", {\n    /**\n     * A timestamp in milliseconds of when the test ended.\n     */\n    get: function () {\n      return this._endTime;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"latestSample\", {\n    /**\n     * The latest WebRTC sample collected.\n     */\n    get: function () {\n      return this._latestSample;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"report\", {\n    /**\n     * The report for this test.\n     */\n    get: function () {\n      return this._report;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"startTime\", {\n    /**\n     * A timestamp in milliseconds of when the test started.\n     */\n    get: function () {\n      return this._startTime;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(PreflightTest.prototype, \"status\", {\n    /**\n     * The status of the test.\n     */\n    get: function () {\n      return this._status;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return PreflightTest;\n}(events_1.EventEmitter);\n\nexports.PreflightTest = PreflightTest;\n\n(function (PreflightTest) {\n  /**\n   * The quality of the call determined by different mos ranges.\n   * Mos is calculated base on the WebRTC stats - rtt, jitter, and packet lost.\n   */\n  var CallQuality;\n\n  (function (CallQuality) {\n    /**\n     * If the average mos is over 4.2.\n     */\n    CallQuality[\"Excellent\"] = \"excellent\";\n    /**\n     * If the average mos is between 4.1 and 4.2 both inclusive.\n     */\n\n    CallQuality[\"Great\"] = \"great\";\n    /**\n     * If the average mos is between 3.7 and 4.0 both inclusive.\n     */\n\n    CallQuality[\"Good\"] = \"good\";\n    /**\n     * If the average mos is between 3.1 and 3.6 both inclusive.\n     */\n\n    CallQuality[\"Fair\"] = \"fair\";\n    /**\n     * If the average mos is 3.0 or below.\n     */\n\n    CallQuality[\"Degraded\"] = \"degraded\";\n  })(CallQuality = PreflightTest.CallQuality || (PreflightTest.CallQuality = {}));\n  /**\n   * Possible events that a [[PreflightTest]] might emit.\n   */\n\n\n  var Events;\n\n  (function (Events) {\n    /**\n     * See [[PreflightTest.completedEvent]]\n     */\n    Events[\"Completed\"] = \"completed\";\n    /**\n     * See [[PreflightTest.connectedEvent]]\n     */\n\n    Events[\"Connected\"] = \"connected\";\n    /**\n     * See [[PreflightTest.failedEvent]]\n     */\n\n    Events[\"Failed\"] = \"failed\";\n    /**\n     * See [[PreflightTest.sampleEvent]]\n     */\n\n    Events[\"Sample\"] = \"sample\";\n    /**\n     * See [[PreflightTest.warningEvent]]\n     */\n\n    Events[\"Warning\"] = \"warning\";\n  })(Events = PreflightTest.Events || (PreflightTest.Events = {}));\n  /**\n   * Possible status of the test.\n   */\n\n\n  var Status;\n\n  (function (Status) {\n    /**\n     * Call to Twilio has initiated.\n     */\n    Status[\"Connecting\"] = \"connecting\";\n    /**\n     * Call to Twilio has been established.\n     */\n\n    Status[\"Connected\"] = \"connected\";\n    /**\n     * The connection to Twilio has been disconnected and the test call has completed.\n     */\n\n    Status[\"Completed\"] = \"completed\";\n    /**\n     * The test has stopped and failed.\n     */\n\n    Status[\"Failed\"] = \"failed\";\n  })(Status = PreflightTest.Status || (PreflightTest.Status = {}));\n})(PreflightTest = exports.PreflightTest || (exports.PreflightTest = {}));\n\nexports.PreflightTest = PreflightTest;","map":{"version":3,"mappings":"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","names":["COWBELL_AUDIO_URL","ECHO_TEST_DURATION","__extends","token","options","_super","_this","codecPreferences","call_1","Codec","PCMU","Opus","edge","fakeMicInput","logLevel","signalingTimeoutMs","PreflightTest","Status","Connecting","Object","assign","_options","_samples","_warnings","_startTime","Date","now","_initDevice","__assign","fileInputStream","_getStreamFromFile","undefined","error","errors_1","CallCancelledError","_device","once","device_1","EventName","Unregistered","_onFailed","destroy","name","description","rtcWarning","warning","push","emit","Events","Warning","mos","CallQuality","Excellent","Great","Good","Fair","Degraded","stats","_getRTCStats","testTiming","start","_endTime","end","duration","report","callSid","_callSid","_edge","iceCandidateStats","_rtcIceCandidateStatsReport","networkTiming","_networkTiming","samples","selectedEdge","totals","_getRTCSampleTotals","warnings","selectedIceCandidatePairStats","isTurnRequired","localCandidate","candidateType","remoteCandidate","callQuality","_getCallQuality","average","_latestSample","firstMosSampleIdx","findIndex","sample","slice","length","reduce","statObj","stat","values","map","_a","Number","total","value","toPrecision","max","Math","apply","min","audioContext","audioEl","Audio","addEventListener","play","setAttribute","src","createMediaElementSource","dest","createMediaStreamDestination","connect","stream","deviceFactory","preflight","Registered","_onDeviceRegistered","Error","_onDeviceError","register","setTimeout","_signalingTimeoutTimer","ConnectionError","clearTimeout","_echoTimer","rtcConfiguration","_call","_b","signaling","_setupCallHandlers","disconnectAll","audio","disconnect","outgoing","_onUnregistered","publisher","on","_hasInsightsErrored","_emitWarning","_releaseHandlers","_status","Failed","Completed","_report","_getReport","forEach","emitter","eventNames","removeAllListeners","call","outputs","output","muted","data","Connected","getRTCIceCandidateStatsReport","stats_1","version","pc","Sample","reportLabel","type","handlerName","originalHandler","state","timing","events_1","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/preflight/preflight.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nimport { EventEmitter } from 'events';\nimport Call from '../call';\nimport Device, { IExtendedDeviceOptions } from '../device';\nimport {\n  GeneralErrors,\n  NotSupportedError,\n  SignalingErrors,\n  TwilioError,\n} from '../errors';\nimport { RTCSampleTotals } from '../rtc/sample';\nimport RTCSample from '../rtc/sample';\nimport { getRTCIceCandidateStatsReport } from '../rtc/stats';\nimport RTCWarning from '../rtc/warning';\nimport StatsMonitor from '../statsMonitor';\nimport { NetworkTiming, TimeMeasurement } from './timing';\n\nconst { COWBELL_AUDIO_URL, ECHO_TEST_DURATION } = require('../constants');\n\n/**\n * Placeholder until we convert peerconnection.js to TypeScript.\n * Represents the audio output object coming from Client SDK's PeerConnection object.\n * @internalapi\n */\nexport interface AudioOutput {\n  /**\n   * The audio element used to play out the sound.\n   */\n  audio: HTMLAudioElement;\n}\n\nexport declare interface PreflightTest {\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Completed]].\n   * During this time, [[PreflightTest.report]] is available and ready to be inspected.\n   * In some cases, this will not trigger if the test encounters a fatal error prior connecting to Twilio.\n   * See [[PreflightTest.failedEvent]].\n   * @param report\n   * @example `preflight.on('completed', report => console.log(report))`\n   * @event\n   */\n  completedEvent(report: PreflightTest.Report): void;\n\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Connected]].\n   * @example `preflight.on('connected', () => console.log('Test connected'))`\n   * @event\n   */\n  connectedEvent(): void;\n\n  /**\n   * Raised when [[PreflightTest.status]] has transitioned to [[PreflightTest.Status.Failed]].\n   * This happens when establishing a connection to Twilio has failed or when a test call has encountered a fatal error.\n   * This is also raised if [[PreflightTest.stop]] is called while the test is in progress.\n   * @param error\n   * @example `preflight.on('failed', error => console.log(error))`\n   * @event\n   */\n  failedEvent(error: TwilioError | DOMException): void;\n\n  /**\n   * Raised when the [[Call]] gets a webrtc sample object. This event is published every second.\n   * @param sample\n   * @example `preflight.on('sample', sample => console.log(sample))`\n   * @event\n   */\n  sampleEvent(sample: RTCSample): void;\n\n  /**\n   * Raised whenever the [[Call]] encounters a warning.\n   * @param name - The name of the warning.\n   * @example `preflight.on('warning', (name, data) => console.log({ name, data }))`\n   * @event\n   */\n  warningEvent(name: string, data: PreflightTest.Warning): void;\n}\n\n/**\n * Runs some tests to identify issues, if any, prohibiting successful calling.\n */\nexport class PreflightTest extends EventEmitter {\n  /**\n   * The {@link Call} for this test call\n   */\n  private _call: Call;\n\n  /**\n   * Callsid generated for this test call\n   */\n  private _callSid: string | undefined;\n\n  /**\n   * The {@link Device} for this test call\n   */\n  private _device: Device;\n\n  /**\n   * The timer when doing an echo test\n   * The echo test is used when fakeMicInput is set to true\n   */\n  private _echoTimer: NodeJS.Timer;\n\n  /**\n   * The edge that the `Twilio.Device` connected to.\n   */\n  private _edge: string | undefined;\n\n  /**\n   * End of test timestamp\n   */\n  private _endTime: number | undefined;\n\n  /**\n   * Whether this test has already logged an insights-connection-warning.\n   */\n  private _hasInsightsErrored: boolean = false;\n\n  /**\n   * Latest WebRTC sample collected for this test\n   */\n  private _latestSample: RTCSample | undefined;\n\n  /**\n   * Network related timing measurements for this test\n   */\n  private _networkTiming: NetworkTiming = {};\n\n  /**\n   * The options passed to {@link PreflightTest} constructor\n   */\n  private _options: PreflightTest.ExtendedOptions = {\n    codecPreferences: [Call.Codec.PCMU, Call.Codec.Opus],\n    edge: 'roaming',\n    fakeMicInput: false,\n    logLevel: 'error',\n    signalingTimeoutMs: 10000,\n  };\n\n  /**\n   * The report for this test.\n   */\n  private _report: PreflightTest.Report | undefined;\n\n  /**\n   * The WebRTC ICE candidates stats information collected during the test\n   */\n  private _rtcIceCandidateStatsReport: PreflightTest.RTCIceCandidateStatsReport;\n\n  /**\n   * WebRTC samples collected during this test\n   */\n  private _samples: RTCSample[];\n\n  /**\n   * Timer for setting up signaling connection\n   */\n  private _signalingTimeoutTimer: number;\n\n  /**\n   * Start of test timestamp\n   */\n  private _startTime: number;\n\n  /**\n   * Current status of this test\n   */\n  private _status: PreflightTest.Status = PreflightTest.Status.Connecting;\n\n  /**\n   * List of warning names and warning data detected during this test\n   */\n  private _warnings: PreflightTest.Warning[];\n\n  /**\n   * Construct a {@link PreflightTest} instance.\n   * @constructor\n   * @param token - A Twilio JWT token string.\n   * @param options\n   */\n  constructor(token: string, options: PreflightTest.ExtendedOptions) {\n    super();\n\n    Object.assign(this._options, options);\n\n    this._samples = [];\n    this._warnings = [];\n    this._startTime = Date.now();\n\n    this._initDevice(token, {\n      ...this._options,\n      fileInputStream: this._options.fakeMicInput ?\n        this._getStreamFromFile() : undefined,\n    });\n  }\n\n  /**\n   * Stops the current test and raises a failed event.\n   */\n  stop(): void {\n    const error = new GeneralErrors.CallCancelledError();\n    if (this._device) {\n      this._device.once(Device.EventName.Unregistered, () => this._onFailed(error));\n      this._device.destroy();\n    } else {\n      this._onFailed(error);\n    }\n  }\n\n  /**\n   * Emit a {PreflightTest.Warning}\n   */\n  private _emitWarning(name: string, description: string, rtcWarning?: RTCWarning): void {\n    const warning: PreflightTest.Warning = { name, description };\n    if (rtcWarning) {\n      warning.rtcWarning = rtcWarning;\n    }\n    this._warnings.push(warning);\n    this.emit(PreflightTest.Events.Warning, warning);\n  }\n\n  /**\n   * Returns call quality base on the RTC Stats\n   */\n  private _getCallQuality(mos: number): PreflightTest.CallQuality {\n    if (mos > 4.2) {\n      return PreflightTest.CallQuality.Excellent;\n    } else if (mos >= 4.1 && mos <= 4.2) {\n      return PreflightTest.CallQuality.Great;\n    } else if (mos >= 3.7 && mos <= 4) {\n      return PreflightTest.CallQuality.Good;\n    } else if (mos >= 3.1 && mos <= 3.6) {\n      return PreflightTest.CallQuality.Fair;\n    } else {\n      return PreflightTest.CallQuality.Degraded;\n    }\n  }\n\n  /**\n   * Returns the report for this test.\n   */\n  private _getReport(): PreflightTest.Report {\n    const stats = this._getRTCStats();\n    const testTiming: TimeMeasurement = { start: this._startTime };\n    if (this._endTime) {\n      testTiming.end = this._endTime;\n      testTiming.duration  = this._endTime - this._startTime;\n    }\n\n    const report: PreflightTest.Report = {\n      callSid: this._callSid,\n      edge: this._edge,\n      iceCandidateStats: this._rtcIceCandidateStatsReport.iceCandidateStats,\n      networkTiming: this._networkTiming,\n      samples: this._samples,\n      selectedEdge: this._options.edge,\n      stats,\n      testTiming,\n      totals: this._getRTCSampleTotals(),\n      warnings: this._warnings,\n    };\n\n    const selectedIceCandidatePairStats = this._rtcIceCandidateStatsReport.selectedIceCandidatePairStats;\n\n    if (selectedIceCandidatePairStats) {\n      report.selectedIceCandidatePairStats = selectedIceCandidatePairStats;\n      report.isTurnRequired = selectedIceCandidatePairStats.localCandidate.candidateType === 'relay'\n      || selectedIceCandidatePairStats.remoteCandidate.candidateType === 'relay';\n    }\n\n    if (stats) {\n      report.callQuality = this._getCallQuality(stats.mos.average);\n    }\n\n    return report;\n  }\n\n  /**\n   * Returns RTC stats totals for this test\n   */\n  private _getRTCSampleTotals(): RTCSampleTotals | undefined {\n    if (!this._latestSample) {\n      return;\n    }\n\n    return { ...this._latestSample.totals };\n  }\n\n  /**\n   * Returns RTC related stats captured during the test call\n   */\n  private _getRTCStats(): PreflightTest.RTCStats | undefined {\n    const firstMosSampleIdx = this._samples.findIndex(\n      sample => typeof sample.mos === 'number' && sample.mos > 0,\n    );\n\n    const samples = firstMosSampleIdx >= 0\n      ? this._samples.slice(firstMosSampleIdx)\n      : [];\n\n    if (!samples || !samples.length) {\n      return;\n    }\n\n    return ['jitter', 'mos', 'rtt'].reduce((statObj, stat) => {\n      const values = samples.map(s => s[stat]);\n      return {\n        ...statObj,\n        [stat]: {\n          average: Number((values.reduce((total, value) => total + value) / values.length).toPrecision(5)),\n          max: Math.max(...values),\n          min: Math.min(...values),\n        },\n      };\n    }, {} as any);\n  }\n\n  /**\n   * Returns a MediaStream from a media file\n   */\n  private _getStreamFromFile(): MediaStream {\n    const audioContext = this._options.audioContext;\n    if (!audioContext) {\n      throw new NotSupportedError('Cannot fake input audio stream: AudioContext is not supported by this browser.');\n    }\n\n    const audioEl: any = new Audio(COWBELL_AUDIO_URL);\n\n    audioEl.addEventListener('canplaythrough', () => audioEl.play());\n    if (typeof audioEl.setAttribute === 'function') {\n      audioEl.setAttribute('crossorigin', 'anonymous');\n    }\n\n    const src = audioContext.createMediaElementSource(audioEl);\n    const dest = audioContext.createMediaStreamDestination();\n    src.connect(dest);\n\n    return dest.stream;\n  }\n\n  /**\n   * Initialize the device\n   */\n  private _initDevice(token: string, options: PreflightTest.ExtendedOptions): void {\n    try {\n      this._device = new (options.deviceFactory || Device)(token, {\n        codecPreferences: options.codecPreferences,\n        edge: options.edge,\n        fileInputStream: options.fileInputStream,\n        logLevel: options.logLevel,\n        preflight: true,\n      } as IExtendedDeviceOptions);\n\n      this._device.once(Device.EventName.Registered, () => {\n        this._onDeviceRegistered();\n      });\n\n      this._device.once(Device.EventName.Error, (error: TwilioError) => {\n        this._onDeviceError(error);\n      });\n\n      this._device.register();\n    } catch (error) {\n      // We want to return before failing so the consumer can capture the event\n      setTimeout(() => {\n        this._onFailed(error);\n      });\n      return;\n    }\n\n    this._signalingTimeoutTimer = setTimeout(() => {\n      this._onDeviceError(new SignalingErrors.ConnectionError('WebSocket Connection Timeout'));\n    }, options.signalingTimeoutMs);\n  }\n\n  /**\n   * Called on {@link Device} error event\n   * @param error\n   */\n  private _onDeviceError(error: TwilioError): void {\n    this._device.destroy();\n    this._onFailed(error);\n  }\n\n  /**\n   * Called on {@link Device} ready event\n   */\n  private async _onDeviceRegistered(): Promise<void> {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n\n    this._call = await this._device.connect({\n      rtcConfiguration: this._options.rtcConfiguration,\n    });\n    this._networkTiming.signaling = { start: Date.now() };\n    this._setupCallHandlers(this._call);\n\n    this._edge = this._device.edge || undefined;\n    if (this._options.fakeMicInput) {\n      this._echoTimer = setTimeout(() => this._device.disconnectAll(), ECHO_TEST_DURATION);\n\n      const audio = this._device.audio as any;\n      if (audio) {\n        audio.disconnect(false);\n        audio.outgoing(false);\n      }\n    }\n\n    this._call.once('disconnect', () => {\n      this._device.once(Device.EventName.Unregistered, () => this._onUnregistered());\n      this._device.destroy();\n    });\n\n    const publisher = this._call['_publisher'] as any;\n    publisher.on('error', () => {\n      if (!this._hasInsightsErrored) {\n        this._emitWarning('insights-connection-error',\n          'Received an error when attempting to connect to Insights gateway');\n      }\n      this._hasInsightsErrored = true;\n    });\n  }\n\n  /**\n   * Called when there is a fatal error\n   * @param error\n   */\n  private _onFailed(error: TwilioError | DOMException): void {\n    clearTimeout(this._echoTimer);\n    clearTimeout(this._signalingTimeoutTimer);\n    this._releaseHandlers();\n    this._endTime = Date.now();\n    this._status = PreflightTest.Status.Failed;\n    this.emit(PreflightTest.Events.Failed, error);\n  }\n\n  /**\n   * Called when the device goes offline.\n   * This indicates that the test has been completed, but we won't know if it failed or not.\n   * The onError event will be the indicator whether the test failed.\n   */\n  private _onUnregistered(): void {\n    // We need to make sure we always execute preflight.on('completed') last\n    // as client SDK sometimes emits 'offline' event before emitting fatal errors.\n    setTimeout(() => {\n      if (this._status === PreflightTest.Status.Failed) {\n        return;\n      }\n\n      clearTimeout(this._echoTimer);\n      clearTimeout(this._signalingTimeoutTimer);\n\n      this._releaseHandlers();\n      this._endTime = Date.now();\n      this._status = PreflightTest.Status.Completed;\n      this._report = this._getReport();\n      this.emit(PreflightTest.Events.Completed, this._report);\n    }, 10);\n  }\n\n  /**\n   * Clean up all handlers for device and call\n   */\n  private _releaseHandlers(): void {\n    [this._device, this._call].forEach((emitter: EventEmitter) => {\n      if (emitter) {\n        emitter.eventNames().forEach((name: string) => emitter.removeAllListeners(name));\n      }\n    });\n  }\n\n  /**\n   * Setup the event handlers for the {@link Call} of the test call\n   * @param call\n   */\n  private _setupCallHandlers(call: Call): void {\n    if (this._options.fakeMicInput) {\n      // When volume events start emitting, it means all audio outputs have been created.\n      // Let's mute them if we're using fake mic input.\n      call.once('volume', () => {\n        call['_mediaHandler'].outputs\n          .forEach((output: AudioOutput) => output.audio.muted = true);\n      });\n    }\n\n    call.on('warning', (name: string, data: RTCWarning) => {\n      this._emitWarning(name, 'Received an RTCWarning. See .rtcWarning for the RTCWarning', data);\n    });\n\n    call.once('accept', () => {\n      this._callSid = call['_mediaHandler'].callSid;\n      this._status = PreflightTest.Status.Connected;\n      this.emit(PreflightTest.Events.Connected);\n    });\n\n    call.on('sample', async (sample) => {\n      // RTC Stats are ready. We only need to get ICE candidate stats report once.\n      if (!this._latestSample) {\n        this._rtcIceCandidateStatsReport = await (\n          this._options.getRTCIceCandidateStatsReport || getRTCIceCandidateStatsReport\n        )(call['_mediaHandler'].version.pc);\n      }\n\n      this._latestSample = sample;\n      this._samples.push(sample);\n      this.emit(PreflightTest.Events.Sample, sample);\n    });\n\n    // TODO: Update the following once the SDK supports emitting these events\n    // Let's shim for now\n    [{\n      reportLabel: 'peerConnection',\n      type: 'pcconnection',\n     }, {\n      reportLabel: 'ice',\n      type: 'iceconnection',\n     }, {\n      reportLabel: 'dtls',\n      type: 'dtlstransport',\n     }, {\n      reportLabel: 'signaling',\n      type: 'signaling',\n     }].forEach(({type, reportLabel}) => {\n\n      const handlerName = `on${type}statechange`;\n      const originalHandler = call['_mediaHandler'][handlerName];\n\n      call['_mediaHandler'][handlerName] = (state: string) => {\n        const timing = (this._networkTiming as any)[reportLabel]\n          = (this._networkTiming as any)[reportLabel] || { start: 0 };\n\n        if (state === 'connecting' || state === 'checking') {\n          timing.start = Date.now();\n        } else if ((state === 'connected' || state === 'stable') && !timing.duration) {\n          timing.end = Date.now();\n          timing.duration = timing.end - timing.start;\n        }\n\n        originalHandler(state);\n      };\n    });\n  }\n\n  /**\n   * The callsid generated for the test call.\n   */\n  get callSid(): string | undefined {\n    return this._callSid;\n  }\n\n  /**\n   * A timestamp in milliseconds of when the test ended.\n   */\n  get endTime(): number | undefined {\n    return this._endTime;\n  }\n\n  /**\n   * The latest WebRTC sample collected.\n   */\n  get latestSample(): RTCSample | undefined {\n    return this._latestSample;\n  }\n\n  /**\n   * The report for this test.\n   */\n  get report(): PreflightTest.Report | undefined {\n    return this._report;\n  }\n\n  /**\n   * A timestamp in milliseconds of when the test started.\n   */\n  get startTime(): number {\n    return this._startTime;\n  }\n\n  /**\n   * The status of the test.\n   */\n  get status(): PreflightTest.Status {\n    return this._status;\n  }\n}\n\nexport namespace PreflightTest {\n  /**\n   * The quality of the call determined by different mos ranges.\n   * Mos is calculated base on the WebRTC stats - rtt, jitter, and packet lost.\n   */\n  export enum CallQuality {\n    /**\n     * If the average mos is over 4.2.\n     */\n    Excellent = 'excellent',\n\n    /**\n     * If the average mos is between 4.1 and 4.2 both inclusive.\n     */\n    Great = 'great',\n\n    /**\n     * If the average mos is between 3.7 and 4.0 both inclusive.\n     */\n    Good = 'good',\n\n    /**\n     * If the average mos is between 3.1 and 3.6 both inclusive.\n     */\n    Fair = 'fair',\n\n    /**\n     * If the average mos is 3.0 or below.\n     */\n    Degraded = 'degraded',\n  }\n\n  /**\n   * Possible events that a [[PreflightTest]] might emit.\n   */\n  export enum Events {\n    /**\n     * See [[PreflightTest.completedEvent]]\n     */\n    Completed = 'completed',\n\n    /**\n     * See [[PreflightTest.connectedEvent]]\n     */\n    Connected = 'connected',\n\n    /**\n     * See [[PreflightTest.failedEvent]]\n     */\n    Failed = 'failed',\n\n    /**\n     * See [[PreflightTest.sampleEvent]]\n     */\n    Sample = 'sample',\n\n    /**\n     * See [[PreflightTest.warningEvent]]\n     */\n    Warning = 'warning',\n  }\n\n  /**\n   * Possible status of the test.\n   */\n  export enum Status {\n    /**\n     * Call to Twilio has initiated.\n     */\n    Connecting = 'connecting',\n\n    /**\n     * Call to Twilio has been established.\n     */\n    Connected = 'connected',\n\n    /**\n     * The connection to Twilio has been disconnected and the test call has completed.\n     */\n    Completed = 'completed',\n\n    /**\n     * The test has stopped and failed.\n     */\n    Failed = 'failed',\n  }\n\n  /**\n   * The WebRTC API's [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n   * dictionary which provides information related to an ICE candidate.\n   */\n  export type RTCIceCandidateStats = any;\n\n  /**\n   * Options that may be passed to {@link PreflightTest} constructor for internal testing.\n   * @internalapi\n   */\n  export interface ExtendedOptions extends Options {\n    /**\n     * The AudioContext instance to use\n     */\n    audioContext?: AudioContext;\n\n    /**\n     * Device class to use.\n     */\n    deviceFactory?: typeof Device;\n\n    /**\n     * File input stream to use instead of reading from mic\n     */\n    fileInputStream?: MediaStream;\n\n    /**\n     * The getRTCIceCandidateStatsReport to use for testing.\n     */\n    getRTCIceCandidateStatsReport?: Function;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n  }\n\n  /**\n   * A WebRTC stats report containing relevant information about selected and gathered ICE candidates\n   */\n  export interface RTCIceCandidateStatsReport {\n    /**\n     * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n     */\n    iceCandidateStats: RTCIceCandidateStats[];\n\n    /**\n     * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n     */\n    selectedIceCandidatePairStats?: RTCSelectedIceCandidatePairStats;\n  }\n\n  /**\n   * Options passed to {@link PreflightTest} constructor.\n   */\n  export interface Options {\n    /**\n     * An ordered array of codec names that will be used during the test call,\n     * from most to least preferred.\n     * @default ['pcmu','opus']\n     */\n    codecPreferences?: Call.Codec[];\n\n    /**\n     * Specifies which Twilio Data Center to use when initiating the test call.\n     * Please see this\n     * [page](https://www.twilio.com/docs/voice/client/edges)\n     * for the list of available edges.\n     * @default roaming\n     */\n    edge?: string;\n\n    /**\n     * If set to `true`, the test call will ignore microphone input and will use a default audio file.\n     * If set to `false`, the test call will capture the audio from the microphone.\n     * Setting this to `true` is only supported on Chrome and will throw a fatal error on other browsers\n     * @default false\n     */\n    fakeMicInput?: boolean;\n\n    /**\n     * An array of custom ICE servers to use to connect media. If you provide both STUN and TURN server configurations,\n     * the test will detect whether a TURN server is required to establish a connection.\n     *\n     * The following example demonstrates how to use [Twilio's Network Traversal Service](https://www.twilio.com/stun-turn)\n     * to generate STUN/TURN credentials and how to specify a specific [edge location](https://www.twilio.com/docs/global-infrastructure/edge-locations).\n     *\n     * ```ts\n     * import Client from 'twilio';\n     * import { Device } from 'twilio-client';\n     *\n     * // Generate the STUN and TURN server credentials with a ttl of 120 seconds\n     * const client = Client(twilioAccountSid, authToken);\n     * const token = await client.tokens.create({ ttl: 120 });\n     *\n     * let iceServers = token.iceServers;\n     *\n     * // By default, global will be used as the default edge location.\n     * // You can replace global with a specific edge name for each of the iceServer configuration.\n     * iceServers = iceServers.map(config => {\n     *   let { url, urls, ...rest } = config;\n     *   url = url.replace('global', 'ashburn');\n     *   urls = urls.replace('global', 'ashburn');\n     *\n     *   return { url, urls, ...rest };\n     * });\n     *\n     * // Use the TURN credentials using the iceServers parameter\n     * const preflightTest = Device.runPreflight(token, { iceServers });\n     *\n     * // Read from the report object to determine whether TURN is required to connect to media\n     * preflightTest.on('completed', (report) => {\n     *   console.log(report.isTurnRequired);\n     * });\n     * ```\n     *\n     * @default null\n     */\n    iceServers?: RTCIceServer[];\n\n    /**\n     * Log level to use in the Device.\n     * @default 'error'\n     */\n    logLevel?: string;\n\n    /**\n     * Amount of time to wait for setting up signaling connection.\n     * @default 10000\n     */\n    signalingTimeoutMs?: number;\n  }\n\n  /**\n   * Represents the WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n   */\n  export interface RTCSelectedIceCandidatePairStats {\n    /**\n     * An [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n     * object which provides information related to the selected local ICE candidate.\n     */\n    localCandidate: RTCIceCandidateStats;\n\n    /**\n     * An [RTCIceCandidateStats](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceCandidateStats)\n     * object which provides information related to the selected remote ICE candidate.\n     */\n    remoteCandidate: RTCIceCandidateStats;\n  }\n\n  /**\n   * Represents RTC related stats that are extracted from RTC samples.\n   */\n  export interface RTCStats {\n    /**\n     * Packets delay variation.\n     */\n    jitter: Stats;\n\n    /**\n     * Mean opinion score, 1.0 through roughly 4.5.\n     */\n    mos: Stats;\n\n    /**\n     * Round trip time, to the server back to the client.\n     */\n    rtt: Stats;\n  }\n\n  /**\n   * Represents general stats for a specific metric.\n   */\n  export interface Stats {\n    /**\n     * The average value for this metric.\n     */\n    average: number;\n\n    /**\n     * The maximum value for this metric.\n     */\n    max: number;\n\n    /**\n     * The minimum value for this metric.\n     */\n    min: number;\n  }\n\n  /**\n   * Represents the report generated from a {@link PreflightTest}.\n   */\n  export interface Report {\n    /**\n     * The quality of the call determined by different mos ranges.\n     */\n    callQuality?: CallQuality;\n\n    /**\n     * CallSid generaged during the test.\n     */\n    callSid: string | undefined;\n\n    /**\n     * The edge that the test call was connected to.\n     */\n    edge?: string;\n\n    /**\n     * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n     */\n    iceCandidateStats: RTCIceCandidateStats[];\n\n    /**\n     * Whether a TURN server is required to connect to media.\n     * This is dependent on the selected ICE candidates, and will be true if either is of type \"relay\",\n     * false if both are of another type, or undefined if there are no selected ICE candidates.\n     * See `PreflightTest.Options.iceServers` for more details.\n     */\n    isTurnRequired?: boolean;\n\n    /**\n     * Network related time measurements.\n     */\n    networkTiming: NetworkTiming;\n\n    /**\n     * WebRTC samples collected during the test.\n     */\n    samples: RTCSample[];\n\n    /**\n     * The edge passed to `Device.runPreflight`.\n     */\n    selectedEdge?: string;\n\n    /**\n     * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n     */\n    selectedIceCandidatePairStats?: RTCSelectedIceCandidatePairStats;\n\n    /**\n     * RTC related stats captured during the test.\n     */\n    stats?: RTCStats;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming: TimeMeasurement;\n\n    /**\n     * Calculated totals in RTC statistics samples.\n     */\n    totals?: RTCSampleTotals;\n\n    /**\n     * List of warning names and warning data detected during this test.\n     */\n    warnings: PreflightTest.Warning[];\n  }\n\n  /**\n   * A warning that can be raised by Preflight, and returned in the Report.warnings field.\n   */\n  export interface Warning {\n    /**\n     * Description of the Warning\n     */\n    description: string;\n    /**\n     * Name of the Warning\n     */\n    name: string;\n    /**\n     * If applicable, the RTCWarning that triggered this warning.\n     */\n    rtcWarning?: RTCWarning;\n  }\n }\n"]},"metadata":{},"sourceType":"script"}