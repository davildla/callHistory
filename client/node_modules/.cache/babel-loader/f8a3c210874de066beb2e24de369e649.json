{"ast":null,"code":"import { EmitterImpl } from \"../../../api/emitter.js\";\nimport { StateTransitionError } from \"../../../api/exceptions/state-transition.js\";\nimport { TransportState } from \"../../../api/transport-state.js\";\nimport { Grammar } from \"../../../grammar/grammar.js\";\n/**\n * Transport for SIP over secure WebSocket (WSS).\n * @public\n */\n\nexport class Transport {\n  constructor(logger, options) {\n    this._state = TransportState.Disconnected;\n    this.transitioningState = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // logger\n\n    this.logger = logger; // guard deprecated options (remove this in version 16.x)\n\n    if (options) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const optionsDeprecated = options;\n      const wsServersDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.wsServers;\n      const maxReconnectionAttemptsDeprecated = optionsDeprecated === null || optionsDeprecated === void 0 ? void 0 : optionsDeprecated.maxReconnectionAttempts;\n\n      if (wsServersDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"wsServers\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      } // hack\n\n\n      if (wsServersDeprecated && !options.server) {\n        if (typeof wsServersDeprecated === \"string\") {\n          options.server = wsServersDeprecated;\n        }\n\n        if (wsServersDeprecated instanceof Array) {\n          options.server = wsServersDeprecated[0];\n        }\n      }\n    } // initialize configuration\n\n\n    this.configuration = Object.assign(Object.assign({}, Transport.defaultOptions), options); // validate server URL\n\n    const url = this.configuration.server;\n    const parsed = Grammar.parse(url, \"absoluteURI\");\n\n    if (parsed === -1) {\n      this.logger.error(`Invalid WebSocket Server URL \"${url}\"`);\n      throw new Error(\"Invalid WebSocket Server URL\");\n    }\n\n    if (![\"wss\", \"ws\", \"udp\"].includes(parsed.scheme)) {\n      this.logger.error(`Invalid scheme in WebSocket Server URL \"${url}\"`);\n      throw new Error(\"Invalid scheme in WebSocket Server URL\");\n    }\n\n    this._protocol = parsed.scheme.toUpperCase();\n  }\n\n  dispose() {\n    return this.disconnect();\n  }\n  /**\n   * The protocol.\n   *\n   * @remarks\n   * Formatted as defined for the Via header sent-protocol transport.\n   * https://tools.ietf.org/html/rfc3261#section-20.42\n   */\n\n\n  get protocol() {\n    return this._protocol;\n  }\n  /**\n   * The URL of the WebSocket Server.\n   */\n\n\n  get server() {\n    return this.configuration.server;\n  }\n  /**\n   * Transport state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * Transport state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * The WebSocket.\n   */\n\n\n  get ws() {\n    return this._ws;\n  }\n  /**\n   * Connect to network.\n   * Resolves once connected. Otherwise rejects with an Error.\n   */\n\n\n  connect() {\n    return this._connect();\n  }\n  /**\n   * Disconnect from network.\n   * Resolves once disconnected. Otherwise rejects with an Error.\n   */\n\n\n  disconnect() {\n    return this._disconnect();\n  }\n  /**\n   * Returns true if the `state` equals \"Connected\".\n   * @remarks\n   * This is equivalent to `state === TransportState.Connected`.\n   */\n\n\n  isConnected() {\n    return this.state === TransportState.Connected;\n  }\n  /**\n   * Sends a message.\n   * Resolves once message is sent. Otherwise rejects with an Error.\n   * @param message - Message to send.\n   */\n\n\n  send(message) {\n    // Error handling is independent of whether the message was a request or\n    // response.\n    //\n    // If the transport user asks for a message to be sent over an\n    // unreliable transport, and the result is an ICMP error, the behavior\n    // depends on the type of ICMP error.  Host, network, port or protocol\n    // unreachable errors, or parameter problem errors SHOULD cause the\n    // transport layer to inform the transport user of a failure in sending.\n    // Source quench and TTL exceeded ICMP errors SHOULD be ignored.\n    //\n    // If the transport user asks for a request to be sent over a reliable\n    // transport, and the result is a connection failure, the transport\n    // layer SHOULD inform the transport user of a failure in sending.\n    // https://tools.ietf.org/html/rfc3261#section-18.4\n    return this._send(message);\n  }\n\n  _connect() {\n    this.logger.log(`Connecting ${this.server}`);\n\n    switch (this.state) {\n      case TransportState.Connecting:\n        // If `state` is \"Connecting\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n        }\n\n        if (!this.connectPromise) {\n          throw new Error(\"Connect promise must be defined.\");\n        }\n\n        return this.connectPromise;\n      // Already connecting\n\n      case TransportState.Connected:\n        // If `state` is \"Connected\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Connecting));\n        }\n\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        return Promise.resolve();\n      // Already connected\n\n      case TransportState.Disconnecting:\n        // If `state` is \"Disconnecting\", `state` MUST transition to \"Connecting\" before returning\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Connecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Disconnected:\n        // If `state` is \"Disconnected\" `state` MUST transition to \"Connecting\" before returning\n        if (this.connectPromise) {\n          throw new Error(\"Connect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Connecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    let ws;\n\n    try {\n      // WebSocket()\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/WebSocket\n      ws = new WebSocket(this.server, \"sip\");\n      ws.binaryType = \"arraybuffer\"; // set data type of received binary messages\n\n      ws.addEventListener(\"close\", ev => this.onWebSocketClose(ev, ws));\n      ws.addEventListener(\"error\", ev => this.onWebSocketError(ev, ws));\n      ws.addEventListener(\"open\", ev => this.onWebSocketOpen(ev, ws));\n      ws.addEventListener(\"message\", ev => this.onWebSocketMessage(ev, ws));\n      this._ws = ws;\n    } catch (error) {\n      this._ws = undefined;\n      this.logger.error(\"WebSocket construction failed.\");\n      this.logger.error(error.toString());\n      return new Promise((resolve, reject) => {\n        this.connectResolve = resolve;\n        this.connectReject = reject; // The `state` MUST transition to \"Disconnecting\" or \"Disconnected\" before rejecting\n\n        this.transitionState(TransportState.Disconnected, error);\n      });\n    }\n\n    this.connectPromise = new Promise((resolve, reject) => {\n      this.connectResolve = resolve;\n      this.connectReject = reject;\n      this.connectTimeout = setTimeout(() => {\n        this.logger.warn(\"Connect timed out. \" + \"Exceeded time set in configuration.connectionTimeout: \" + this.configuration.connectionTimeout + \"s.\");\n        ws.close(1000); // careful here to use a local reference instead of this._ws\n      }, this.configuration.connectionTimeout * 1000);\n    });\n    return this.connectPromise;\n  }\n\n  _disconnect() {\n    this.logger.log(`Disconnecting ${this.server}`);\n\n    switch (this.state) {\n      case TransportState.Connecting:\n        // If `state` is \"Connecting\", `state` MUST transition to \"Disconnecting\" before returning.\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Disconnecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Connected:\n        // If `state` is \"Connected\", `state` MUST transition to \"Disconnecting\" before returning.\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        try {\n          this.transitionState(TransportState.Disconnecting);\n        } catch (e) {\n          if (e instanceof StateTransitionError) {\n            return Promise.reject(e); // Loop detected\n          }\n\n          throw e;\n        }\n\n        break;\n\n      case TransportState.Disconnecting:\n        // If `state` is \"Disconnecting\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n        }\n\n        if (!this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must be defined.\");\n        }\n\n        return this.disconnectPromise;\n      // Already disconnecting\n\n      case TransportState.Disconnected:\n        // If `state` is \"Disconnected\", `state` MUST NOT transition before returning.\n        if (this.transitioningState) {\n          return Promise.reject(this.transitionLoopDetectedError(TransportState.Disconnecting));\n        }\n\n        if (this.disconnectPromise) {\n          throw new Error(\"Disconnect promise must not be defined.\");\n        }\n\n        return Promise.resolve();\n      // Already disconnected\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    if (!this._ws) {\n      throw new Error(\"WebSocket must be defined.\");\n    }\n\n    const ws = this._ws;\n    this.disconnectPromise = new Promise((resolve, reject) => {\n      this.disconnectResolve = resolve;\n      this.disconnectReject = reject;\n\n      try {\n        // WebSocket.close()\n        // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/close\n        ws.close(1000); // careful here to use a local reference instead of this._ws\n      } catch (error) {\n        // Treating this as a coding error as it apparently can only happen\n        // if you pass close() invalid parameters (so it should never happen)\n        this.logger.error(\"WebSocket close failed.\");\n        this.logger.error(error.toString());\n        throw error;\n      }\n    });\n    return this.disconnectPromise;\n  }\n\n  _send(message) {\n    if (this.configuration.traceSip === true) {\n      this.logger.log(\"Sending WebSocket message:\\n\\n\" + message + \"\\n\");\n    }\n\n    if (this._state !== TransportState.Connected) {\n      return Promise.reject(new Error(\"Not connected.\"));\n    }\n\n    if (!this._ws) {\n      throw new Error(\"WebSocket undefined.\");\n    }\n\n    try {\n      // WebSocket.send()\n      // https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send\n      this._ws.send(message);\n    } catch (error) {\n      if (error instanceof Error) {\n        return Promise.reject(error);\n      }\n\n      return Promise.reject(new Error(\"WebSocket send failed.\"));\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * WebSocket \"onclose\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketClose(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    const message = `WebSocket closed ${this.server} (code: ${ev.code})`;\n    const error = !this.disconnectPromise ? new Error(message) : undefined;\n\n    if (error) {\n      this.logger.warn(\"WebSocket closed unexpectedly\");\n    }\n\n    this.logger.log(message); // We are about to transition to disconnected, so clear our web socket\n\n    this._ws = undefined; // The `state` MUST transition to \"Disconnected\" before resolving (assuming `state` is not already \"Disconnected\").\n\n    this.transitionState(TransportState.Disconnected, error);\n  }\n  /**\n   * WebSocket \"onerror\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketError(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    this.logger.error(\"WebSocket error occurred.\");\n  }\n  /**\n   * WebSocket \"onmessage\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketMessage(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    const data = ev.data;\n    let finishedData; // CRLF Keep Alive response from server. Clear our keep alive timeout.\n\n    if (/^(\\r\\n)+$/.test(data)) {\n      this.clearKeepAliveTimeout();\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket message with CRLF Keep Alive response\");\n      }\n\n      return;\n    }\n\n    if (!data) {\n      this.logger.warn(\"Received empty message, discarding...\");\n      return;\n    }\n\n    if (typeof data !== \"string\") {\n      // WebSocket binary message.\n      try {\n        finishedData = new TextDecoder().decode(new Uint8Array(data)); // TextDecoder (above) is not supported by old browsers, but it correctly decodes UTF-8.\n        // The line below is an ISO 8859-1 (Latin 1) decoder, so just UTF-8 code points that are 1 byte.\n        // It's old code and works in old browsers (IE), so leaving it here in a comment in case someone needs it.\n        // finishedData = String.fromCharCode.apply(null, (new Uint8Array(data) as unknown as Array<number>));\n      } catch (err) {\n        this.logger.error(err.toString());\n        this.logger.error(\"Received WebSocket binary message failed to be converted into string, message discarded\");\n        return;\n      }\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket binary message:\\n\\n\" + finishedData + \"\\n\");\n      }\n    } else {\n      // WebSocket text message.\n      finishedData = data;\n\n      if (this.configuration.traceSip === true) {\n        this.logger.log(\"Received WebSocket text message:\\n\\n\" + finishedData + \"\\n\");\n      }\n    }\n\n    if (this.state !== TransportState.Connected) {\n      this.logger.warn(\"Received message while not connected, discarding...\");\n      return;\n    }\n\n    if (this.onMessage) {\n      try {\n        this.onMessage(finishedData);\n      } catch (e) {\n        this.logger.error(e.toString());\n        this.logger.error(\"Exception thrown by onMessage callback\");\n        throw e; // rethrow unhandled exception\n      }\n    }\n  }\n  /**\n   * WebSocket \"onopen\" event handler.\n   * @param ev - Event.\n   */\n\n\n  onWebSocketOpen(ev, ws) {\n    if (ws !== this._ws) {\n      return;\n    }\n\n    if (this._state === TransportState.Connecting) {\n      this.logger.log(`WebSocket opened ${this.server}`);\n      this.transitionState(TransportState.Connected);\n    }\n  }\n  /**\n   * Helper function to generate an Error.\n   * @param state - State transitioning to.\n   */\n\n\n  transitionLoopDetectedError(state) {\n    let message = `A state transition loop has been detected.`;\n    message += ` An attempt to transition from ${this._state} to ${state} before the prior transition completed.`;\n    message += ` Perhaps you are synchronously calling connect() or disconnect() from a callback or state change handler?`;\n    this.logger.error(message);\n    return new StateTransitionError(\"Loop detected.\");\n  }\n  /**\n   * Transition transport state.\n   * @internal\n   */\n\n\n  transitionState(newState, error) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    };\n\n    if (this.transitioningState) {\n      throw this.transitionLoopDetectedError(newState);\n    }\n\n    this.transitioningState = true; // Validate state transition\n\n    switch (this._state) {\n      case TransportState.Connecting:\n        if (newState !== TransportState.Connected && newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Connected:\n        if (newState !== TransportState.Disconnecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Disconnecting:\n        if (newState !== TransportState.Connecting && newState !== TransportState.Disconnected) {\n          invalidTransition();\n        }\n\n        break;\n\n      case TransportState.Disconnected:\n        if (newState !== TransportState.Connecting) {\n          invalidTransition();\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    } // Update state\n\n\n    const oldState = this._state;\n    this._state = newState; // Local copies of connect promises (guarding against callbacks changing them indirectly)\n    // const connectPromise = this.connectPromise;\n\n    const connectResolve = this.connectResolve;\n    const connectReject = this.connectReject; // Reset connect promises if no longer connecting\n\n    if (oldState === TransportState.Connecting) {\n      this.connectPromise = undefined;\n      this.connectResolve = undefined;\n      this.connectReject = undefined;\n    } // Local copies of disconnect promises (guarding against callbacks changing them indirectly)\n    // const disconnectPromise = this.disconnectPromise;\n\n\n    const disconnectResolve = this.disconnectResolve;\n    const disconnectReject = this.disconnectReject; // Reset disconnect promises if no longer disconnecting\n\n    if (oldState === TransportState.Disconnecting) {\n      this.disconnectPromise = undefined;\n      this.disconnectResolve = undefined;\n      this.disconnectReject = undefined;\n    } // Clear any outstanding connect timeout\n\n\n    if (this.connectTimeout) {\n      clearTimeout(this.connectTimeout);\n      this.connectTimeout = undefined;\n    }\n\n    this.logger.log(`Transitioned from ${oldState} to ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); //  Transition to Connected\n\n\n    if (newState === TransportState.Connected) {\n      this.startSendingKeepAlives();\n\n      if (this.onConnect) {\n        try {\n          this.onConnect();\n        } catch (e) {\n          this.logger.error(e.toString());\n          this.logger.error(\"Exception thrown by onConnect callback\");\n          throw e; // rethrow unhandled exception\n        }\n      }\n    } //  Transition from Connected\n\n\n    if (oldState === TransportState.Connected) {\n      this.stopSendingKeepAlives();\n\n      if (this.onDisconnect) {\n        try {\n          if (error) {\n            this.onDisconnect(error);\n          } else {\n            this.onDisconnect();\n          }\n        } catch (e) {\n          this.logger.error(e.toString());\n          this.logger.error(\"Exception thrown by onDisconnect callback\");\n          throw e; // rethrow unhandled exception\n        }\n      }\n    } // Complete connect promise\n\n\n    if (oldState === TransportState.Connecting) {\n      if (!connectResolve) {\n        throw new Error(\"Connect resolve undefined.\");\n      }\n\n      if (!connectReject) {\n        throw new Error(\"Connect reject undefined.\");\n      }\n\n      newState === TransportState.Connected ? connectResolve() : connectReject(error || new Error(\"Connect aborted.\"));\n    } // Complete disconnect promise\n\n\n    if (oldState === TransportState.Disconnecting) {\n      if (!disconnectResolve) {\n        throw new Error(\"Disconnect resolve undefined.\");\n      }\n\n      if (!disconnectReject) {\n        throw new Error(\"Disconnect reject undefined.\");\n      }\n\n      newState === TransportState.Disconnected ? disconnectResolve() : disconnectReject(error || new Error(\"Disconnect aborted.\"));\n    }\n\n    this.transitioningState = false;\n  } // TODO: Review \"KeepAlive Stuff\".\n  // It is not clear if it works and there are no tests for it.\n  // It was blindly lifted the keep alive code unchanged from earlier transport code.\n  //\n  // From the RFC...\n  //\n  // SIP WebSocket Clients and Servers may keep their WebSocket\n  // connections open by sending periodic WebSocket \"Ping\" frames as\n  // described in [RFC6455], Section 5.5.2.\n  // ...\n  // The indication and use of the CRLF NAT keep-alive mechanism defined\n  // for SIP connection-oriented transports in [RFC5626], Section 3.5.1 or\n  // [RFC6223] are, of course, usable over the transport defined in this\n  // specification.\n  // https://tools.ietf.org/html/rfc7118#section-6\n  //\n  // and...\n  //\n  // The Ping frame contains an opcode of 0x9.\n  // https://tools.ietf.org/html/rfc6455#section-5.5.2\n  //\n  // ==============================\n  // KeepAlive Stuff\n  // ==============================\n\n\n  clearKeepAliveTimeout() {\n    if (this.keepAliveDebounceTimeout) {\n      clearTimeout(this.keepAliveDebounceTimeout);\n    }\n\n    this.keepAliveDebounceTimeout = undefined;\n  }\n  /**\n   * Send a keep-alive (a double-CRLF sequence).\n   */\n\n\n  sendKeepAlive() {\n    if (this.keepAliveDebounceTimeout) {\n      // We already have an outstanding keep alive, do not send another.\n      return Promise.resolve();\n    }\n\n    this.keepAliveDebounceTimeout = setTimeout(() => {\n      this.clearKeepAliveTimeout();\n    }, this.configuration.keepAliveDebounce * 1000);\n    return this.send(\"\\r\\n\\r\\n\");\n  }\n  /**\n   * Start sending keep-alives.\n   */\n\n\n  startSendingKeepAlives() {\n    // Compute an amount of time in seconds to wait before sending another keep-alive.\n    const computeKeepAliveTimeout = upperBound => {\n      const lowerBound = upperBound * 0.8;\n      return 1000 * (Math.random() * (upperBound - lowerBound) + lowerBound);\n    };\n\n    if (this.configuration.keepAliveInterval && !this.keepAliveInterval) {\n      this.keepAliveInterval = setInterval(() => {\n        this.sendKeepAlive();\n        this.startSendingKeepAlives();\n      }, computeKeepAliveTimeout(this.configuration.keepAliveInterval));\n    }\n  }\n  /**\n   * Stop sending keep-alives.\n   */\n\n\n  stopSendingKeepAlives() {\n    if (this.keepAliveInterval) {\n      clearInterval(this.keepAliveInterval);\n    }\n\n    if (this.keepAliveDebounceTimeout) {\n      clearTimeout(this.keepAliveDebounceTimeout);\n    }\n\n    this.keepAliveInterval = undefined;\n    this.keepAliveDebounceTimeout = undefined;\n  }\n\n}\nTransport.defaultOptions = {\n  server: \"\",\n  connectionTimeout: 5,\n  keepAliveInterval: 0,\n  keepAliveDebounce: 10,\n  traceSip: true\n};","map":null,"metadata":{},"sourceType":"module"}