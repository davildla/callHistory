{"ast":null,"code":"const stripPayload = (sdp, payload) => {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const mediaDescs = [];\n  const lines = sdp.split(/\\r\\n/); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  let currentMediaDesc;\n\n  for (let i = 0; i < lines.length;) {\n    const line = lines[i];\n\n    if (/^m=(?:audio|video)/.test(line)) {\n      currentMediaDesc = {\n        index: i,\n        stripped: []\n      };\n      mediaDescs.push(currentMediaDesc);\n    } else if (currentMediaDesc) {\n      const rtpmap = /^a=rtpmap:(\\d+) ([^/]+)\\//.exec(line);\n\n      if (rtpmap && payload === rtpmap[2]) {\n        lines.splice(i, 1);\n        currentMediaDesc.stripped.push(rtpmap[1]);\n        continue; // Don't increment 'i'\n      }\n    }\n\n    i++;\n  }\n\n  for (const mediaDesc of mediaDescs) {\n    const mline = lines[mediaDesc.index].split(\" \"); // Ignore the first 3 parameters of the mline. The codec information is after that\n\n    for (let j = 3; j < mline.length;) {\n      if (mediaDesc.stripped.indexOf(mline[j]) !== -1) {\n        mline.splice(j, 1);\n        continue;\n      }\n\n      j++;\n    }\n\n    lines[mediaDesc.index] = mline.join(\" \");\n  }\n\n  return lines.join(\"\\r\\n\");\n};\n\nconst stripMediaDescription = (sdp, description) => {\n  const descriptionRegExp = new RegExp(\"m=\" + description + \".*$\", \"gm\");\n  const groupRegExp = new RegExp(\"^a=group:.*$\", \"gm\");\n\n  if (descriptionRegExp.test(sdp)) {\n    let midLineToRemove;\n    sdp = sdp.split(/^m=/gm).filter(section => {\n      if (section.substr(0, description.length) === description) {\n        midLineToRemove = section.match(/^a=mid:.*$/gm);\n\n        if (midLineToRemove) {\n          const step = midLineToRemove[0].match(/:.+$/g);\n\n          if (step) {\n            midLineToRemove = step[0].substr(1);\n          }\n        }\n\n        return false;\n      }\n\n      return true;\n    }).join(\"m=\");\n    const groupLine = sdp.match(groupRegExp);\n\n    if (groupLine && groupLine.length === 1) {\n      let groupLinePortion = groupLine[0]; // eslint-disable-next-line no-useless-escape\n\n      const groupRegExpReplace = new RegExp(\"\\ *\" + midLineToRemove + \"[^\\ ]*\", \"g\");\n      groupLinePortion = groupLinePortion.replace(groupRegExpReplace, \"\");\n      sdp = sdp.split(groupRegExp).join(groupLinePortion);\n    }\n  }\n\n  return sdp;\n};\n/**\n * Modifier.\n * @public\n */\n\n\nexport function stripTcpCandidates(description) {\n  description.sdp = (description.sdp || \"\").replace(/^a=candidate:\\d+ \\d+ tcp .*?\\r\\n/img, \"\");\n  return Promise.resolve(description);\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function stripTelephoneEvent(description) {\n  description.sdp = stripPayload(description.sdp || \"\", \"telephone-event\");\n  return Promise.resolve(description);\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function cleanJitsiSdpImageattr(description) {\n  description.sdp = (description.sdp || \"\").replace(/^(a=imageattr:.*?)(x|y)=\\[0-/gm, \"$1$2=[1:\");\n  return Promise.resolve(description);\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function stripG722(description) {\n  description.sdp = stripPayload(description.sdp || \"\", \"G722\");\n  return Promise.resolve(description);\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function stripRtpPayload(payload) {\n  return description => {\n    description.sdp = stripPayload(description.sdp || \"\", payload);\n    return Promise.resolve(description);\n  };\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function stripVideo(description) {\n  description.sdp = stripMediaDescription(description.sdp || \"\", \"video\");\n  return Promise.resolve(description);\n}\n/**\n * Modifier.\n * @public\n */\n\nexport function addMidLines(description) {\n  let sdp = description.sdp || \"\";\n\n  if (sdp.search(/^a=mid.*$/gm) === -1) {\n    const mlines = sdp.match(/^m=.*$/gm);\n    const sdpArray = sdp.split(/^m=.*$/gm);\n\n    if (mlines) {\n      mlines.forEach((elem, idx) => {\n        mlines[idx] = elem + \"\\na=mid:\" + idx;\n      });\n    }\n\n    sdpArray.forEach((elem, idx) => {\n      if (mlines && mlines[idx]) {\n        sdpArray[idx] = elem + mlines[idx];\n      }\n    });\n    sdp = sdpArray.join(\"\");\n    description.sdp = sdp;\n  }\n\n  return Promise.resolve(description);\n}\n/**\n * The modifier that should be used when the session would like to place the call on hold.\n * @param description - The description that will be modified.\n */\n\nexport function holdModifier(description) {\n  if (!description.sdp || !description.type) {\n    throw new Error(\"Invalid SDP\");\n  }\n\n  let sdp = description.sdp;\n  const type = description.type;\n\n  if (sdp) {\n    if (!/a=(sendrecv|sendonly|recvonly|inactive)/.test(sdp)) {\n      sdp = sdp.replace(/(m=[^\\r]*\\r\\n)/g, \"$1a=sendonly\\r\\n\");\n    } else {\n      sdp = sdp.replace(/a=sendrecv\\r\\n/g, \"a=sendonly\\r\\n\");\n      sdp = sdp.replace(/a=recvonly\\r\\n/g, \"a=inactive\\r\\n\");\n    }\n  }\n\n  return Promise.resolve({\n    sdp,\n    type\n  });\n}","map":null,"metadata":{},"sourceType":"module"}