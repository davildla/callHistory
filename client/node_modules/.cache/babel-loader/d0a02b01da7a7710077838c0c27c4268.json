{"ast":null,"code":"import { C } from \"../messages/methods/constants.js\";\nimport { IncomingResponseMessage } from \"../messages/incoming-response-message.js\";\nimport { NonInviteClientTransaction } from \"../transactions/non-invite-client-transaction.js\";\nimport { TransactionState } from \"../transactions/transaction-state.js\";\n/**\n * User Agent Client (UAC).\n * @remarks\n * A user agent client is a logical entity\n * that creates a new request, and then uses the client\n * transaction state machinery to send it.  The role of UAC lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software initiates a request, it acts as a UAC for\n * the duration of that transaction.  If it receives a request\n * later, it assumes the role of a user agent server for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport class UserAgentClient {\n  constructor(transactionConstructor, core, message, delegate) {\n    this.transactionConstructor = transactionConstructor;\n    this.core = core;\n    this.message = message;\n    this.delegate = delegate;\n    this.challenged = false;\n    this.stale = false;\n    this.logger = this.loggerFactory.getLogger(\"sip.user-agent-client\");\n    this.init();\n  }\n\n  dispose() {\n    this.transaction.dispose();\n  }\n\n  get loggerFactory() {\n    return this.core.loggerFactory;\n  }\n  /** The transaction associated with this request. */\n\n\n  get transaction() {\n    if (!this._transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    return this._transaction;\n  }\n  /**\n   * Since requests other than INVITE are responded to immediately, sending a\n   * CANCEL for a non-INVITE request would always create a race condition.\n   * A CANCEL request SHOULD NOT be sent to cancel a request other than INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-9.1\n   * @param options - Cancel options bucket.\n   */\n\n\n  cancel(reason) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    if (!this.message.to) {\n      throw new Error(\"To undefined.\");\n    }\n\n    if (!this.message.from) {\n      throw new Error(\"From undefined.\");\n    } // The following procedures are used to construct a CANCEL request.  The\n    // Request-URI, Call-ID, To, the numeric part of CSeq, and From header\n    // fields in the CANCEL request MUST be identical to those in the\n    // request being cancelled, including tags.  A CANCEL constructed by a\n    // client MUST have only a single Via header field value matching the\n    // top Via value in the request being cancelled.  Using the same values\n    // for these header fields allows the CANCEL to be matched with the\n    // request it cancels (Section 9.2 indicates how such matching occurs).\n    // However, the method part of the CSeq header field MUST have a value\n    // of CANCEL.  This allows it to be identified and processed as a\n    // transaction in its own right (See Section 17).\n    // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n    const message = this.core.makeOutgoingRequestMessage(C.CANCEL, this.message.ruri, this.message.from.uri, this.message.to.uri, {\n      toTag: this.message.toTag,\n      fromTag: this.message.fromTag,\n      callId: this.message.callId,\n      cseq: this.message.cseq\n    }, options.extraHeaders); // TODO: Revisit this.\n    // The CANCEL needs to use the same branch parameter so that\n    // it matches the INVITE transaction, but this is a hacky way to do this.\n    // Or at the very least not well documented. If the the branch parameter\n    // is set on the outgoing request, the transaction will use it.\n    // Otherwise the transaction will make a new one.\n\n    message.branch = this.message.branch;\n\n    if (this.message.headers.Route) {\n      message.headers.Route = this.message.headers.Route;\n    }\n\n    if (reason) {\n      message.setHeader(\"Reason\", reason);\n    } // If no provisional response has been received, the CANCEL request MUST\n    // NOT be sent; rather, the client MUST wait for the arrival of a\n    // provisional response before sending the request. If the original\n    // request has generated a final response, the CANCEL SHOULD NOT be\n    // sent, as it is an effective no-op, since CANCEL has no effect on\n    // requests that have already generated a final response.\n    // https://tools.ietf.org/html/rfc3261#section-9.1\n\n\n    if (this.transaction.state === TransactionState.Proceeding) {\n      new UserAgentClient(NonInviteClientTransaction, this.core, message);\n    } else {\n      this.transaction.addStateChangeListener(() => {\n        if (this.transaction && this.transaction.state === TransactionState.Proceeding) {\n          new UserAgentClient(NonInviteClientTransaction, this.core, message);\n        }\n      }, {\n        once: true\n      });\n    }\n\n    return message;\n  }\n  /**\n   * If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n   * response is received, the UAC SHOULD follow the authorization\n   * procedures of Section 22.2 and Section 22.3 to retry the request with\n   * credentials.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n   * 22 Usage of HTTP Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22\n   * 22.1 Framework\n   * https://tools.ietf.org/html/rfc3261#section-22.1\n   * 22.2 User-to-User Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22.2\n   * 22.3 Proxy-to-User Authentication\n   * https://tools.ietf.org/html/rfc3261#section-22.3\n   *\n   * FIXME: This \"guard for and retry the request with credentials\"\n   * implementation is not complete and at best minimally passable.\n   * @param response - The incoming response to guard.\n   * @param dialog - If defined, the dialog within which the response was received.\n   * @returns True if the program execution is to continue in the branch in question.\n   *          Otherwise the request is retried with credentials and current request processing must stop.\n   */\n\n\n  authenticationGuard(message, dialog) {\n    const statusCode = message.statusCode;\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    } // If a 401 (Unauthorized) or 407 (Proxy Authentication Required)\n    // response is received, the UAC SHOULD follow the authorization\n    // procedures of Section 22.2 and Section 22.3 to retry the request with\n    // credentials.\n    // https://tools.ietf.org/html/rfc3261#section-8.1.3.5\n\n\n    if (statusCode !== 401 && statusCode !== 407) {\n      return true;\n    } // Get and parse the appropriate WWW-Authenticate or Proxy-Authenticate header.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    let challenge;\n    let authorizationHeaderName;\n\n    if (statusCode === 401) {\n      challenge = message.parseHeader(\"www-authenticate\");\n      authorizationHeaderName = \"authorization\";\n    } else {\n      challenge = message.parseHeader(\"proxy-authenticate\");\n      authorizationHeaderName = \"proxy-authorization\";\n    } // Verify it seems a valid challenge.\n\n\n    if (!challenge) {\n      this.logger.warn(statusCode + \" with wrong or missing challenge, cannot authenticate\");\n      return true;\n    } // Avoid infinite authentications.\n\n\n    if (this.challenged && (this.stale || challenge.stale !== true)) {\n      this.logger.warn(statusCode + \" apparently in authentication loop, cannot authenticate\");\n      return true;\n    } // Get credentials.\n\n\n    if (!this.credentials) {\n      this.credentials = this.core.configuration.authenticationFactory();\n\n      if (!this.credentials) {\n        this.logger.warn(\"Unable to obtain credentials, cannot authenticate\");\n        return true;\n      }\n    } // Verify that the challenge is really valid.\n\n\n    if (!this.credentials.authenticate(this.message, challenge)) {\n      return true;\n    }\n\n    this.challenged = true;\n\n    if (challenge.stale) {\n      this.stale = true;\n    } // If response to out of dialog request, assume incrementing the CSeq will suffice.\n\n\n    let cseq = this.message.cseq += 1; // If response to in dialog request, get a valid next CSeq number.\n\n    if (dialog && dialog.localSequenceNumber) {\n      dialog.incrementLocalSequenceNumber();\n      cseq = this.message.cseq = dialog.localSequenceNumber;\n    }\n\n    this.message.setHeader(\"cseq\", cseq + \" \" + this.message.method);\n    this.message.setHeader(authorizationHeaderName, this.credentials.toString()); // Calling init (again) will swap out our existing client transaction with a new one.\n    // FIXME: HACK: An assumption is being made here that there is nothing that needs to\n    // be cleaned up beyond the client transaction which is being replaced. For example,\n    // it is assumed that no early dialogs have been created.\n\n    this.init();\n    return false;\n  }\n  /**\n   * 8.1.3.1 Transaction Layer Errors\n   * In some cases, the response returned by the transaction layer will\n   * not be a SIP message, but rather a transaction layer error.  When a\n   * timeout error is received from the transaction layer, it MUST be\n   * treated as if a 408 (Request Timeout) status code has been received.\n   * If a fatal transport error is reported by the transport layer\n   * (generally, due to fatal ICMP errors in UDP or connection failures in\n   * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n   * status code.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n   */\n\n\n  onRequestTimeout() {\n    this.logger.warn(\"User agent client request timed out. Generating internal 408 Request Timeout.\");\n    const message = new IncomingResponseMessage();\n    message.statusCode = 408;\n    message.reasonPhrase = \"Request Timeout\";\n    this.receiveResponse(message);\n    return;\n  }\n  /**\n   * 8.1.3.1 Transaction Layer Errors\n   * In some cases, the response returned by the transaction layer will\n   * not be a SIP message, but rather a transaction layer error.  When a\n   * timeout error is received from the transaction layer, it MUST be\n   * treated as if a 408 (Request Timeout) status code has been received.\n   * If a fatal transport error is reported by the transport layer\n   * (generally, due to fatal ICMP errors in UDP or connection failures in\n   * TCP), the condition MUST be treated as a 503 (Service Unavailable)\n   * status code.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.3.1\n   * @param error - Transport error\n   */\n\n\n  onTransportError(error) {\n    this.logger.error(error.message);\n    this.logger.error(\"User agent client request transport error. Generating internal 503 Service Unavailable.\");\n    const message = new IncomingResponseMessage();\n    message.statusCode = 503;\n    message.reasonPhrase = \"Service Unavailable\";\n    this.receiveResponse(message);\n  }\n  /**\n   * Receive a response from the transaction layer.\n   * @param message - Incoming response message.\n   */\n\n\n  receiveResponse(message) {\n    if (!this.authenticationGuard(message)) {\n      return;\n    }\n\n    const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    }\n\n    switch (true) {\n      case /^100$/.test(statusCode):\n        if (this.delegate && this.delegate.onTrying) {\n          this.delegate.onTrying({\n            message\n          });\n        }\n\n        break;\n\n      case /^1[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onProgress) {\n          this.delegate.onProgress({\n            message\n          });\n        }\n\n        break;\n\n      case /^2[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onAccept) {\n          this.delegate.onAccept({\n            message\n          });\n        }\n\n        break;\n\n      case /^3[0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onRedirect) {\n          this.delegate.onRedirect({\n            message\n          });\n        }\n\n        break;\n\n      case /^[4-6][0-9]{2}$/.test(statusCode):\n        if (this.delegate && this.delegate.onReject) {\n          this.delegate.onReject({\n            message\n          });\n        }\n\n        break;\n\n      default:\n        throw new Error(`Invalid status code ${statusCode}`);\n    }\n  }\n\n  init() {\n    // We are the transaction user.\n    const user = {\n      loggerFactory: this.loggerFactory,\n      onRequestTimeout: () => this.onRequestTimeout(),\n      onStateChange: newState => {\n        if (newState === TransactionState.Terminated) {\n          // Remove the terminated transaction from the core.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          this.core.userAgentClients.delete(userAgentClientId); // FIXME: HACK: Our transaction may have been swapped out with a new one\n          // post authentication (see above), so make sure to only to dispose of\n          // ourselves if this terminating transaction is our current transaction.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n          if (transaction === this._transaction) {\n            this.dispose();\n          }\n        }\n      },\n      onTransportError: error => this.onTransportError(error),\n      receiveResponse: message => this.receiveResponse(message)\n    }; // Create a new transaction with us as the user.\n\n    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n    this._transaction = transaction; // Add the new transaction to the core.\n\n    const userAgentClientId = transaction.id + transaction.request.method;\n    this.core.userAgentClients.set(userAgentClientId, this);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}