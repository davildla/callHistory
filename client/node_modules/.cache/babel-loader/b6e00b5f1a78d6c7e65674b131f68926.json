{"ast":null,"code":"import { SubscriptionDialog } from \"../dialogs/subscription-dialog.js\";\nimport { SubscriptionState } from \"../subscription/subscription.js\";\nimport { Timers } from \"../timers.js\";\nimport { NonInviteClientTransaction } from \"../transactions/non-invite-client-transaction.js\";\nimport { UserAgentClient } from \"./user-agent-client.js\";\n/**\n * SUBSCRIBE UAC.\n * @remarks\n * 4.1.  Subscriber Behavior\n * https://tools.ietf.org/html/rfc6665#section-4.1\n *\n * User agent client for installation of a single subscription per SUBSCRIBE request.\n * TODO: Support for installation of multiple subscriptions on forked SUBSCRIBE requests.\n * @public\n */\n\nexport class SubscribeUserAgentClient extends UserAgentClient {\n  constructor(core, message, delegate) {\n    // Get event from request message.\n    const event = message.getHeader(\"Event\");\n\n    if (!event) {\n      throw new Error(\"Event undefined\");\n    } // Get expires from request message.\n\n\n    const expires = message.getHeader(\"Expires\");\n\n    if (!expires) {\n      throw new Error(\"Expires undefined\");\n    }\n\n    super(NonInviteClientTransaction, core, message, delegate);\n    this.delegate = delegate; // FIXME: Subscriber id should also be matching on event id.\n\n    this.subscriberId = message.callId + message.fromTag + event;\n    this.subscriptionExpiresRequested = this.subscriptionExpires = Number(expires);\n    this.subscriptionEvent = event;\n    this.subscriptionState = SubscriptionState.NotifyWait; // Start waiting for a NOTIFY we can use to create a subscription.\n\n    this.waitNotifyStart();\n  }\n  /**\n   * Destructor.\n   * Note that Timer N may live on waiting for an initial NOTIFY and\n   * the delegate may still receive that NOTIFY. If you don't want\n   * that behavior then either clear the delegate so the delegate\n   * doesn't get called (a 200 will be sent in response to the NOTIFY)\n   * or call `waitNotifyStop` which will clear Timer N and remove this\n   * UAC from the core (a 481 will be sent in response to the NOTIFY).\n   */\n\n\n  dispose() {\n    super.dispose();\n  }\n  /**\n   * Handle out of dialog NOTIFY associated with SUBSCRIBE request.\n   * This is the first NOTIFY received after the SUBSCRIBE request.\n   * @param uas - User agent server handling the subscription creating NOTIFY.\n   */\n\n\n  onNotify(uas) {\n    // NOTIFY requests are matched to such SUBSCRIBE requests if they\n    // contain the same \"Call-ID\", a \"To\" header field \"tag\" parameter that\n    // matches the \"From\" header field \"tag\" parameter of the SUBSCRIBE\n    // request, and the same \"Event\" header field.  Rules for comparisons of\n    // the \"Event\" header fields are described in Section 8.2.1.\n    // https://tools.ietf.org/html/rfc6665#section-4.4.1\n    const event = uas.message.parseHeader(\"Event\").event;\n\n    if (!event || event !== this.subscriptionEvent) {\n      this.logger.warn(`Failed to parse event.`);\n      uas.reject({\n        statusCode: 489\n      });\n      return;\n    } // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n    // indicate the status of the subscription.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    const subscriptionState = uas.message.parseHeader(\"Subscription-State\");\n\n    if (!subscriptionState || !subscriptionState.state) {\n      this.logger.warn(\"Failed to parse subscription state.\");\n      uas.reject({\n        statusCode: 489\n      });\n      return;\n    } // Validate subscription state.\n\n\n    const state = subscriptionState.state;\n\n    switch (state) {\n      case \"pending\":\n        break;\n\n      case \"active\":\n        break;\n\n      case \"terminated\":\n        break;\n\n      default:\n        this.logger.warn(`Invalid subscription state ${state}`);\n        uas.reject({\n          statusCode: 489\n        });\n        return;\n    } // Dialogs usages are created upon completion of a NOTIFY transaction\n    // for a new subscription, unless the NOTIFY request contains a\n    // \"Subscription-State\" of \"terminated.\"\n    // https://tools.ietf.org/html/rfc6665#section-4.4.1\n\n\n    if (state !== \"terminated\") {\n      // The Contact header field MUST be present and contain exactly one SIP\n      // or SIPS URI in any request that can result in the establishment of a\n      // dialog.\n      // https://tools.ietf.org/html/rfc3261#section-8.1.1.8\n      const contact = uas.message.parseHeader(\"contact\");\n\n      if (!contact) {\n        this.logger.warn(\"Failed to parse contact.\");\n        uas.reject({\n          statusCode: 489\n        });\n        return;\n      }\n    } // In accordance with the rules for proxying non-INVITE requests as\n    // defined in [RFC3261], successful SUBSCRIBE requests will receive only\n    // one 200-class response; however, due to forking, the subscription may\n    // have been accepted by multiple nodes.  The subscriber MUST therefore\n    // be prepared to receive NOTIFY requests with \"From:\" tags that differ\n    // from the \"To:\" tag received in the SUBSCRIBE 200-class response.\n    //\n    // If multiple NOTIFY requests are received in different dialogs in\n    // response to a single SUBSCRIBE request, each dialog represents a\n    // different destination to which the SUBSCRIBE request was forked.\n    // Subscriber handling in such situations varies by event package; see\n    // Section 5.4.9 for details.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.4\n    // Each event package MUST specify whether forked SUBSCRIBE requests are\n    // allowed to install multiple subscriptions.\n    //\n    // If such behavior is not allowed, the first potential dialog-\n    // establishing message will create a dialog.  All subsequent NOTIFY\n    // requests that correspond to the SUBSCRIBE request (i.e., have\n    // matching \"To\", \"From\", \"Call-ID\", and \"Event\" header fields, as well\n    // as \"From\" header field \"tag\" parameter and \"Event\" header field \"id\"\n    // parameter) but that do not match the dialog would be rejected with a\n    // 481 response.  Note that the 200-class response to the SUBSCRIBE\n    // request can arrive after a matching NOTIFY request has been received;\n    // such responses might not correlate to the same dialog established by\n    // the NOTIFY request.  Except as required to complete the SUBSCRIBE\n    // transaction, such non-matching 200-class responses are ignored.\n    //\n    // If installing of multiple subscriptions by way of a single forked\n    // SUBSCRIBE request is allowed, the subscriber establishes a new dialog\n    // towards each notifier by returning a 200-class response to each\n    // NOTIFY request.  Each dialog is then handled as its own entity and is\n    // refreshed independently of the other dialogs.\n    //\n    // In the case that multiple subscriptions are allowed, the event\n    // package MUST specify whether merging of the notifications to form a\n    // single state is required, and how such merging is to be performed.\n    // Note that it is possible that some event packages may be defined in\n    // such a way that each dialog is tied to a mutually exclusive state\n    // that is unaffected by the other dialogs; this MUST be clearly stated\n    // if it is the case.\n    // https://tools.ietf.org/html/rfc6665#section-5.4.9\n    // *** NOTE: This implementation is only for event packages which\n    // do not allow forked requests to install multiple subscriptions.\n    // As such and in accordance with the specification, we stop waiting\n    // and any future NOTIFY requests will be rejected with a 481.\n\n\n    if (this.dialog) {\n      throw new Error(\"Dialog already created. This implementation only supports install of single subscriptions.\");\n    }\n\n    this.waitNotifyStop(); // Update expires.\n\n    this.subscriptionExpires = subscriptionState.expires ? Math.min(this.subscriptionExpires, Math.max(subscriptionState.expires, 0)) : this.subscriptionExpires; // Update subscription state.\n\n    switch (state) {\n      case \"pending\":\n        this.subscriptionState = SubscriptionState.Pending;\n        break;\n\n      case \"active\":\n        this.subscriptionState = SubscriptionState.Active;\n        break;\n\n      case \"terminated\":\n        this.subscriptionState = SubscriptionState.Terminated;\n        break;\n\n      default:\n        throw new Error(`Unrecognized state ${state}.`);\n    } // Dialogs usages are created upon completion of a NOTIFY transaction\n    // for a new subscription, unless the NOTIFY request contains a\n    // \"Subscription-State\" of \"terminated.\"\n    // https://tools.ietf.org/html/rfc6665#section-4.4.1\n\n\n    if (this.subscriptionState !== SubscriptionState.Terminated) {\n      // Because the dialog usage is established by the NOTIFY request, the\n      // route set at the subscriber is taken from the NOTIFY request itself,\n      // as opposed to the route set present in the 200-class response to the\n      // SUBSCRIBE request.\n      // https://tools.ietf.org/html/rfc6665#section-4.4.1\n      const dialogState = SubscriptionDialog.initialDialogStateForSubscription(this.message, uas.message); // Subscription Initiated! :)\n\n      this.dialog = new SubscriptionDialog(this.subscriptionEvent, this.subscriptionExpires, this.subscriptionState, this.core, dialogState);\n    } // Delegate.\n\n\n    if (this.delegate && this.delegate.onNotify) {\n      const request = uas;\n      const subscription = this.dialog;\n      this.delegate.onNotify({\n        request,\n        subscription\n      });\n    } else {\n      uas.accept();\n    }\n  }\n\n  waitNotifyStart() {\n    if (!this.N) {\n      // Add ourselves to the core's subscriber map.\n      // This allows the core to route out of dialog NOTIFY messages to us.\n      this.core.subscribers.set(this.subscriberId, this);\n      this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n    }\n  }\n\n  waitNotifyStop() {\n    if (this.N) {\n      // Remove ourselves to the core's subscriber map.\n      // Any future out of dialog NOTIFY messages will be rejected with a 481.\n      this.core.subscribers.delete(this.subscriberId);\n      clearTimeout(this.N);\n      this.N = undefined;\n    }\n  }\n  /**\n   * Receive a response from the transaction layer.\n   * @param message - Incoming response message.\n   */\n\n\n  receiveResponse(message) {\n    if (!this.authenticationGuard(message)) {\n      return;\n    }\n\n    if (message.statusCode && message.statusCode >= 200 && message.statusCode < 300) {\n      //  The \"Expires\" header field in a 200-class response to SUBSCRIBE\n      //  request indicates the actual duration for which the subscription will\n      //  remain active (unless refreshed).  The received value might be\n      //  smaller than the value indicated in the SUBSCRIBE request but cannot\n      //  be larger; see Section 4.2.1 for details.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n      // The \"Expires\" values present in SUBSCRIBE 200-class responses behave\n      // in the same way as they do in REGISTER responses: the server MAY\n      // shorten the interval but MUST NOT lengthen it.\n      //\n      //    If the duration specified in a SUBSCRIBE request is unacceptably\n      //    short, the notifier may be able to send a 423 response, as\n      //    described earlier in this section.\n      //\n      // 200-class responses to SUBSCRIBE requests will not generally contain\n      // any useful information beyond subscription duration; their primary\n      // purpose is to serve as a reliability mechanism.  State information\n      // will be communicated via a subsequent NOTIFY request from the\n      // notifier.\n      // https://tools.ietf.org/html/rfc6665#section-4.2.1.1\n      const expires = message.getHeader(\"Expires\");\n\n      if (!expires) {\n        this.logger.warn(\"Expires header missing in a 200-class response to SUBSCRIBE\");\n      } else {\n        const subscriptionExpiresReceived = Number(expires);\n\n        if (subscriptionExpiresReceived > this.subscriptionExpiresRequested) {\n          this.logger.warn(\"Expires header in a 200-class response to SUBSCRIBE with a higher value than the one in the request\");\n        }\n\n        if (subscriptionExpiresReceived < this.subscriptionExpires) {\n          this.subscriptionExpires = subscriptionExpiresReceived;\n        }\n      } // If a NOTIFY arrived before 200-class response a dialog may have been created.\n      // Updated the dialogs expiration only if this indicates earlier expiration.\n\n\n      if (this.dialog) {\n        if (this.dialog.subscriptionExpires > this.subscriptionExpires) {\n          this.dialog.subscriptionExpires = this.subscriptionExpires;\n        }\n      }\n    }\n\n    if (message.statusCode && message.statusCode >= 300 && message.statusCode < 700) {\n      this.waitNotifyStop(); // No NOTIFY will be sent after a negative final response.\n    }\n\n    super.receiveResponse(message);\n  }\n  /**\n   * To ensure that subscribers do not wait indefinitely for a\n   * subscription to be established, a subscriber starts a Timer N, set to\n   * 64*T1, when it sends a SUBSCRIBE request.  If this Timer N expires\n   * prior to the receipt of a NOTIFY request, the subscriber considers\n   * the subscription failed, and cleans up any state associated with the\n   * subscription attempt.\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n   */\n\n\n  timerN() {\n    this.logger.warn(`Timer N expired for SUBSCRIBE user agent client. Timed out waiting for NOTIFY.`);\n    this.waitNotifyStop();\n\n    if (this.delegate && this.delegate.onNotifyTimeout) {\n      this.delegate.onNotifyTimeout();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}