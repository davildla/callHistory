{"ast":null,"code":"import { fromBodyLegacy } from \"../core/messages/body.js\";\nimport { C } from \"../core/messages/methods/constants.js\";\nimport { SubscriptionState as SubscriptionDialogState } from \"../core/subscription/subscription.js\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods.js\";\nimport { Notification } from \"./notification.js\";\nimport { Subscription } from \"./subscription.js\";\nimport { SubscriptionState } from \"./subscription-state.js\";\n/**\n * A subscriber establishes a {@link Subscription} (outgoing SUBSCRIBE).\n *\n * @remarks\n * This is (more or less) an implementation of a \"subscriber\" as\n * defined in RFC 6665 \"SIP-Specific Event Notifications\".\n * https://tools.ietf.org/html/rfc6665\n *\n * @example\n * ```ts\n * // Create a new subscriber.\n * const targetURI = new URI(\"sip\", \"alice\", \"example.com\");\n * const eventType = \"example-name\"; // https://www.iana.org/assignments/sip-events/sip-events.xhtml\n * const subscriber = new Subscriber(userAgent, targetURI, eventType);\n *\n * // Add delegate to handle event notifications.\n * subscriber.delegate = {\n *   onNotify: (notification: Notification) => {\n *     // send a response\n *     notification.accept();\n *     // handle notification here\n *   }\n * };\n *\n * // Monitor subscription state changes.\n * subscriber.stateChange.addListener((newState: SubscriptionState) => {\n *   if (newState === SubscriptionState.Terminated) {\n *     // handle state change here\n *   }\n * });\n *\n * // Attempt to establish the subscription\n * subscriber.subscribe();\n *\n * // Sometime later when done with subscription\n * subscriber.unsubscribe();\n * ```\n *\n * @public\n */\n\nexport class Subscriber extends Subscription {\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - The request URI identifying the subscribed event.\n   * @param eventType - The event type identifying the subscribed event.\n   * @param options - Options bucket. See {@link SubscriberOptions} for details.\n   */\n  constructor(userAgent, targetURI, eventType) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    super(userAgent, options);\n    this.body = undefined;\n    this.logger = userAgent.getLogger(\"sip.Subscriber\");\n\n    if (options.body) {\n      this.body = {\n        body: options.body,\n        contentType: options.contentType ? options.contentType : \"application/sdp\"\n      };\n    }\n\n    this.targetURI = targetURI; // Subscription event\n\n    this.event = eventType; // Subscription expires\n\n    if (options.expires === undefined) {\n      this.expires = 3600;\n    } else if (typeof options.expires !== \"number\") {\n      // pre-typescript type guard\n      this.logger.warn(`Option \"expires\" must be a number. Using default of 3600.`);\n      this.expires = 3600;\n    } else {\n      this.expires = options.expires;\n    } // Subscription extra headers\n\n\n    this.extraHeaders = (options.extraHeaders || []).slice(); // Subscription context.\n\n    this.subscriberRequest = this.initSubscriberRequest();\n    this.outgoingRequestMessage = this.subscriberRequest.message; // Add to UserAgent's collection\n\n    this.id = this.outgoingRequestMessage.callId + this.outgoingRequestMessage.from.parameters.tag + this.event;\n    this._userAgent._subscriptions[this.id] = this;\n  }\n  /**\n   * Destructor.\n   * @internal\n   */\n\n\n  dispose() {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Subscription ${this.id} in state ${this.state} is being disposed`); // Remove from the user agent's subscription collection\n\n    delete this._userAgent._subscriptions[this.id]; // Clear timers\n\n    if (this.retryAfterTimer) {\n      clearTimeout(this.retryAfterTimer);\n      this.retryAfterTimer = undefined;\n    } // Dispose subscriber request\n\n\n    this.subscriberRequest.dispose(); // Make sure to dispose of our parent, then unsubscribe the\n    // subscription dialog (if need be) and resolve when it has terminated.\n\n    return super.dispose().then(() => {\n      // If we have never subscribed there is nothing to wait on.\n      // If we are already transitioned to terminated there is no need to unsubscribe again.\n      if (this.state !== SubscriptionState.Subscribed) {\n        return;\n      }\n\n      if (!this._dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      if (this._dialog.subscriptionState === SubscriptionDialogState.Pending || this._dialog.subscriptionState === SubscriptionDialogState.Active) {\n        const dialog = this._dialog; // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n        return new Promise((resolve, reject) => {\n          dialog.delegate = {\n            onTerminated: () => resolve()\n          };\n          dialog.unsubscribe();\n        });\n      }\n    });\n  }\n  /**\n   * Subscribe to event notifications.\n   *\n   * @remarks\n   * Send an initial SUBSCRIBE request if no subscription as been established.\n   * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  subscribe() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    switch (this.subscriberRequest.state) {\n      case SubscriptionDialogState.Initial:\n        // we can end up here when retrying so only state transition if in SubscriptionState.Initial state\n        if (this.state === SubscriptionState.Initial) {\n          this.stateTransition(SubscriptionState.NotifyWait);\n        }\n\n        this.subscriberRequest.subscribe().then(result => {\n          if (result.success) {\n            if (result.success.subscription) {\n              this._dialog = result.success.subscription;\n              this._dialog.delegate = {\n                onNotify: request => this.onNotify(request),\n                onRefresh: request => this.onRefresh(request),\n                onTerminated: () => {\n                  // If a call to unsubscribe will state transition to SubscriptionState.Terminated,\n                  // but we can end up here after that if the NOTIFY never arrives and timer N fires.\n                  if (this.state !== SubscriptionState.Terminated) {\n                    this.stateTransition(SubscriptionState.Terminated);\n                  }\n                }\n              };\n            }\n\n            this.onNotify(result.success.request);\n          } else if (result.failure) {\n            this.unsubscribe();\n          }\n        });\n        break;\n\n      case SubscriptionDialogState.NotifyWait:\n        break;\n\n      case SubscriptionDialogState.Pending:\n        break;\n\n      case SubscriptionDialogState.Active:\n        if (this._dialog) {\n          const request = this._dialog.refresh();\n\n          request.delegate = {\n            onAccept: response => this.onAccepted(response),\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onRedirect: response => this.unsubscribe(),\n            // eslint-disable-next-line @typescript-eslint/no-unused-vars\n            onReject: response => this.unsubscribe()\n          };\n        }\n\n        break;\n\n      case SubscriptionDialogState.Terminated:\n        break;\n\n      default:\n        break;\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * {@inheritDoc Subscription.unsubscribe}\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  unsubscribe() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    switch (this.subscriberRequest.state) {\n      case SubscriptionDialogState.Initial:\n        break;\n\n      case SubscriptionDialogState.NotifyWait:\n        break;\n\n      case SubscriptionDialogState.Pending:\n        if (this._dialog) {\n          this._dialog.unsubscribe(); // responses intentionally ignored\n\n        }\n\n        break;\n\n      case SubscriptionDialogState.Active:\n        if (this._dialog) {\n          this._dialog.unsubscribe(); // responses intentionally ignored\n\n        }\n\n        break;\n\n      case SubscriptionDialogState.Terminated:\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n\n    this.stateTransition(SubscriptionState.Terminated);\n    return Promise.resolve();\n  }\n  /**\n   * Sends a re-SUBSCRIBE request if the subscription is \"active\".\n   * @deprecated Use `subscribe` instead.\n   * @internal\n   */\n\n\n  _refresh() {\n    if (this.subscriberRequest.state === SubscriptionDialogState.Active) {\n      return this.subscribe();\n    }\n\n    return Promise.resolve();\n  }\n  /** @internal */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onAccepted(response) {// NOTE: If you think you should do something with this response,\n    // please make sure you understand what it is you are doing and why.\n    // Per the RFC, the first NOTIFY is all that actually matters.\n  }\n  /** @internal */\n\n\n  onNotify(request) {\n    // If we've set state to done, no further processing should take place\n    // and we are only interested in cleaning up after the appropriate NOTIFY.\n    if (this.disposed) {\n      request.accept();\n      return;\n    } // State transition if needed.\n\n\n    if (this.state !== SubscriptionState.Subscribed) {\n      this.stateTransition(SubscriptionState.Subscribed);\n    } // Delegate notification.\n\n\n    if (this.delegate && this.delegate.onNotify) {\n      const notification = new Notification(request);\n      this.delegate.onNotify(notification);\n    } else {\n      request.accept();\n    } //  If the \"Subscription-State\" value is SubscriptionState.Terminated, the subscriber\n    //  MUST consider the subscription terminated.  The \"expires\" parameter\n    //  has no semantics for SubscriptionState.Terminated -- notifiers SHOULD NOT include an\n    //  \"expires\" parameter on a \"Subscription-State\" header field with a\n    //  value of SubscriptionState.Terminated, and subscribers MUST ignore any such\n    //  parameter, if present.  If a reason code is present, the client\n    //  should behave as described below.  If no reason code or an unknown\n    //  reason code is present, the client MAY attempt to re-subscribe at any\n    //  time (unless a \"retry-after\" parameter is present, in which case the\n    //  client SHOULD NOT attempt re-subscription until after the number of\n    //  seconds specified by the \"retry-after\" parameter).  The reason codes\n    //  defined by this document are:\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    const subscriptionState = request.message.parseHeader(\"Subscription-State\");\n\n    if (subscriptionState && subscriptionState.state) {\n      switch (subscriptionState.state) {\n        case \"terminated\":\n          if (subscriptionState.reason) {\n            this.logger.log(`Terminated subscription with reason ${subscriptionState.reason}`);\n\n            switch (subscriptionState.reason) {\n              case \"deactivated\":\n              case \"timeout\":\n                this.initSubscriberRequest();\n                this.subscribe();\n                return;\n\n              case \"probation\":\n              case \"giveup\":\n                this.initSubscriberRequest();\n\n                if (subscriptionState.params && subscriptionState.params[\"retry-after\"]) {\n                  this.retryAfterTimer = setTimeout(() => {\n                    this.subscribe();\n                  }, subscriptionState.params[\"retry-after\"]);\n                } else {\n                  this.subscribe();\n                }\n\n                return;\n\n              case \"rejected\":\n              case \"noresource\":\n              case \"invariant\":\n                break;\n            }\n          }\n\n          this.unsubscribe();\n          break;\n\n        default:\n          break;\n      }\n    }\n  }\n  /** @internal */\n\n\n  onRefresh(request) {\n    request.delegate = {\n      onAccept: response => this.onAccepted(response)\n    };\n  }\n\n  initSubscriberRequest() {\n    const options = {\n      extraHeaders: this.extraHeaders,\n      body: this.body ? fromBodyLegacy(this.body) : undefined\n    }; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n    this.subscriberRequest = new SubscriberRequest(this._userAgent.userAgentCore, this.targetURI, this.event, this.expires, options);\n    this.subscriberRequest.delegate = {\n      onAccept: response => this.onAccepted(response)\n    };\n    return this.subscriberRequest;\n  }\n\n}\n\nclass SubscriberRequest {\n  constructor(core, target, event, expires, options, delegate) {\n    this.core = core;\n    this.target = target;\n    this.event = event;\n    this.expires = expires;\n    this.subscribed = false;\n    this.logger = core.loggerFactory.getLogger(\"sip.Subscriber\");\n    this.delegate = delegate;\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const extraHeaders = (options && options.extraHeaders || []).slice();\n    extraHeaders.push(allowHeader);\n    extraHeaders.push(\"Event: \" + this.event);\n    extraHeaders.push(\"Expires: \" + this.expires);\n    extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    const body = options && options.body;\n    this.message = core.makeOutgoingRequestMessage(C.SUBSCRIBE, this.target, this.core.configuration.aor, this.target, {}, extraHeaders, body);\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    if (this.request) {\n      this.request.waitNotifyStop();\n      this.request.dispose();\n      this.request = undefined;\n    }\n  }\n  /** Subscription state. */\n\n\n  get state() {\n    if (this.subscription) {\n      return this.subscription.subscriptionState;\n    } else if (this.subscribed) {\n      return SubscriptionDialogState.NotifyWait;\n    } else {\n      return SubscriptionDialogState.Initial;\n    }\n  }\n  /**\n   * Establish subscription.\n   * @param options Options bucket.\n   */\n\n\n  subscribe() {\n    if (this.subscribed) {\n      return Promise.reject(new Error(\"Not in initial state. Did you call subscribe more than once?\"));\n    }\n\n    this.subscribed = true;\n    return new Promise(resolve => {\n      if (!this.message) {\n        throw new Error(\"Message undefined.\");\n      }\n\n      this.request = this.core.subscribe(this.message, {\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // 200-class responses indicate that the subscription has been accepted\n        // and that a NOTIFY request will be sent immediately.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onAccept: response => {\n          if (this.delegate && this.delegate.onAccept) {\n            this.delegate.onAccept(response);\n          }\n        },\n        // Due to the potential for out-of-order messages, packet loss, and\n        // forking, the subscriber MUST be prepared to receive NOTIFY requests\n        // before the SUBSCRIBE transaction has completed.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n        onNotify: requestWithSubscription => {\n          this.subscription = requestWithSubscription.subscription;\n\n          if (this.subscription) {\n            this.subscription.autoRefresh = true;\n          }\n\n          resolve({\n            success: requestWithSubscription\n          });\n        },\n        // If this Timer N expires prior to the receipt of a NOTIFY request,\n        // the subscriber considers the subscription failed, and cleans up\n        // any state associated with the subscription attempt.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.4\n        onNotifyTimeout: () => {\n          resolve({\n            failure: {}\n          });\n        },\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // Non-200-class final responses indicate that no subscription or new\n        // dialog usage has been created, and no subsequent NOTIFY request will\n        // be sent.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onRedirect: response => {\n          resolve({\n            failure: {\n              response\n            }\n          });\n        },\n        // This SUBSCRIBE request will be confirmed with a final response.\n        // Non-200-class final responses indicate that no subscription or new\n        // dialog usage has been created, and no subsequent NOTIFY request will\n        // be sent.\n        // https://tools.ietf.org/html/rfc6665#section-4.1.2.1\n        onReject: response => {\n          resolve({\n            failure: {\n              response\n            }\n          });\n        }\n      });\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}