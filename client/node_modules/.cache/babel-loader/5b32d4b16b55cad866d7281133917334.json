{"ast":null,"code":"/* eslint-disable no-inner-declarations */\n\n/* eslint-disable @typescript-eslint/no-namespace */\nimport { Grammar } from \"../../grammar/grammar.js\";\nimport { IncomingRequestMessage } from \"./incoming-request-message.js\";\nimport { IncomingResponseMessage } from \"./incoming-response-message.js\";\n/**\n * Extract and parse every header of a SIP message.\n * @internal\n */\n\nexport var Parser;\n\n(function (Parser) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function getHeader(data, headerStart) {\n    // 'start' position of the header.\n    let start = headerStart; // 'end' position of the header.\n\n    let end = 0; // 'partial end' position of the header.\n\n    let partialEnd = 0; // End of message.\n\n    if (data.substring(start, start + 2).match(/(^\\r\\n)/)) {\n      return -2;\n    }\n\n    while (end === 0) {\n      // Partial End of Header.\n      partialEnd = data.indexOf(\"\\r\\n\", start); // 'indexOf' returns -1 if the value to be found never occurs.\n\n      if (partialEnd === -1) {\n        return partialEnd;\n      }\n\n      if (!data.substring(partialEnd + 2, partialEnd + 4).match(/(^\\r\\n)/) && data.charAt(partialEnd + 2).match(/(^\\s+)/)) {\n        // Not the end of the message. Continue from the next position.\n        start = partialEnd + 2;\n      } else {\n        end = partialEnd;\n      }\n    }\n\n    return end;\n  }\n\n  Parser.getHeader = getHeader;\n\n  function parseHeader(message, // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data, headerStart, headerEnd) {\n    const hcolonIndex = data.indexOf(\":\", headerStart);\n    const headerName = data.substring(headerStart, hcolonIndex).trim();\n    const headerValue = data.substring(hcolonIndex + 1, headerEnd).trim(); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n    let parsed; // If header-field is well-known, parse it.\n\n    switch (headerName.toLowerCase()) {\n      case \"via\":\n      case \"v\":\n        message.addHeader(\"via\", headerValue);\n\n        if (message.getHeaders(\"via\").length === 1) {\n          parsed = message.parseHeader(\"Via\");\n\n          if (parsed) {\n            message.via = parsed;\n            message.viaBranch = parsed.branch;\n          }\n        } else {\n          parsed = 0;\n        }\n\n        break;\n\n      case \"from\":\n      case \"f\":\n        message.setHeader(\"from\", headerValue);\n        parsed = message.parseHeader(\"from\");\n\n        if (parsed) {\n          message.from = parsed;\n          message.fromTag = parsed.getParam(\"tag\");\n        }\n\n        break;\n\n      case \"to\":\n      case \"t\":\n        message.setHeader(\"to\", headerValue);\n        parsed = message.parseHeader(\"to\");\n\n        if (parsed) {\n          message.to = parsed;\n          message.toTag = parsed.getParam(\"tag\");\n        }\n\n        break;\n\n      case \"record-route\":\n        parsed = Grammar.parse(headerValue, \"Record_Route\");\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        if (!(parsed instanceof Array)) {\n          parsed = undefined;\n          break;\n        }\n\n        parsed.forEach(header => {\n          message.addHeader(\"record-route\", headerValue.substring(header.position, header.offset));\n          message.headers[\"Record-Route\"][message.getHeaders(\"record-route\").length - 1].parsed = header.parsed;\n        });\n        break;\n\n      case \"call-id\":\n      case \"i\":\n        message.setHeader(\"call-id\", headerValue);\n        parsed = message.parseHeader(\"call-id\");\n\n        if (parsed) {\n          message.callId = headerValue;\n        }\n\n        break;\n\n      case \"contact\":\n      case \"m\":\n        parsed = Grammar.parse(headerValue, \"Contact\");\n\n        if (parsed === -1) {\n          parsed = undefined;\n          break;\n        }\n\n        if (!(parsed instanceof Array)) {\n          parsed = undefined;\n          break;\n        }\n\n        parsed.forEach(header => {\n          message.addHeader(\"contact\", headerValue.substring(header.position, header.offset));\n          message.headers.Contact[message.getHeaders(\"contact\").length - 1].parsed = header.parsed;\n        });\n        break;\n\n      case \"content-length\":\n      case \"l\":\n        message.setHeader(\"content-length\", headerValue);\n        parsed = message.parseHeader(\"content-length\");\n        break;\n\n      case \"content-type\":\n      case \"c\":\n        message.setHeader(\"content-type\", headerValue);\n        parsed = message.parseHeader(\"content-type\");\n        break;\n\n      case \"cseq\":\n        message.setHeader(\"cseq\", headerValue);\n        parsed = message.parseHeader(\"cseq\");\n\n        if (parsed) {\n          message.cseq = parsed.value;\n        }\n\n        if (message instanceof IncomingResponseMessage) {\n          message.method = parsed.method;\n        }\n\n        break;\n\n      case \"max-forwards\":\n        message.setHeader(\"max-forwards\", headerValue);\n        parsed = message.parseHeader(\"max-forwards\");\n        break;\n\n      case \"www-authenticate\":\n        message.setHeader(\"www-authenticate\", headerValue);\n        parsed = message.parseHeader(\"www-authenticate\");\n        break;\n\n      case \"proxy-authenticate\":\n        message.setHeader(\"proxy-authenticate\", headerValue);\n        parsed = message.parseHeader(\"proxy-authenticate\");\n        break;\n\n      case \"refer-to\":\n      case \"r\":\n        message.setHeader(\"refer-to\", headerValue);\n        parsed = message.parseHeader(\"refer-to\");\n\n        if (parsed) {\n          message.referTo = parsed;\n        }\n\n        break;\n\n      default:\n        // Do not parse this header.\n        message.addHeader(headerName.toLowerCase(), headerValue);\n        parsed = 0;\n    }\n\n    if (parsed === undefined) {\n      return {\n        error: \"error parsing header '\" + headerName + \"'\"\n      };\n    } else {\n      return true;\n    }\n  }\n\n  Parser.parseHeader = parseHeader;\n\n  function parseMessage(data, logger) {\n    let headerStart = 0;\n    let headerEnd = data.indexOf(\"\\r\\n\");\n\n    if (headerEnd === -1) {\n      logger.warn(\"no CRLF found, not a SIP message, discarded\");\n      return;\n    } // Parse first line. Check if it is a Request or a Reply.\n\n\n    const firstLine = data.substring(0, headerEnd);\n    const parsed = Grammar.parse(firstLine, \"Request_Response\");\n    let message;\n\n    if (parsed === -1) {\n      logger.warn('error parsing first line of SIP message: \"' + firstLine + '\"');\n      return;\n    } else if (!parsed.status_code) {\n      message = new IncomingRequestMessage();\n      message.method = parsed.method;\n      message.ruri = parsed.uri;\n    } else {\n      message = new IncomingResponseMessage();\n      message.statusCode = parsed.status_code;\n      message.reasonPhrase = parsed.reason_phrase;\n    }\n\n    message.data = data;\n    headerStart = headerEnd + 2; // Loop over every line in data. Detect the end of each header and parse\n    // it or simply add to the headers collection.\n\n    let bodyStart; // eslint-disable-next-line no-constant-condition\n\n    while (true) {\n      headerEnd = getHeader(data, headerStart); // The SIP message has normally finished.\n\n      if (headerEnd === -2) {\n        bodyStart = headerStart + 2;\n        break;\n      } else if (headerEnd === -1) {\n        // data.indexOf returned -1 due to a malformed message.\n        logger.error(\"malformed message\");\n        return;\n      }\n\n      const parsedHeader = parseHeader(message, data, headerStart, headerEnd);\n\n      if (parsedHeader && parsedHeader !== true) {\n        logger.error(parsedHeader.error);\n        return;\n      }\n\n      headerStart = headerEnd + 2;\n    } // RFC3261 18.3.\n    // If there are additional bytes in the transport packet\n    // beyond the end of the body, they MUST be discarded.\n\n\n    if (message.hasHeader(\"content-length\")) {\n      message.body = data.substr(bodyStart, Number(message.getHeader(\"content-length\")));\n    } else {\n      message.body = data.substring(bodyStart);\n    }\n\n    return message;\n  }\n\n  Parser.parseMessage = parseMessage;\n})(Parser = Parser || (Parser = {}));","map":null,"metadata":{},"sourceType":"module"}