{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar WebSocket = require(\"ws\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\"); // tslint:disable-next-line\n\n\nvar Backoff = require('backoff');\n\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\n/**\n * All possible states of WSTransport.\n */\n\nvar WSTransportState;\n\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\n\n\nvar WSTransport =\n/** @class */\nfunction (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n\n\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n\n\n    _this.state = WSTransportState.Closed;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n\n\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason); // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n\n\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n\n        var wasConnected = // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open || // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open; // Only fallback if this is not the first error\n        // and if we were not connected previously\n\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n\n        _this._shouldFallback = true;\n      }\n\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n\n\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n\n\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout(); // Filter and respond to heartbeats\n\n\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n\n        return;\n      }\n\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n\n\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n\n      _this._setState(WSTransportState.Open);\n\n      clearTimeout(_this._connectTimeout);\n\n      _this._setHeartbeatTimeout();\n\n      _this.emit('open');\n    };\n\n    _this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n    var initialDelay = 100;\n\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    var backoffConfig = {\n      factor: 2.0,\n      initialDelay: initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number' ? Math.max(options.backoffMaxMs, 3000) : 20000,\n      randomisationFactor: 0.40\n    };\n\n    _this._log.info('Initializing transport backoff using config: ', backoffConfig);\n\n    _this._backoff = Backoff.exponential(backoffConfig);\n    _this._uris = uris;\n    _this._WebSocket = options.WebSocket || WebSocket; // Called when a backoff timer is started.\n\n    _this._backoff.on('backoff', function (_, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n    }); // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n\n\n    _this._backoff.on('ready', function (attempt) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._connect(attempt + 1);\n    });\n\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n\n\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n\n      return;\n    }\n\n    this._connect();\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n\n\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n\n      this._closeSocket();\n\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n\n\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose);\n\n    this._socket.removeEventListener('error', this._onSocketError);\n\n    this._socket.removeEventListener('message', this._onSocketMessage);\n\n    this._socket.removeEventListener('open', this._onSocketOpen);\n\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    } // Reset backoff counter if connection was open for long enough to be considered successful\n\n\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n\n\n  WSTransport.prototype._connect = function (retryCount) {\n    var _this = this;\n\n    if (retryCount) {\n      this._log.info(\"Attempting to reconnect (retry #\" + retryCount + \")...\");\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n\n    var socket = null;\n\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n\n      this._close();\n\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._uris[this._uriIndex],\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n\n      _this._moveUriIndex();\n\n      _this._closeSocket();\n    }, this._connectTimeoutMs);\n    socket.addEventListener('close', this._onSocketClose);\n    socket.addEventListener('error', this._onSocketError);\n    socket.addEventListener('message', this._onSocketMessage);\n    socket.addEventListener('open', this._onSocketOpen);\n    this._socket = socket;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n\n\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n\n      _this._shouldFallback = true;\n\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n\n\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._uris[this._uriIndex];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return WSTransport;\n}(events_1.EventEmitter);\n\nexports.default = WSTransport; //# sourceMappingURL=wstransport.js.map","map":null,"metadata":{},"sourceType":"script"}