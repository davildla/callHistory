{"ast":null,"code":"import { Timers } from \"../timers.js\";\nimport { ServerTransaction } from \"./server-transaction.js\";\nimport { TransactionState } from \"./transaction-state.js\";\n/**\n * Non-INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.2\n * @public\n */\n\nexport class NonInviteServerTransaction extends ServerTransaction {\n  /**\n   * Constructor.\n   * After construction the transaction will be in the \"trying\": state and the transaction\n   * `id` will equal the branch parameter set in the Via header of the incoming request.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.2\n   * @param request - Incoming Non-INVITE request from the transport.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Trying, \"sip.transaction.nist\");\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    if (this.J) {\n      clearTimeout(this.J);\n      this.J = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"nist\";\n  }\n  /**\n   * Receive requests from transport matching this transaction.\n   * @param request - Request matching this transaction.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  receiveRequest(request) {\n    switch (this.state) {\n      case TransactionState.Trying:\n        // Once in the \"Trying\" state, any further request retransmissions are discarded.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        break;\n\n      case TransactionState.Proceeding:\n        // If a retransmission of the request is received while in the \"Proceeding\" state,\n        // the most recently sent provisional response MUST be passed to the transport layer for retransmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        if (!this.lastResponse) {\n          throw new Error(\"Last response undefined.\");\n        }\n\n        this.send(this.lastResponse).catch(error => {\n          this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n        });\n        break;\n\n      case TransactionState.Completed:\n        // While in the \"Completed\" state, the server transaction MUST pass the final response to the transport\n        // layer for retransmission whenever a retransmission of the request is received. Any other final responses\n        // passed by the TU to the server transaction MUST be discarded while in the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        if (!this.lastResponse) {\n          throw new Error(\"Last response undefined.\");\n        }\n\n        this.send(this.lastResponse).catch(error => {\n          this.logTransportError(error, \"Failed to send retransmission of final response.\");\n        });\n        break;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n  }\n  /**\n   * Receive responses from TU for this transaction.\n   * @param statusCode - Status code of response. 101-199 not allowed per RFC 4320.\n   * @param response - Response to send.\n   */\n\n\n  receiveResponse(statusCode, response) {\n    if (statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    } // An SIP element MUST NOT send any provisional response with a\n    // Status-Code other than 100 to a non-INVITE request.\n    // An SIP element MUST NOT respond to a non-INVITE request with a\n    // Status-Code of 100 over any unreliable transport, such as UDP,\n    // before the amount of time it takes a client transaction's Timer E to be reset to T2.\n    // An SIP element MAY respond to a non-INVITE request with a\n    // Status-Code of 100 over a reliable transport at any time.\n    // https://tools.ietf.org/html/rfc4320#section-4.1\n\n\n    if (statusCode > 100 && statusCode <= 199) {\n      throw new Error(\"Provisional response other than 100 not allowed.\");\n    }\n\n    switch (this.state) {\n      case TransactionState.Trying:\n        // While in the \"Trying\" state, if the TU passes a provisional response\n        // to the server transaction, the server transaction MUST enter the \"Proceeding\" state.\n        // The response MUST be passed to the transport layer for transmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        this.lastResponse = response;\n\n        if (statusCode >= 100 && statusCode < 200) {\n          this.stateTransition(TransactionState.Proceeding);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send provisional response.\");\n          });\n          return;\n        }\n\n        if (statusCode >= 200 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send final response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Proceeding:\n        // Any further provisional responses that are received from the TU while\n        // in the \"Proceeding\" state MUST be passed to the transport layer for transmission.\n        // If the TU passes a final response (status codes 200-699) to the server while in\n        // the \"Proceeding\" state, the transaction MUST enter the \"Completed\" state, and\n        // the response MUST be passed to the transport layer for transmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        this.lastResponse = response;\n\n        if (statusCode >= 200 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send final response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // Any other final responses passed by the TU to the server\n        // transaction MUST be discarded while in the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.2\n        return;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `Non-INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;\n    this.logger.error(message);\n    throw new Error(message);\n  }\n  /**\n   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n   * inform the TU that a failure has occurred, and SHOULD transition to the terminated state.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.4\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n\n    this.stateTransition(TransactionState.Terminated, true);\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"non-INVITE server transaction\";\n  }\n\n  stateTransition(newState) {\n    let dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Trying:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Proceeding:\n        if (this.state !== TransactionState.Trying) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {\n          if (!dueToTransportError) {\n            invalidStateTransition();\n          }\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // When the server transaction enters the \"Completed\" state, it MUST set Timer J to fire\n    // in 64*T1 seconds for unreliable transports, and zero seconds for reliable transports.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.2\n\n\n    if (newState === TransactionState.Completed) {\n      this.J = setTimeout(() => this.timerJ(), Timers.TIMER_J);\n    } // The server transaction MUST be destroyed the instant it enters the \"Terminated\" state.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.2\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    }\n\n    this.setState(newState);\n  }\n  /**\n   * The server transaction remains in this state until Timer J fires,\n   * at which point it MUST transition to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.2\n   */\n\n\n  timerJ() {\n    this.logger.debug(`Timer J expired for NON-INVITE server transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Completed) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}