{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\n\nvar events_1 = require(\"events\");\n\nvar device_1 = require(\"./device\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar icecandidate_1 = require(\"./rtc/icecandidate\");\n\nvar statsMonitor_1 = require(\"./statsMonitor\");\n\nvar util_1 = require(\"./util\");\n\nvar Backoff = require('backoff');\n\nvar C = require('./constants');\n\nvar PeerConnection = require('./rtc').PeerConnection;\n\nvar getPreferredCodecInfo = require('./rtc/sdp').getPreferredCodecInfo;\n\nvar BACKOFF_CONFIG = {\n  factor: 1.1,\n  initialDelay: 1,\n  maxDelay: 30000,\n  randomisationFactor: 0.5\n};\nvar DTMF_INTER_TONE_GAP = 70;\nvar DTMF_PAUSE_DURATION = 500;\nvar DTMF_TONE_DURATION = 160;\nvar METRICS_BATCH_SIZE = 10;\nvar METRICS_DELAY = 5000;\nvar MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new errors_1.MediaErrors.ConnectionError()\n  }\n};\nvar MULTIPLE_THRESHOLD_WARNING_NAMES = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction'\n  }\n};\nvar WARNING_NAMES = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt'\n};\nvar WARNING_PREFIXES = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-'\n};\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\n\nvar Call =\n/** @class */\nfunction (_super) {\n  __extends(Call, _super);\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n\n\n  function Call(config, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * Call parameters received from Twilio for an incoming call.\n     */\n\n\n    _this.parameters = {};\n    /**\n     * The number of times input volume has been the same consecutively.\n     */\n\n    _this._inputVolumeStreak = 0;\n    /**\n     * Whether the call has been answered.\n     */\n\n    _this._isAnswered = false;\n    /**\n     * Whether the call has been cancelled.\n     */\n\n    _this._isCancelled = false;\n    /**\n     * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n\n    _this._latestInputVolume = 0;\n    /**\n     * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n     */\n\n    _this._latestOutputVolume = 0;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * State of the {@link Call}'s media.\n     */\n\n    _this._mediaStatus = Call.State.Pending;\n    /**\n     * A batch of metrics samples to send to Insights. Gets cleared after\n     * each send and appended to on each new sample.\n     */\n\n    _this._metricsSamples = [];\n    /**\n     * Options passed to this {@link Call}.\n     */\n\n    _this._options = {\n      MediaHandler: PeerConnection,\n      offerSdp: null,\n      shouldPlayDisconnect: function () {\n        return true;\n      }\n    };\n    /**\n     * The number of times output volume has been the same consecutively.\n     */\n\n    _this._outputVolumeStreak = 0;\n    /**\n     * Whether the {@link Call} should send a hangup on disconnect.\n     */\n\n    _this._shouldSendHangup = true;\n    /**\n     * State of the {@link Call}'s signaling.\n     */\n\n    _this._signalingStatus = Call.State.Pending;\n    /**\n     * A Map of Sounds to play.\n     */\n\n    _this._soundcache = new Map();\n    /**\n     * State of the {@link Call}.\n     */\n\n    _this._status = Call.State.Pending;\n    /**\n     * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n     */\n\n    _this._wasConnected = false;\n    /**\n     * String representation of {@link Call} instance.\n     * @private\n     */\n\n    _this.toString = function () {\n      return '[Twilio.Call instance]';\n    };\n\n    _this._emitWarning = function (groupPrefix, warningName, threshold, value, wasCleared, warningData) {\n      var groupSuffix = wasCleared ? '-cleared' : '-raised';\n      var groupName = groupPrefix + \"warning\" + groupSuffix; // Ignore constant input if the Call is muted (Expected)\n\n      if (warningName === 'constant-audio-input-level' && _this.isMuted()) {\n        return;\n      }\n\n      var level = wasCleared ? 'info' : 'warning'; // Avoid throwing false positives as warnings until we refactor volume metrics\n\n      if (warningName === 'constant-audio-output-level') {\n        level = 'info';\n      }\n\n      var payloadData = {\n        threshold: threshold\n      };\n\n      if (value) {\n        if (value instanceof Array) {\n          payloadData.values = value.map(function (val) {\n            if (typeof val === 'number') {\n              return Math.round(val * 100) / 100;\n            }\n\n            return value;\n          });\n        } else {\n          payloadData.value = value;\n        }\n      }\n\n      _this._publisher.post(level, groupName, warningName, {\n        data: payloadData\n      }, _this);\n\n      if (warningName !== 'constant-audio-output-level') {\n        var emitName = wasCleared ? 'warning-cleared' : 'warning';\n\n        _this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n      }\n    };\n    /**\n     * Called when the {@link Call} is answered.\n     * @param payload\n     */\n\n\n    _this._onAnswer = function (payload) {\n      if (typeof payload.reconnect === 'string') {\n        _this._signalingReconnectToken = payload.reconnect;\n      } // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n      // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n      // the callee accepts the call firing a second `accept` event if we don't\n      // short circuit here.\n\n\n      if (_this._isAnswered && _this._status !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._setCallSid(payload);\n\n      _this._isAnswered = true;\n\n      _this._maybeTransitionToOpen();\n    };\n    /**\n     * Called when the {@link Call} is cancelled.\n     * @param payload\n     */\n\n\n    _this._onCancel = function (payload) {\n      // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n      var callsid = payload.callsid;\n\n      if (_this.parameters.CallSid === callsid) {\n        _this._isCancelled = true;\n\n        _this._publisher.info('connection', 'cancel', null, _this);\n\n        _this._cleanupEventListeners();\n\n        _this._mediaHandler.close();\n\n        _this._status = Call.State.Closed;\n\n        _this.emit('cancel');\n\n        _this._pstream.removeListener('cancel', _this._onCancel);\n      }\n    };\n    /**\n     * Called when we receive a connected event from pstream.\n     * Re-emits the event.\n     */\n\n\n    _this._onConnected = function () {\n      _this._log.info('Received connected from pstream');\n\n      if (_this._signalingReconnectToken) {\n        _this._pstream.reconnect(_this._mediaHandler.version.getSDP(), _this.parameters.CallSid, _this._signalingReconnectToken);\n      }\n    };\n    /**\n     * Called when the {@link Call} is hung up.\n     * @param payload\n     */\n\n\n    _this._onHangup = function (payload) {\n      if (_this.status() === Call.State.Closed) {\n        return;\n      }\n      /**\n       *  see if callsid passed in message matches either callsid or outbound id\n       *  call should always have either callsid or outbound id\n       *  if no callsid passed hangup anyways\n       */\n\n\n      if (payload.callsid && (_this.parameters.CallSid || _this.outboundConnectionId)) {\n        if (payload.callsid !== _this.parameters.CallSid && payload.callsid !== _this.outboundConnectionId) {\n          return;\n        }\n      } else if (payload.callsid) {\n        // hangup is for another call\n        return;\n      }\n\n      _this._log.info('Received HANGUP from gateway');\n\n      if (payload.error) {\n        var error = new errors_1.GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n\n        _this._log.error('Received an error from the gateway:', error);\n\n        _this.emit('error', error);\n      }\n\n      _this._shouldSendHangup = false;\n\n      _this._publisher.info('connection', 'disconnected-by-remote', null, _this);\n\n      _this._disconnect(null, true);\n\n      _this._cleanupEventListeners();\n    };\n    /**\n     * Called when there is a media failure.\n     * Manages all media-related states and takes action base on the states\n     * @param type - Type of media failure\n     */\n\n\n    _this._onMediaFailure = function (type) {\n      var _a = Call.MediaFailure,\n          ConnectionDisconnected = _a.ConnectionDisconnected,\n          ConnectionFailed = _a.ConnectionFailed,\n          IceGatheringFailed = _a.IceGatheringFailed,\n          LowBytes = _a.LowBytes; // These types signifies the end of a single ICE cycle\n\n      var isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed; // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n      // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n      // Since we cannot detect if ICE Restart is complete, we will not retry.\n\n      if (!util_1.isChrome(window, window.navigator) && type === ConnectionFailed) {\n        return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n      } // Ignore subsequent requests if ice restart is in progress\n\n\n      if (_this._mediaStatus === Call.State.Reconnecting) {\n        // This is a retry. Previous ICE Restart failed\n        if (isEndOfIceCycle) {\n          // We already exceeded max retry time.\n          if (Date.now() - _this._mediaReconnectStartTime > BACKOFF_CONFIG.maxDelay) {\n            _this._log.info('Exceeded max ICE retries');\n\n            return _this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n          } // Issue ICE restart with backoff\n\n\n          try {\n            _this._mediaReconnectBackoff.backoff();\n          } catch (error) {\n            // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n            // ongoing and we try to start another one, there shouldn't be a\n            // problem.\n            if (!(error.message && error.message === 'Backoff in progress.')) {\n              throw error;\n            }\n          }\n        }\n\n        return;\n      }\n\n      var pc = _this._mediaHandler.version.pc;\n      var isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n\n      var hasLowBytesWarning = _this._monitor.hasActiveWarning('bytesSent', 'min') || _this._monitor.hasActiveWarning('bytesReceived', 'min'); // Only certain conditions can trigger media reconnection\n\n\n      if (type === LowBytes && isIceDisconnected || type === ConnectionDisconnected && hasLowBytesWarning || isEndOfIceCycle) {\n        var mediaReconnectionError = new errors_1.MediaErrors.ConnectionError('Media connection failed.');\n\n        _this._log.warn('ICE Connection disconnected.');\n\n        _this._publisher.warn('connection', 'error', mediaReconnectionError, _this);\n\n        _this._publisher.info('connection', 'reconnecting', null, _this);\n\n        _this._mediaReconnectStartTime = Date.now();\n        _this._status = Call.State.Reconnecting;\n        _this._mediaStatus = Call.State.Reconnecting;\n\n        _this._mediaReconnectBackoff.reset();\n\n        _this._mediaReconnectBackoff.backoff();\n\n        _this.emit('reconnecting', mediaReconnectionError);\n      }\n    };\n    /**\n     * Called when media call is restored\n     */\n\n\n    _this._onMediaReconnected = function () {\n      // Only trigger once.\n      // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n      if (_this._mediaStatus !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._log.info('ICE Connection reestablished.');\n\n      _this._mediaStatus = Call.State.Open;\n\n      if (_this._signalingStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n\n        _this.emit('reconnected');\n\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * When we get a RINGING signal from PStream, update the {@link Call} status.\n     * @param payload\n     */\n\n\n    _this._onRinging = function (payload) {\n      _this._setCallSid(payload); // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n\n\n      if (_this._status !== Call.State.Connecting && _this._status !== Call.State.Ringing) {\n        return;\n      }\n\n      var hasEarlyMedia = !!payload.sdp;\n      _this._status = Call.State.Ringing;\n\n      _this._publisher.info('connection', 'outgoing-ringing', {\n        hasEarlyMedia: hasEarlyMedia\n      }, _this);\n\n      _this.emit('ringing', hasEarlyMedia);\n    };\n    /**\n     * Called each time StatsMonitor emits a sample.\n     * Emits stats event and batches the call stats metrics and sends them to Insights.\n     * @param sample\n     */\n\n\n    _this._onRTCSample = function (sample) {\n      var callMetrics = __assign(__assign({}, sample), {\n        inputVolume: _this._latestInputVolume,\n        outputVolume: _this._latestOutputVolume\n      });\n\n      _this._codec = callMetrics.codecName;\n\n      _this._metricsSamples.push(callMetrics);\n\n      if (_this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n        _this._publishMetrics();\n      }\n\n      _this.emit('sample', sample);\n    };\n    /**\n     * Called when signaling is restored\n     */\n\n\n    _this._onSignalingReconnected = function () {\n      if (_this._signalingStatus !== Call.State.Reconnecting) {\n        return;\n      }\n\n      _this._log.info('Signaling Connection reestablished.');\n\n      _this._signalingStatus = Call.State.Open;\n\n      if (_this._mediaStatus === Call.State.Open) {\n        _this._publisher.info('connection', 'reconnected', null, _this);\n\n        _this.emit('reconnected');\n\n        _this._status = Call.State.Open;\n      }\n    };\n    /**\n     * Called when we receive a transportClose event from pstream.\n     * Re-emits the event.\n     */\n\n\n    _this._onTransportClose = function () {\n      _this._log.error('Received transportClose from pstream');\n\n      _this.emit('transportClose');\n\n      if (_this._signalingReconnectToken) {\n        _this._status = Call.State.Reconnecting;\n        _this._signalingStatus = Call.State.Reconnecting;\n\n        _this.emit('reconnecting', new errors_1.SignalingErrors.ConnectionDisconnected());\n      } else {\n        _this._status = Call.State.Closed;\n        _this._signalingStatus = Call.State.Closed;\n      }\n    };\n    /**\n     * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n     * @param warningData\n     * @param wasCleared - Whether this is a -cleared or -raised event.\n     */\n\n\n    _this._reemitWarning = function (warningData, wasCleared) {\n      var groupPrefix = /^audio/.test(warningData.name) ? 'audio-level-' : 'network-quality-';\n      var warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n      /**\n       * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n       * `high-packets-lost-fraction`, so in this case we need to use a different\n       * `WARNING_NAME` mapping.\n       */\n\n      var warningName;\n\n      if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n        warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n      } else if (warningData.name in WARNING_NAMES) {\n        warningName = WARNING_NAMES[warningData.name];\n      }\n\n      var warning = warningPrefix + warningName;\n\n      _this._emitWarning(groupPrefix, warning, warningData.threshold.value, warningData.values || warningData.value, wasCleared, warningData);\n    };\n    /**\n     * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n     * @param warningData\n     */\n\n\n    _this._reemitWarningCleared = function (warningData) {\n      _this._reemitWarning(warningData, true);\n    };\n\n    _this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    _this._soundcache = config.soundcache;\n\n    if (typeof config.onIgnore === 'function') {\n      _this._onIgnore = config.onIgnore;\n    }\n\n    var message = options && options.twimlParams || {};\n    _this.customParameters = new Map(Object.entries(message).map(function (_a) {\n      var key = _a[0],\n          val = _a[1];\n      return [key, String(val)];\n    }));\n    Object.assign(_this._options, options);\n\n    if (_this._options.callParameters) {\n      _this.parameters = _this._options.callParameters;\n    }\n\n    if (_this._options.reconnectToken) {\n      _this._signalingReconnectToken = _this._options.reconnectToken;\n    }\n\n    _this._direction = _this.parameters.CallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n\n    if (_this._direction === Call.CallDirection.Incoming && _this.parameters) {\n      _this.callerInfo = _this.parameters.StirStatus ? {\n        isVerified: _this.parameters.StirStatus === 'TN-Validation-Passed-A'\n      } : null;\n    } else {\n      _this.callerInfo = null;\n    }\n\n    _this._mediaReconnectBackoff = Backoff.exponential(BACKOFF_CONFIG);\n\n    _this._mediaReconnectBackoff.on('ready', function () {\n      return _this._mediaHandler.iceRestart();\n    }); // temporary call sid to be used for outgoing calls\n\n\n    _this.outboundConnectionId = generateTempCallSid();\n    var publisher = _this._publisher = config.publisher;\n\n    if (_this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, _this);\n    } else {\n      publisher.info('connection', 'outgoing', {\n        preflight: _this._options.preflight\n      }, _this);\n    }\n\n    var monitor = _this._monitor = new (_this._options.StatsMonitor || statsMonitor_1.default)();\n    monitor.on('sample', _this._onRTCSample); // First 20 seconds or so are choppy, so let's not bother with these warnings.\n\n    monitor.disableWarnings();\n    setTimeout(function () {\n      return monitor.enableWarnings();\n    }, METRICS_DELAY);\n    monitor.on('warning', function (data, wasCleared) {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        _this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n\n      _this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', function (data) {\n      _this._reemitWarningCleared(data);\n    });\n    _this._mediaHandler = new _this._options.MediaHandler(config.audioHelper, config.pstream, config.getUserMedia, {\n      codecPreferences: _this._options.codecPreferences,\n      dscp: _this._options.dscp,\n      forceAggressiveIceNomination: _this._options.forceAggressiveIceNomination,\n      isUnifiedPlan: _this._isUnifiedPlanDefault,\n      maxAverageBitrate: _this._options.maxAverageBitrate,\n      preflight: _this._options.preflight\n    });\n\n    _this.on('volume', function (inputVolume, outputVolume) {\n      _this._inputVolumeStreak = _this._checkVolume(inputVolume, _this._inputVolumeStreak, _this._latestInputVolume, 'input');\n      _this._outputVolumeStreak = _this._checkVolume(outputVolume, _this._outputVolumeStreak, _this._latestOutputVolume, 'output');\n      _this._latestInputVolume = inputVolume;\n      _this._latestOutputVolume = outputVolume;\n    });\n\n    _this._mediaHandler.onvolume = function (inputVolume, outputVolume, internalInputVolume, internalOutputVolume) {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes(internalInputVolume / 255 * 32767, internalOutputVolume / 255 * 32767); // (rrowland) 0.0 -> 1.0 linear\n\n      _this.emit('volume', inputVolume, outputVolume);\n    };\n\n    _this._mediaHandler.ondtlstransportstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n\n      _this._publisher.post(level, 'dtls-transport-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onpcconnectionstatechange = function (state) {\n      var level = 'debug';\n\n      var dtlsTransport = _this._mediaHandler.getRTCDtlsTransport();\n\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n\n      _this._publisher.post(level, 'pc-connection-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onicecandidate = function (candidate) {\n      var payload = new icecandidate_1.IceCandidate(candidate).toPayload();\n\n      _this._publisher.debug('ice-candidate', 'ice-candidate', payload, _this);\n    };\n\n    _this._mediaHandler.onselectedcandidatepairchange = function (pair) {\n      var localCandidatePayload = new icecandidate_1.IceCandidate(pair.local).toPayload();\n      var remoteCandidatePayload = new icecandidate_1.IceCandidate(pair.remote, true).toPayload();\n\n      _this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload\n      }, _this);\n    };\n\n    _this._mediaHandler.oniceconnectionstatechange = function (state) {\n      var level = state === 'failed' ? 'error' : 'debug';\n\n      _this._publisher.post(level, 'ice-connection-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onicegatheringfailure = function (type) {\n      _this._publisher.warn('ice-gathering-state', type, null, _this);\n\n      _this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n\n    _this._mediaHandler.onicegatheringstatechange = function (state) {\n      _this._publisher.debug('ice-gathering-state', state, null, _this);\n    };\n\n    _this._mediaHandler.onsignalingstatechange = function (state) {\n      _this._publisher.debug('signaling-state', state, null, _this);\n    };\n\n    _this._mediaHandler.ondisconnected = function (msg) {\n      _this._log.info(msg);\n\n      _this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n\n      _this.emit('warning', 'ice-connectivity-lost');\n\n      _this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n\n    _this._mediaHandler.onfailed = function (msg) {\n      _this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n\n    _this._mediaHandler.onconnected = function () {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (_this._status === Call.State.Reconnecting) {\n        _this._onMediaReconnected();\n      }\n    };\n\n    _this._mediaHandler.onreconnected = function (msg) {\n      _this._log.info(msg);\n\n      _this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg\n      }, _this);\n\n      _this.emit('warning-cleared', 'ice-connectivity-lost');\n\n      _this._onMediaReconnected();\n    };\n\n    _this._mediaHandler.onerror = function (e) {\n      if (e.disconnect === true) {\n        _this._disconnect(e.info && e.info.message);\n      }\n\n      var error = e.info.twilioError || new errors_1.GeneralErrors.UnknownError(e.info.message);\n\n      _this._log.error('Received an error from MediaStream:', e);\n\n      _this.emit('error', error);\n    };\n\n    _this._mediaHandler.onopen = function () {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (_this._status === Call.State.Open || _this._status === Call.State.Reconnecting) {\n        return;\n      } else if (_this._status === Call.State.Ringing || _this._status === Call.State.Connecting) {\n        _this.mute(false);\n\n        _this._mediaStatus = Call.State.Open;\n\n        _this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        _this._mediaHandler.close();\n      }\n    };\n\n    _this._mediaHandler.onclose = function () {\n      _this._status = Call.State.Closed;\n\n      if (_this._options.shouldPlayDisconnect && _this._options.shouldPlayDisconnect() // Don't play disconnect sound if this was from a cancel event. i.e. the call\n      // was ignored or hung up even before it was answered.\n      && !_this._isCancelled) {\n        _this._soundcache.get(device_1.default.SoundName.Disconnect).play();\n      }\n\n      monitor.disable();\n\n      _this._publishMetrics();\n\n      if (!_this._isCancelled) {\n        // tslint:disable no-console\n        _this.emit('disconnect', _this);\n      }\n    };\n\n    _this._pstream = config.pstream;\n\n    _this._pstream.on('cancel', _this._onCancel);\n\n    _this._pstream.on('ringing', _this._onRinging);\n\n    _this._pstream.on('transportClose', _this._onTransportClose);\n\n    _this._pstream.on('connected', _this._onConnected);\n\n    _this.on('error', function (error) {\n      _this._publisher.error('connection', 'error', {\n        code: error.code,\n        message: error.message\n      }, _this);\n\n      if (_this._pstream && _this._pstream.status === 'disconnected') {\n        _this._cleanupEventListeners();\n      }\n    });\n\n    _this.on('disconnect', function () {\n      _this._cleanupEventListeners();\n    });\n\n    return _this;\n  }\n\n  Object.defineProperty(Call.prototype, \"direction\", {\n    /**\n     * Whether this {@link Call} is incoming or outgoing.\n     */\n    get: function () {\n      return this._direction;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Call.prototype, \"codec\", {\n    /**\n     * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n     * will copy whatever we get from RTC stats.\n     */\n    get: function () {\n      return this._codec;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n\n  Call.prototype._setInputTracksFromStream = function (stream) {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  };\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n\n\n  Call.prototype._setSinkIds = function (sinkIds) {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  };\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n\n\n  Call.prototype.accept = function (options) {\n    var _this = this;\n\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    options = options || {};\n    var rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    var rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || {};\n    var audioConstraints = rtcConstraints.audio || {\n      audio: true\n    };\n    this._status = Call.State.Connecting;\n\n    var connect = function () {\n      if (_this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        _this._cleanupEventListeners();\n\n        _this._mediaHandler.close();\n\n        return;\n      }\n\n      var onAnswer = function (pc, reconnectToken) {\n        // Report that the call was answered, and directionality\n        var eventName = _this._direction === Call.CallDirection.Incoming ? 'accepted-by-local' : 'accepted-by-remote';\n\n        _this._publisher.info('connection', eventName, null, _this);\n\n        if (typeof reconnectToken === 'string') {\n          _this._signalingReconnectToken = reconnectToken;\n        } // Report the preferred codec and params as they appear in the SDP\n\n\n        var _a = getPreferredCodecInfo(_this._mediaHandler.version.getSDP()),\n            codecName = _a.codecName,\n            codecParams = _a.codecParams;\n\n        _this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName\n        }, _this); // Enable RTC monitoring\n\n\n        _this._monitor.enable(pc);\n      };\n\n      var sinkIds = typeof _this._options.getSinkIds === 'function' && _this._options.getSinkIds();\n\n      if (Array.isArray(sinkIds)) {\n        _this._mediaHandler._setSinkIds(sinkIds).catch(function () {// (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n\n      _this._pstream.addListener('hangup', _this._onHangup);\n\n      if (_this._direction === Call.CallDirection.Incoming) {\n        _this._isAnswered = true;\n\n        _this._pstream.on('answer', _this._onAnswer.bind(_this));\n\n        _this._mediaHandler.answerIncomingCall(_this.parameters.CallSid, _this._options.offerSdp, rtcConstraints, rtcConfiguration, onAnswer);\n      } else {\n        var params = Array.from(_this.customParameters.entries()).map(function (pair) {\n          return encodeURIComponent(pair[0]) + \"=\" + encodeURIComponent(pair[1]);\n        }).join('&');\n\n        _this._pstream.on('answer', _this._onAnswer.bind(_this));\n\n        _this._mediaHandler.makeOutgoingCall(_this._pstream.token, params, _this.outboundConnectionId, rtcConstraints, rtcConfiguration, onAnswer);\n      }\n    };\n\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n\n    var inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n\n    var promise = inputStream ? this._mediaHandler.setInputTracksFromStream(inputStream) : this._mediaHandler.openWithConstraints(audioConstraints);\n    promise.then(function () {\n      _this._publisher.info('get-user-media', 'succeeded', {\n        data: {\n          audioConstraints: audioConstraints\n        }\n      }, _this);\n\n      connect();\n    }, function (error) {\n      var twilioError;\n\n      if (error.code === 31208 || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new errors_1.UserMediaErrors.PermissionDeniedError();\n\n        _this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      } else {\n        twilioError = new errors_1.UserMediaErrors.AcquisitionFailedError();\n\n        _this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints: audioConstraints,\n            error: error\n          }\n        }, _this);\n      }\n\n      _this._disconnect();\n\n      _this.emit('error', twilioError);\n    });\n  };\n  /**\n   * Disconnect from the {@link Call}.\n   */\n\n\n  Call.prototype.disconnect = function () {\n    this._disconnect();\n  };\n  /**\n   * Get the local MediaStream, if set.\n   */\n\n\n  Call.prototype.getLocalStream = function () {\n    return this._mediaHandler && this._mediaHandler.stream;\n  };\n  /**\n   * Get the remote MediaStream, if set.\n   */\n\n\n  Call.prototype.getRemoteStream = function () {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  };\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n\n\n  Call.prototype.ignore = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._status = Call.State.Closed;\n\n    this._mediaHandler.ignore(this.parameters.CallSid);\n\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  };\n  /**\n   * Check whether call is muted\n   */\n\n\n  Call.prototype.isMuted = function () {\n    return this._mediaHandler.isMuted;\n  };\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n\n\n  Call.prototype.mute = function (shouldMute) {\n    if (shouldMute === void 0) {\n      shouldMute = true;\n    }\n\n    var wasMuted = this._mediaHandler.isMuted;\n\n    this._mediaHandler.mute(shouldMute);\n\n    var isMuted = this._mediaHandler.isMuted;\n\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n\n      this.emit('mute', isMuted, this);\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n\n\n  Call.prototype.postFeedback = function (score, issue) {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback score must be one of: \" + Object.values(Call.FeedbackScore));\n    }\n\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new errors_1.InvalidArgumentError(\"Feedback issue must be one of: \" + Object.values(Call.FeedbackIssue));\n    }\n\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score\n    }, this, true);\n  };\n  /**\n   * Reject the incoming {@link Call}.\n   */\n\n\n  Call.prototype.reject = function () {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._pstream.reject(this.parameters.CallSid);\n\n    this._status = Call.State.Closed;\n    this.emit('reject');\n\n    this._mediaHandler.reject(this.parameters.CallSid);\n\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n  };\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n\n\n  Call.prototype.sendDigits = function (digits) {\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new errors_1.InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n\n    var sequence = [];\n    digits.split('').forEach(function (digit) {\n      var dtmf = digit !== 'w' ? \"dtmf\" + digit : '';\n\n      if (dtmf === 'dtmf*') {\n        dtmf = 'dtmfs';\n      }\n\n      if (dtmf === 'dtmf#') {\n        dtmf = 'dtmfh';\n      }\n\n      sequence.push(dtmf);\n    }); // Binds soundCache to be used in recursion until all digits have been played.\n\n    (function playNextDigit(soundCache, dialtonePlayer) {\n      var digit = sequence.shift();\n\n      if (digit) {\n        if (dialtonePlayer) {\n          dialtonePlayer.play(digit);\n        } else {\n          soundCache.get(digit).play();\n        }\n      }\n\n      if (sequence.length) {\n        setTimeout(playNextDigit.bind(null, soundCache), 200);\n      }\n    })(this._soundcache, this._options.dialtonePlayer);\n\n    var dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n\n    function insertDTMF(dtmfs) {\n      if (!dtmfs.length) {\n        return;\n      }\n\n      var dtmf = dtmfs.shift();\n\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender'); // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n\n\n        insertDTMF(digits.split('w'));\n        return;\n      }\n\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    } // send pstream message to send DTMF\n\n\n    this._log.info('Sending digits over PStream');\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      var error = new errors_1.GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this.emit('error', error);\n    }\n  };\n  /**\n   * Get the current {@link Call} status.\n   */\n\n\n  Call.prototype.status = function () {\n    return this._status;\n  };\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n\n\n  Call.prototype._checkVolume = function (currentVolume, currentStreak, lastValue, direction) {\n    var wasWarningRaised = currentStreak >= 10;\n    var newStreak = 0;\n\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', \"constant-audio-\" + direction + \"-level\", 10, newStreak, true);\n    }\n\n    return newStreak;\n  };\n  /**\n   * Clean up event listeners.\n   */\n\n\n  Call.prototype._cleanupEventListeners = function () {\n    var _this = this;\n\n    var cleanup = function () {\n      if (!_this._pstream) {\n        return;\n      }\n\n      _this._pstream.removeListener('answer', _this._onAnswer);\n\n      _this._pstream.removeListener('cancel', _this._onCancel);\n\n      _this._pstream.removeListener('hangup', _this._onHangup);\n\n      _this._pstream.removeListener('ringing', _this._onRinging);\n\n      _this._pstream.removeListener('transportClose', _this._onTransportClose);\n\n      _this._pstream.removeListener('connected', _this._onConnected);\n    }; // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n\n\n    cleanup();\n    setTimeout(cleanup, 0);\n  };\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n\n\n  Call.prototype._createMetricPayload = function () {\n    var payload = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: C.RELEASE_VERSION,\n      selected_region: this._options.selectedRegion\n    };\n\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n\n    if (this._options.region) {\n      payload.region = this._options.region;\n    }\n\n    payload.direction = this._direction;\n    return payload;\n  };\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n\n\n  Call.prototype._disconnect = function (message, wasRemote) {\n    message = typeof message === 'string' ? message : null;\n\n    if (this._status !== Call.State.Open && this._status !== Call.State.Connecting && this._status !== Call.State.Reconnecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    this._log.info('Disconnecting...'); // send pstream hangup message\n\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      var callsid = this.parameters.CallSid || this.outboundConnectionId;\n\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n\n    this._cleanupEventListeners();\n\n    this._mediaHandler.close();\n\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  };\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n\n\n  Call.prototype._maybeTransitionToOpen = function () {\n    var wasConnected = this._wasConnected;\n\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n\n      this._signalingStatus = Call.State.Open;\n\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this.emit('accept', this);\n        }\n      }\n    }\n  };\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n\n\n  Call.prototype._postFeedbackDeclined = function () {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  };\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n\n\n  Call.prototype._publishMetrics = function () {\n    var _this = this;\n\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n\n    this._publisher.postMetrics('quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this).catch(function (e) {\n      _this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  };\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n\n\n  Call.prototype._setCallSid = function (payload) {\n    var callSid = payload.callsid;\n\n    if (!callSid) {\n      return;\n    }\n\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  };\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n\n\n  Call.toString = function () {\n    return '[Twilio.Call class]';\n  };\n\n  return Call;\n}(events_1.EventEmitter);\n\n(function (Call) {\n  /**\n   * Possible states of the {@link Call}.\n   */\n  var State;\n\n  (function (State) {\n    State[\"Closed\"] = \"closed\";\n    State[\"Connecting\"] = \"connecting\";\n    State[\"Open\"] = \"open\";\n    State[\"Pending\"] = \"pending\";\n    State[\"Reconnecting\"] = \"reconnecting\";\n    State[\"Ringing\"] = \"ringing\";\n  })(State = Call.State || (Call.State = {}));\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n\n\n  var FeedbackIssue;\n\n  (function (FeedbackIssue) {\n    FeedbackIssue[\"AudioLatency\"] = \"audio-latency\";\n    FeedbackIssue[\"ChoppyAudio\"] = \"choppy-audio\";\n    FeedbackIssue[\"DroppedCall\"] = \"dropped-call\";\n    FeedbackIssue[\"Echo\"] = \"echo\";\n    FeedbackIssue[\"NoisyCall\"] = \"noisy-call\";\n    FeedbackIssue[\"OneWayAudio\"] = \"one-way-audio\";\n  })(FeedbackIssue = Call.FeedbackIssue || (Call.FeedbackIssue = {}));\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n\n\n  var FeedbackScore;\n\n  (function (FeedbackScore) {\n    FeedbackScore[FeedbackScore[\"One\"] = 1] = \"One\";\n    FeedbackScore[FeedbackScore[\"Two\"] = 2] = \"Two\";\n    FeedbackScore[FeedbackScore[\"Three\"] = 3] = \"Three\";\n    FeedbackScore[FeedbackScore[\"Four\"] = 4] = \"Four\";\n    FeedbackScore[FeedbackScore[\"Five\"] = 5] = \"Five\";\n  })(FeedbackScore = Call.FeedbackScore || (Call.FeedbackScore = {}));\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n\n\n  var CallDirection;\n\n  (function (CallDirection) {\n    CallDirection[\"Incoming\"] = \"INCOMING\";\n    CallDirection[\"Outgoing\"] = \"OUTGOING\";\n  })(CallDirection = Call.CallDirection || (Call.CallDirection = {}));\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n\n\n  var Codec;\n\n  (function (Codec) {\n    Codec[\"Opus\"] = \"opus\";\n    Codec[\"PCMU\"] = \"pcmu\";\n  })(Codec = Call.Codec || (Call.Codec = {}));\n  /**\n   * Possible ICE Gathering failures\n   */\n\n\n  var IceGatheringFailureReason;\n\n  (function (IceGatheringFailureReason) {\n    IceGatheringFailureReason[\"None\"] = \"none\";\n    IceGatheringFailureReason[\"Timeout\"] = \"timeout\";\n  })(IceGatheringFailureReason = Call.IceGatheringFailureReason || (Call.IceGatheringFailureReason = {}));\n  /**\n   * Possible media failures\n   */\n\n\n  var MediaFailure;\n\n  (function (MediaFailure) {\n    MediaFailure[\"ConnectionDisconnected\"] = \"ConnectionDisconnected\";\n    MediaFailure[\"ConnectionFailed\"] = \"ConnectionFailed\";\n    MediaFailure[\"IceGatheringFailed\"] = \"IceGatheringFailed\";\n    MediaFailure[\"LowBytes\"] = \"LowBytes\";\n  })(MediaFailure = Call.MediaFailure || (Call.MediaFailure = {}));\n})(Call || (Call = {}));\n\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {\n    /* tslint:disable:no-bitwise */\n    var r = Math.random() * 16 | 0;\n    var v = c === 'x' ? r : r & 0x3 | 0x8;\n    /* tslint:enable:no-bitwise */\n\n    return v.toString(16);\n  });\n}\n\nexports.default = Call;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AAMA;;AACA;;AAEA;;AAQA;;AACA;;AAGA;;AACA;;AAEA,IAAMA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMC,CAAC,GAAGD,OAAO,CAAC,aAAD,CAAjB;;AACQ;;AACA;;AAwBR,IAAME,cAAc,GAAG;EACrBC,MAAM,EAAE,GADa;EAErBC,YAAY,EAAE,CAFO;EAGrBC,QAAQ,EAAE,KAHW;EAIrBC,mBAAmB,EAAE;AAJA,CAAvB;AAOA,IAAMC,mBAAmB,GAAW,EAApC;AACA,IAAMC,mBAAmB,GAAW,GAApC;AACA,IAAMC,kBAAkB,GAAW,GAAnC;AAEA,IAAMC,kBAAkB,GAAW,EAAnC;AACA,IAAMC,aAAa,GAAW,IAA9B;AAEA,IAAMC,sBAAsB,GAAG;EAC7BC,UAAU,EAAE,IADiB;EAE7BC,IAAI,EAAE;IACJC,IAAI,EAAE,KADF;IAEJC,OAAO,EAAE,yCAFL;IAGJC,WAAW,EAAE,IAAIC,qBAAYC,eAAhB;EAHT;AAFuB,CAA/B;AASA,IAAMC,gCAAgC,GAA2C;EAC/E;EACA;EACAC,mBAAmB,EAAE;IACnBC,GAAG,EAAE,aADc;IAEnBC,UAAU,EAAE;EAFO;AAH0D,CAAjF;AASA,IAAMC,aAAa,GAA2B;EAC5CC,eAAe,EAAE,mBAD2B;EAE5CC,gBAAgB,EAAE,oBAF0B;EAG5CC,aAAa,EAAE,gBAH6B;EAI5CC,SAAS,EAAE,YAJiC;EAK5CC,MAAM,EAAE,QALoC;EAM5CC,GAAG,EAAE,KANuC;EAO5CC,GAAG,EAAE;AAPuC,CAA9C;AAUA,IAAMC,gBAAgB,GAA2B;EAC/CV,GAAG,EAAE,OAD0C;EAE/CC,UAAU,EAAE,OAFmC;EAG/CU,WAAW,EAAE,WAHkC;EAI/CC,GAAG,EAAE,MAJ0C;EAK/CC,oBAAoB,EAAE;AALyB,CAAjD;AAQA;;;;;AAIA;AAAA;AAAA;EAAmBC;EAoLjB;;;;;;;;EAMA,cAAYC,MAAZ,EAAiCC,OAAjC,EAAuD;IAAvD,YACEC,qBAAO,IADT;IApJA;;;;;IAGAC,mBAAqC,EAArC;IAaA;;;;IAGQA,2BAA6B,CAA7B;IAER;;;;IAGQA,oBAAuB,KAAvB;IAER;;;;IAGQA,qBAAwB,KAAxB;IAOR;;;;IAGQA,2BAA6B,CAA7B;IAER;;;;IAGQA,4BAA8B,CAA9B;IAER;;;;IAGQA,aAAYC,cAAIC,WAAJ,EAAZ;IAkBR;;;;IAGQF,qBAA2BG,IAAI,CAACC,KAAL,CAAWC,OAAtC;IAER;;;;;IAIiBL,wBAAsC,EAAtC;IAYjB;;;;IAGQA,iBAAyB;MAC/BM,YAAY,EAAEC,cADiB;MAE/BC,QAAQ,EAAE,IAFqB;MAG/BC,oBAAoB,EAAE;QAAM;MAAI;IAHD,CAAzB;IAMR;;;;IAGQT,4BAA8B,CAA9B;IAYR;;;;IAGQA,0BAA6B,IAA7B;IAOR;;;;IAGQA,yBAA+BG,IAAI,CAACC,KAAL,CAAWC,OAA1C;IAER;;;;IAGiBL,oBAA6C,IAAIU,GAAJ,EAA7C;IAEjB;;;;IAGQV,gBAAsBG,IAAI,CAACC,KAAL,CAAWC,OAAjC;IAER;;;;IAGQL,sBAAyB,KAAzB;IAwjBR;;;;;IAIAA,iBAAW;MAAM;IAAwB,CAAzC;;IAqHQA,qBAAe,UAACW,WAAD,EAAsBC,WAAtB,EAA2CC,SAA3C,EACCC,KADD,EACyBC,UADzB,EAC+CC,WAD/C,EACuE;MAC5F,IAAMC,WAAW,GAAGF,UAAU,GAAG,UAAH,GAAgB,SAA9C;MACA,IAAMG,SAAS,GAAMP,WAAW,YAAX,GAAqBM,WAA1C,CAF4F,CAI5F;;MACA,IAAIL,WAAW,KAAK,4BAAhB,IAAgDZ,KAAI,CAACmB,OAAL,EAApD,EAAoE;QAClE;MACD;;MAED,IAAIC,KAAK,GAAGL,UAAU,GAAG,MAAH,GAAY,SAAlC,CAT4F,CAW5F;;MACA,IAAIH,WAAW,KAAK,6BAApB,EAAmD;QACjDQ,KAAK,GAAG,MAAR;MACD;;MAED,IAAMC,WAAW,GAAwB;QAAER,SAAS;MAAX,CAAzC;;MAEA,IAAIC,KAAJ,EAAW;QACT,IAAIA,KAAK,YAAYQ,KAArB,EAA4B;UAC1BD,WAAW,CAACE,MAAZ,GAAqBT,KAAK,CAACU,GAAN,CAAU,UAACC,GAAD,EAAS;YACtC,IAAI,OAAOA,GAAP,KAAe,QAAnB,EAA6B;cAC3B,OAAOC,IAAI,CAACC,KAAL,CAAWF,GAAG,GAAG,GAAjB,IAAwB,GAA/B;YACD;;YAED,OAAOX,KAAP;UACD,CANoB,CAArB;QAOD,CARD,MAQO;UACLO,WAAW,CAACP,KAAZ,GAAoBA,KAApB;QACD;MACF;;MAEDd,KAAI,CAAC4B,UAAL,CAAgBC,IAAhB,CAAqBT,KAArB,EAA4BF,SAA5B,EAAuCN,WAAvC,EAAoD;QAAEkB,IAAI,EAAET;MAAR,CAApD,EAA2ErB,KAA3E;;MAEA,IAAIY,WAAW,KAAK,6BAApB,EAAmD;QACjD,IAAMmB,QAAQ,GAAGhB,UAAU,GAAG,iBAAH,GAAuB,SAAlD;;QACAf,KAAI,CAACgC,IAAL,CAAUD,QAAV,EAAoBnB,WAApB,EAAiCI,WAAW,IAAI,CAACD,UAAhB,GAA6BC,WAA7B,GAA2C,IAA5E;MACD;IACF,CAvCO;IA2DR;;;;;;IAIQhB,kBAAY,UAACiC,OAAD,EAA6B;MAC/C,IAAI,OAAOA,OAAO,CAACC,SAAf,KAA6B,QAAjC,EAA2C;QACzClC,KAAI,CAACmC,wBAAL,GAAgCF,OAAO,CAACC,SAAxC;MACD,CAH8C,CAK/C;MACA;MACA;MACA;;;MACA,IAAIlC,KAAI,CAACoC,WAAL,IAAoBpC,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWkC,YAApD,EAAkE;QAChE;MACD;;MAEDtC,KAAI,CAACuC,WAAL,CAAiBN,OAAjB;;MACAjC,KAAI,CAACoC,WAAL,GAAmB,IAAnB;;MACApC,KAAI,CAACwC,sBAAL;IACD,CAhBO;IAkBR;;;;;;IAIQxC,kBAAY,UAACiC,OAAD,EAA6B;MAC/C;MACA,IAAMQ,OAAO,GAAGR,OAAO,CAACQ,OAAxB;;MACA,IAAIzC,KAAI,CAAC0C,UAAL,CAAgBC,OAAhB,KAA4BF,OAAhC,EAAyC;QACvCzC,KAAI,CAAC4C,YAAL,GAAoB,IAApB;;QACA5C,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,QAAnC,EAA6C,IAA7C,EAAmD0B,KAAnD;;QACAA,KAAI,CAAC6C,sBAAL;;QACA7C,KAAI,CAAC8C,aAAL,CAAmBC,KAAnB;;QAEA/C,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAW4C,MAA1B;;QACAhD,KAAI,CAACgC,IAAL,CAAU,QAAV;;QACAhC,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,QAA7B,EAAuClD,KAAI,CAACmD,SAA5C;MACD;IACF,CAbO;IAeR;;;;;;IAIQnD,qBAAe;MACrBA,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAe,iCAAf;;MACA,IAAI0B,KAAI,CAACmC,wBAAT,EAAmC;QACjCnC,KAAI,CAACiD,QAAL,CAAcf,SAAd,CACElC,KAAI,CAAC8C,aAAL,CAAmBO,OAAnB,CAA2BC,MAA3B,EADF,EAEEtD,KAAI,CAAC0C,UAAL,CAAgBC,OAFlB,EAGE3C,KAAI,CAACmC,wBAHP;MAKD;IACF,CATO;IAWR;;;;;;IAIQnC,kBAAY,UAACiC,OAAD,EAA6B;MAC/C,IAAIjC,KAAI,CAACuD,MAAL,OAAkBpD,IAAI,CAACC,KAAL,CAAW4C,MAAjC,EAAyC;QACvC;MACD;MAED;;;;;;;MAKA,IAAIf,OAAO,CAACQ,OAAR,KAAoBzC,KAAI,CAAC0C,UAAL,CAAgBC,OAAhB,IAA2B3C,KAAI,CAACwD,oBAApD,CAAJ,EAA+E;QAC7E,IAAIvB,OAAO,CAACQ,OAAR,KAAoBzC,KAAI,CAAC0C,UAAL,CAAgBC,OAApC,IACGV,OAAO,CAACQ,OAAR,KAAoBzC,KAAI,CAACwD,oBADhC,EACsD;UACpD;QACD;MACF,CALD,MAKO,IAAIvB,OAAO,CAACQ,OAAZ,EAAqB;QAC1B;QACA;MACD;;MAEDzC,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAe,8BAAf;;MACA,IAAI2D,OAAO,CAACwB,KAAZ,EAAmB;QACjB,IAAMA,KAAK,GAAG,IAAI/E,uBAAcC,eAAlB,CAAkC,mCAAlC,CAAd;;QACAqB,KAAI,CAACoD,IAAL,CAAUK,KAAV,CAAgB,qCAAhB,EAAuDA,KAAvD;;QACAzD,KAAI,CAACgC,IAAL,CAAU,OAAV,EAAmByB,KAAnB;MACD;;MACDzD,KAAI,CAAC0D,iBAAL,GAAyB,KAAzB;;MACA1D,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,wBAAnC,EAA6D,IAA7D,EAAmE0B,KAAnE;;MACAA,KAAI,CAAC2D,WAAL,CAAiB,IAAjB,EAAuB,IAAvB;;MACA3D,KAAI,CAAC6C,sBAAL;IACD,CA9BO;IAgCR;;;;;;;IAKQ7C,wBAAkB,UAAC4D,IAAD,EAAwB;MAC1C;MAAA,IACJC,kDADI;MAAA,IACoBC,sCADpB;MAAA,IACsCC,0CADtC;MAAA,IAC0DC,sBAD1D,CAD0C,CAKhD;;MACA,IAAMC,eAAe,GAAGL,IAAI,KAAKE,gBAAT,IAA6BF,IAAI,KAAKG,kBAA9D,CANgD,CAQhD;MACA;MACA;;MACA,IAAI,CAACG,gBAASC,MAAT,EAAiBA,MAAM,CAACC,SAAxB,CAAD,IAAuCR,IAAI,KAAKE,gBAApD,EAAsE;QACpE,OAAO9D,KAAI,CAAC8C,aAAL,CAAmBuB,OAAnB,CAA2BjG,sBAA3B,CAAP;MACD,CAb+C,CAehD;;;MACA,IAAI4B,KAAI,CAACsE,YAAL,KAAsBnE,IAAI,CAACC,KAAL,CAAWkC,YAArC,EAAmD;QAEjD;QACA,IAAI2B,eAAJ,EAAqB;UAEnB;UACA,IAAIM,IAAI,CAACC,GAAL,KAAaxE,KAAI,CAACyE,wBAAlB,GAA6C/G,cAAc,CAACG,QAAhE,EAA0E;YACxEmC,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAe,0BAAf;;YACA,OAAO0B,KAAI,CAAC8C,aAAL,CAAmBuB,OAAnB,CAA2BjG,sBAA3B,CAAP;UACD,CANkB,CAQnB;;;UACA,IAAI;YACF4B,KAAI,CAAC0E,sBAAL,CAA4BC,OAA5B;UACD,CAFD,CAEE,OAAOlB,KAAP,EAAc;YACd;YACA;YACA;YACA,IAAI,EAAEA,KAAK,CAACjF,OAAN,IAAiBiF,KAAK,CAACjF,OAAN,KAAkB,sBAArC,CAAJ,EAAkE;cAChE,MAAMiF,KAAN;YACD;UACF;QACF;;QAED;MACD;;MAED,IAAMmB,EAAE,GAAG5E,KAAI,CAAC8C,aAAL,CAAmBO,OAAnB,CAA2BuB,EAAtC;MACA,IAAMC,iBAAiB,GAAGD,EAAE,IAAIA,EAAE,CAACE,kBAAH,KAA0B,cAA1D;;MACA,IAAMC,kBAAkB,GAAG/E,KAAI,CAACgF,QAAL,CAAcC,gBAAd,CAA+B,WAA/B,EAA4C,KAA5C,KACtBjF,KAAI,CAACgF,QAAL,CAAcC,gBAAd,CAA+B,eAA/B,EAAgD,KAAhD,CADL,CA7CgD,CAgDhD;;;MACA,IAAKrB,IAAI,KAAKI,QAAT,IAAqBa,iBAAtB,IACEjB,IAAI,KAAKC,sBAAT,IAAmCkB,kBADrC,IAECd,eAFL,EAEsB;QAEpB,IAAMiB,sBAAsB,GAAG,IAAIxG,qBAAYC,eAAhB,CAAgC,0BAAhC,CAA/B;;QACAqB,KAAI,CAACoD,IAAL,CAAU+B,IAAV,CAAe,8BAAf;;QACAnF,KAAI,CAAC4B,UAAL,CAAgBuD,IAAhB,CAAqB,YAArB,EAAmC,OAAnC,EAA4CD,sBAA5C,EAAoElF,KAApE;;QACAA,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,cAAnC,EAAmD,IAAnD,EAAyD0B,KAAzD;;QAEAA,KAAI,CAACyE,wBAAL,GAAgCF,IAAI,CAACC,GAAL,EAAhC;QACAxE,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWkC,YAA1B;QACAtC,KAAI,CAACsE,YAAL,GAAoBnE,IAAI,CAACC,KAAL,CAAWkC,YAA/B;;QACAtC,KAAI,CAAC0E,sBAAL,CAA4BU,KAA5B;;QACApF,KAAI,CAAC0E,sBAAL,CAA4BC,OAA5B;;QAEA3E,KAAI,CAACgC,IAAL,CAAU,cAAV,EAA0BkD,sBAA1B;MACD;IACF,CAlEO;IAoER;;;;;IAGQlF,4BAAsB;MAC5B;MACA;MACA,IAAIA,KAAI,CAACsE,YAAL,KAAsBnE,IAAI,CAACC,KAAL,CAAWkC,YAArC,EAAmD;QACjD;MACD;;MACDtC,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAe,+BAAf;;MACA0B,KAAI,CAACsE,YAAL,GAAoBnE,IAAI,CAACC,KAAL,CAAWiF,IAA/B;;MAEA,IAAIrF,KAAI,CAACsF,gBAAL,KAA0BnF,IAAI,CAACC,KAAL,CAAWiF,IAAzC,EAA+C;QAC7CrF,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,aAAnC,EAAkD,IAAlD,EAAwD0B,KAAxD;;QACAA,KAAI,CAACgC,IAAL,CAAU,aAAV;;QACAhC,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWiF,IAA1B;MACD;IACF,CAdO;IAgBR;;;;;;IAIQrF,mBAAa,UAACiC,OAAD,EAA6B;MAChDjC,KAAI,CAACuC,WAAL,CAAiBN,OAAjB,EADgD,CAGhD;;;MACA,IAAIjC,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWmF,UAA5B,IAA0CvF,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWoF,OAA1E,EAAmF;QACjF;MACD;;MAED,IAAMC,aAAa,GAAG,CAAC,CAACxD,OAAO,CAACyD,GAAhC;MACA1F,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWoF,OAA1B;;MACAxF,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,kBAAnC,EAAuD;QAAEmH,aAAa;MAAf,CAAvD,EAA0EzF,KAA1E;;MACAA,KAAI,CAACgC,IAAL,CAAU,SAAV,EAAqByD,aAArB;IACD,CAZO;IAcR;;;;;;;IAKQzF,qBAAe,UAAC2F,MAAD,EAAkB;MACvC,IAAMC,WAAW,yBACZD,MADY,GACN;QACTE,WAAW,EAAE7F,KAAI,CAAC8F,kBADT;QAETC,YAAY,EAAE/F,KAAI,CAACgG;MAFV,CADM,CAAjB;;MAMAhG,KAAI,CAACiG,MAAL,GAAcL,WAAW,CAACM,SAA1B;;MAEAlG,KAAI,CAACmG,eAAL,CAAqBC,IAArB,CAA0BR,WAA1B;;MACA,IAAI5F,KAAI,CAACmG,eAAL,CAAqBE,MAArB,IAA+BnI,kBAAnC,EAAuD;QACrD8B,KAAI,CAACsG,eAAL;MACD;;MAEDtG,KAAI,CAACgC,IAAL,CAAU,QAAV,EAAoB2D,MAApB;IACD,CAfO;IAiBR;;;;;IAGQ3F,gCAA0B;MAChC,IAAIA,KAAI,CAACsF,gBAAL,KAA0BnF,IAAI,CAACC,KAAL,CAAWkC,YAAzC,EAAuD;QACrD;MACD;;MACDtC,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAe,qCAAf;;MAEA0B,KAAI,CAACsF,gBAAL,GAAwBnF,IAAI,CAACC,KAAL,CAAWiF,IAAnC;;MAEA,IAAIrF,KAAI,CAACsE,YAAL,KAAsBnE,IAAI,CAACC,KAAL,CAAWiF,IAArC,EAA2C;QACzCrF,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,aAAnC,EAAkD,IAAlD,EAAwD0B,KAAxD;;QACAA,KAAI,CAACgC,IAAL,CAAU,aAAV;;QACAhC,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWiF,IAA1B;MACD;IACF,CAbO;IAeR;;;;;;IAIQrF,0BAAoB;MAC1BA,KAAI,CAACoD,IAAL,CAAUK,KAAV,CAAgB,sCAAhB;;MACAzD,KAAI,CAACgC,IAAL,CAAU,gBAAV;;MACA,IAAIhC,KAAI,CAACmC,wBAAT,EAAmC;QACjCnC,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWkC,YAA1B;QACAtC,KAAI,CAACsF,gBAAL,GAAwBnF,IAAI,CAACC,KAAL,CAAWkC,YAAnC;;QACAtC,KAAI,CAACgC,IAAL,CAAU,cAAV,EAA0B,IAAItD,yBAAgBmF,sBAApB,EAA1B;MACD,CAJD,MAIO;QACL7D,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAW4C,MAA1B;QACAhD,KAAI,CAACsF,gBAAL,GAAwBnF,IAAI,CAACC,KAAL,CAAW4C,MAAnC;MACD;IACF,CAXO;IAoCR;;;;;;;IAKQhD,uBAAiB,UAACgB,WAAD,EAAmCD,UAAnC,EAAuD;MAC9E,IAAMJ,WAAW,GAAG,SAAS4F,IAAT,CAAcvF,WAAW,CAACwF,IAA1B,IAClB,cADkB,GACD,kBADnB;MAGA,IAAMC,aAAa,GAAGjH,gBAAgB,CAACwB,WAAW,CAACH,SAAZ,CAAsB2F,IAAvB,CAAtC;MAEA;;;;;;MAKA,IAAI5F,WAAJ;;MACA,IAAII,WAAW,CAACwF,IAAZ,IAAoB5H,gCAAxB,EAA0D;QACxDgC,WAAW,GAAGhC,gCAAgC,CAACoC,WAAW,CAACwF,IAAb,CAAhC,CAAmDxF,WAAW,CAACH,SAAZ,CAAsB2F,IAAzE,CAAd;MACD,CAFD,MAEO,IAAIxF,WAAW,CAACwF,IAAZ,IAAoBxH,aAAxB,EAAuC;QAC5C4B,WAAW,GAAG5B,aAAa,CAACgC,WAAW,CAACwF,IAAb,CAA3B;MACD;;MAED,IAAME,OAAO,GAAWD,aAAa,GAAG7F,WAAxC;;MAEAZ,KAAI,CAAC2G,YAAL,CAAkBhG,WAAlB,EAA+B+F,OAA/B,EAAwC1F,WAAW,CAACH,SAAZ,CAAsBC,KAA9D,EACkBE,WAAW,CAACO,MAAZ,IAAsBP,WAAW,CAACF,KADpD,EAC2DC,UAD3D,EACuEC,WADvE;IAED,CAtBO;IAwBR;;;;;;IAIQhB,8BAAwB,UAACgB,WAAD,EAAiC;MAC/DhB,KAAI,CAAC4G,cAAL,CAAoB5F,WAApB,EAAiC,IAAjC;IACD,CAFO;;IA5hCNhB,KAAI,CAAC6G,qBAAL,GAA6BhH,MAAM,CAACiH,oBAApC;IACA9G,KAAI,CAAC+G,WAAL,GAAmBlH,MAAM,CAACmH,UAA1B;;IAEA,IAAI,OAAOnH,MAAM,CAACoH,QAAd,KAA2B,UAA/B,EAA2C;MACzCjH,KAAI,CAACkH,SAAL,GAAiBrH,MAAM,CAACoH,QAAxB;IACD;;IAED,IAAMzI,OAAO,GAAGsB,OAAO,IAAIA,OAAO,CAACqH,WAAnB,IAAkC,EAAlD;IACAnH,KAAI,CAACoH,gBAAL,GAAwB,IAAI1G,GAAJ,CACtB2G,MAAM,CAACC,OAAP,CAAe9I,OAAf,EAAwBgD,GAAxB,CAA4B,UAAC+F,EAAD,EAA0B;UAAxBC;UAAK/F;MAA0C,QAAC+F,GAAD,EAAMC,MAAM,CAAChG,GAAD,CAAZ;IAAkB,CAA/F,CADsB,CAAxB;IAGA4F,MAAM,CAACK,MAAP,CAAc1H,KAAI,CAAC2H,QAAnB,EAA6B7H,OAA7B;;IAEA,IAAIE,KAAI,CAAC2H,QAAL,CAAcC,cAAlB,EAAkC;MAChC5H,KAAI,CAAC0C,UAAL,GAAkB1C,KAAI,CAAC2H,QAAL,CAAcC,cAAhC;IACD;;IAED,IAAI5H,KAAI,CAAC2H,QAAL,CAAcE,cAAlB,EAAkC;MAChC7H,KAAI,CAACmC,wBAAL,GAAgCnC,KAAI,CAAC2H,QAAL,CAAcE,cAA9C;IACD;;IAED7H,KAAI,CAAC8H,UAAL,GAAkB9H,KAAI,CAAC0C,UAAL,CAAgBC,OAAhB,GAA0BxC,IAAI,CAAC4H,aAAL,CAAmBC,QAA7C,GAAwD7H,IAAI,CAAC4H,aAAL,CAAmBE,QAA7F;;IAEA,IAAIjI,KAAI,CAAC8H,UAAL,KAAoB3H,IAAI,CAAC4H,aAAL,CAAmBC,QAAvC,IAAmDhI,KAAI,CAAC0C,UAA5D,EAAwE;MACtE1C,KAAI,CAACkI,UAAL,GAAkBlI,KAAI,CAAC0C,UAAL,CAAgByF,UAAhB,GACd;QAAEC,UAAU,EAAEpI,KAAI,CAAC0C,UAAL,CAAgByF,UAAhB,KAA+B;MAA7C,CADc,GAEd,IAFJ;IAGD,CAJD,MAIO;MACLnI,KAAI,CAACkI,UAAL,GAAkB,IAAlB;IACD;;IAEDlI,KAAI,CAAC0E,sBAAL,GAA8BnH,OAAO,CAAC8K,WAAR,CAAoB3K,cAApB,CAA9B;;IACAsC,KAAI,CAAC0E,sBAAL,CAA4B4D,EAA5B,CAA+B,OAA/B,EAAwC;MAAM,YAAI,CAACxF,aAAL,CAAmByF,UAAnB;IAA+B,CAA7E,EAnCqD,CAqCrD;;;IACAvI,KAAI,CAACwD,oBAAL,GAA4BgF,mBAAmB,EAA/C;IAEA,IAAMC,SAAS,GAAGzI,KAAI,CAAC4B,UAAL,GAAkB/B,MAAM,CAAC4I,SAA3C;;IAEA,IAAIzI,KAAI,CAAC8H,UAAL,KAAoB3H,IAAI,CAAC4H,aAAL,CAAmBC,QAA3C,EAAqD;MACnDS,SAAS,CAACnK,IAAV,CAAe,YAAf,EAA6B,UAA7B,EAAyC,IAAzC,EAA+C0B,KAA/C;IACD,CAFD,MAEO;MACLyI,SAAS,CAACnK,IAAV,CAAe,YAAf,EAA6B,UAA7B,EAAyC;QAAEoK,SAAS,EAAE1I,KAAI,CAAC2H,QAAL,CAAce;MAA3B,CAAzC,EAAiF1I,KAAjF;IACD;;IAED,IAAM2I,OAAO,GAAG3I,KAAI,CAACgF,QAAL,GAAgB,KAAKhF,KAAI,CAAC2H,QAAL,CAAciB,YAAd,IAA8BC,sBAAnC,GAAhC;IACAF,OAAO,CAACL,EAAR,CAAW,QAAX,EAAqBtI,KAAI,CAAC8I,YAA1B,EAjDqD,CAmDrD;;IACAH,OAAO,CAACI,eAAR;IACAC,UAAU,CAAC;MAAM,cAAO,CAACC,cAAR;IAAwB,CAA/B,EAAiC9K,aAAjC,CAAV;IAEAwK,OAAO,CAACL,EAAR,CAAW,SAAX,EAAsB,UAACxG,IAAD,EAAmBf,UAAnB,EAAuC;MAC3D,IAAIe,IAAI,CAAC0E,IAAL,KAAc,WAAd,IAA6B1E,IAAI,CAAC0E,IAAL,KAAc,eAA/C,EAAgE;QAC9DxG,KAAI,CAACkJ,eAAL,CAAqB/I,IAAI,CAACgJ,YAAL,CAAkBnF,QAAvC;MACD;;MACDhE,KAAI,CAAC4G,cAAL,CAAoB9E,IAApB,EAA0Bf,UAA1B;IACD,CALD;IAMA4H,OAAO,CAACL,EAAR,CAAW,iBAAX,EAA8B,UAACxG,IAAD,EAAiB;MAC7C9B,KAAI,CAACoJ,qBAAL,CAA2BtH,IAA3B;IACD,CAFD;IAIA9B,KAAI,CAAC8C,aAAL,GAAqB,IAAK9C,KAAI,CAAC2H,QAAL,CAAcrH,YAAnB,CAClBT,MAAM,CAACwJ,WADW,EACExJ,MAAM,CAACyJ,OADT,EACkBzJ,MAAM,CAAC0J,YADzB,EACuC;MACxDC,gBAAgB,EAAExJ,KAAI,CAAC2H,QAAL,CAAc6B,gBADwB;MAExDC,IAAI,EAAEzJ,KAAI,CAAC2H,QAAL,CAAc8B,IAFoC;MAGxDC,4BAA4B,EAAE1J,KAAI,CAAC2H,QAAL,CAAc+B,4BAHY;MAIxDC,aAAa,EAAE3J,KAAI,CAAC6G,qBAJoC;MAKxD+C,iBAAiB,EAAE5J,KAAI,CAAC2H,QAAL,CAAciC,iBALuB;MAMxDlB,SAAS,EAAE1I,KAAI,CAAC2H,QAAL,CAAce;IAN+B,CADvC,CAArB;;IAUA1I,KAAI,CAACsI,EAAL,CAAQ,QAAR,EAAkB,UAACzC,WAAD,EAAsBE,YAAtB,EAA0C;MAC1D/F,KAAI,CAAC6J,kBAAL,GAA0B7J,KAAI,CAAC8J,YAAL,CACxBjE,WADwB,EACX7F,KAAI,CAAC6J,kBADM,EACc7J,KAAI,CAAC8F,kBADnB,EACuC,OADvC,CAA1B;MAEA9F,KAAI,CAAC+J,mBAAL,GAA2B/J,KAAI,CAAC8J,YAAL,CACzB/D,YADyB,EACX/F,KAAI,CAAC+J,mBADM,EACe/J,KAAI,CAACgG,mBADpB,EACyC,QADzC,CAA3B;MAEAhG,KAAI,CAAC8F,kBAAL,GAA0BD,WAA1B;MACA7F,KAAI,CAACgG,mBAAL,GAA2BD,YAA3B;IACD,CAPD;;IASA/F,KAAI,CAAC8C,aAAL,CAAmBkH,QAAnB,GAA8B,UAACnE,WAAD,EAAsBE,YAAtB,EACCkE,mBADD,EAC8BC,oBAD9B,EAC0D;MACtF;MACA;MACA;MACAvB,OAAO,CAACwB,UAAR,CAAoBF,mBAAmB,GAAG,GAAvB,GAA8B,KAAjD,EAAyDC,oBAAoB,GAAG,GAAxB,GAA+B,KAAvF,EAJsF,CAMtF;;MACAlK,KAAI,CAACgC,IAAL,CAAU,QAAV,EAAoB6D,WAApB,EAAiCE,YAAjC;IACD,CATD;;IAWA/F,KAAI,CAAC8C,aAAL,CAAmBsH,0BAAnB,GAAgD,UAACC,KAAD,EAAc;MAC5D,IAAMjJ,KAAK,GAAGiJ,KAAK,KAAK,QAAV,GAAqB,OAArB,GAA+B,OAA7C;;MACArK,KAAI,CAAC4B,UAAL,CAAgBC,IAAhB,CAAqBT,KAArB,EAA4B,sBAA5B,EAAoDiJ,KAApD,EAA2D,IAA3D,EAAiErK,KAAjE;IACD,CAHD;;IAKAA,KAAI,CAAC8C,aAAL,CAAmBwH,yBAAnB,GAA+C,UAACD,KAAD,EAAc;MAC3D,IAAIjJ,KAAK,GAAG,OAAZ;;MACA,IAAMmJ,aAAa,GAAGvK,KAAI,CAAC8C,aAAL,CAAmB0H,mBAAnB,EAAtB;;MAEA,IAAIH,KAAK,KAAK,QAAd,EAAwB;QACtBjJ,KAAK,GAAGmJ,aAAa,IAAIA,aAAa,CAACF,KAAd,KAAwB,QAAzC,GAAoD,OAApD,GAA8D,SAAtE;MACD;;MACDrK,KAAI,CAAC4B,UAAL,CAAgBC,IAAhB,CAAqBT,KAArB,EAA4B,qBAA5B,EAAmDiJ,KAAnD,EAA0D,IAA1D,EAAgErK,KAAhE;IACD,CARD;;IAUAA,KAAI,CAAC8C,aAAL,CAAmB2H,cAAnB,GAAoC,UAACC,SAAD,EAA2B;MAC7D,IAAMzI,OAAO,GAAG,IAAI0I,2BAAJ,CAAiBD,SAAjB,EAA4BE,SAA5B,EAAhB;;MACA5K,KAAI,CAAC4B,UAAL,CAAgBiJ,KAAhB,CAAsB,eAAtB,EAAuC,eAAvC,EAAwD5I,OAAxD,EAAiEjC,KAAjE;IACD,CAHD;;IAKAA,KAAI,CAAC8C,aAAL,CAAmBgI,6BAAnB,GAAmD,UAACC,IAAD,EAA0B;MAC3E,IAAMC,qBAAqB,GAAG,IAAIL,2BAAJ,CAAiBI,IAAI,CAACE,KAAtB,EAA6BL,SAA7B,EAA9B;MACA,IAAMM,sBAAsB,GAAG,IAAIP,2BAAJ,CAAiBI,IAAI,CAACI,MAAtB,EAA8B,IAA9B,EAAoCP,SAApC,EAA/B;;MAEA5K,KAAI,CAAC4B,UAAL,CAAgBiJ,KAAhB,CAAsB,eAAtB,EAAuC,6BAAvC,EAAsE;QACpEO,eAAe,EAAEJ,qBADmD;QAEpEK,gBAAgB,EAAEH;MAFkD,CAAtE,EAGGlL,KAHH;IAID,CARD;;IAUAA,KAAI,CAAC8C,aAAL,CAAmBwI,0BAAnB,GAAgD,UAACjB,KAAD,EAAc;MAC5D,IAAMjJ,KAAK,GAAGiJ,KAAK,KAAK,QAAV,GAAqB,OAArB,GAA+B,OAA7C;;MACArK,KAAI,CAAC4B,UAAL,CAAgBC,IAAhB,CAAqBT,KAArB,EAA4B,sBAA5B,EAAoDiJ,KAApD,EAA2D,IAA3D,EAAiErK,KAAjE;IACD,CAHD;;IAKAA,KAAI,CAAC8C,aAAL,CAAmByI,qBAAnB,GAA2C,UAAC3H,IAAD,EAAqC;MAC9E5D,KAAI,CAAC4B,UAAL,CAAgBuD,IAAhB,CAAqB,qBAArB,EAA4CvB,IAA5C,EAAkD,IAAlD,EAAwD5D,KAAxD;;MACAA,KAAI,CAACkJ,eAAL,CAAqB/I,IAAI,CAACgJ,YAAL,CAAkBpF,kBAAvC;IACD,CAHD;;IAKA/D,KAAI,CAAC8C,aAAL,CAAmB0I,yBAAnB,GAA+C,UAACnB,KAAD,EAAc;MAC3DrK,KAAI,CAAC4B,UAAL,CAAgBiJ,KAAhB,CAAsB,qBAAtB,EAA6CR,KAA7C,EAAoD,IAApD,EAA0DrK,KAA1D;IACD,CAFD;;IAIAA,KAAI,CAAC8C,aAAL,CAAmB2I,sBAAnB,GAA4C,UAACpB,KAAD,EAAc;MACxDrK,KAAI,CAAC4B,UAAL,CAAgBiJ,KAAhB,CAAsB,iBAAtB,EAAyCR,KAAzC,EAAgD,IAAhD,EAAsDrK,KAAtD;IACD,CAFD;;IAIAA,KAAI,CAAC8C,aAAL,CAAmB4I,cAAnB,GAAoC,UAACC,GAAD,EAAY;MAC9C3L,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAeqN,GAAf;;MACA3L,KAAI,CAAC4B,UAAL,CAAgBuD,IAAhB,CAAqB,gCAArB,EAAuD,uBAAvD,EAAgF;QAC9E3G,OAAO,EAAEmN;MADqE,CAAhF,EAEG3L,KAFH;;MAGAA,KAAI,CAACgC,IAAL,CAAU,SAAV,EAAqB,uBAArB;;MAEAhC,KAAI,CAACkJ,eAAL,CAAqB/I,IAAI,CAACgJ,YAAL,CAAkBtF,sBAAvC;IACD,CARD;;IAUA7D,KAAI,CAAC8C,aAAL,CAAmB8I,QAAnB,GAA8B,UAACD,GAAD,EAAY;MACxC3L,KAAI,CAACkJ,eAAL,CAAqB/I,IAAI,CAACgJ,YAAL,CAAkBrF,gBAAvC;IACD,CAFD;;IAIA9D,KAAI,CAAC8C,aAAL,CAAmB+I,WAAnB,GAAiC;MAC/B;MACA,IAAI7L,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWkC,YAAhC,EAA8C;QAC5CtC,KAAI,CAAC8L,mBAAL;MACD;IACF,CALD;;IAOA9L,KAAI,CAAC8C,aAAL,CAAmBiJ,aAAnB,GAAmC,UAACJ,GAAD,EAAY;MAC7C3L,KAAI,CAACoD,IAAL,CAAU9E,IAAV,CAAeqN,GAAf;;MACA3L,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,iCAArB,EAAwD,uBAAxD,EAAiF;QAC/EE,OAAO,EAAEmN;MADsE,CAAjF,EAEG3L,KAFH;;MAGAA,KAAI,CAACgC,IAAL,CAAU,iBAAV,EAA6B,uBAA7B;;MACAhC,KAAI,CAAC8L,mBAAL;IACD,CAPD;;IASA9L,KAAI,CAAC8C,aAAL,CAAmBuB,OAAnB,GAA6B,UAAC2H,CAAD,EAAO;MAClC,IAAIA,CAAC,CAAC3N,UAAF,KAAiB,IAArB,EAA2B;QACzB2B,KAAI,CAAC2D,WAAL,CAAiBqI,CAAC,CAAC1N,IAAF,IAAU0N,CAAC,CAAC1N,IAAF,CAAOE,OAAlC;MACD;;MAED,IAAMiF,KAAK,GAAGuI,CAAC,CAAC1N,IAAF,CAAOG,WAAP,IAAsB,IAAIC,uBAAcuN,YAAlB,CAA+BD,CAAC,CAAC1N,IAAF,CAAOE,OAAtC,CAApC;;MACAwB,KAAI,CAACoD,IAAL,CAAUK,KAAV,CAAgB,qCAAhB,EAAuDuI,CAAvD;;MACAhM,KAAI,CAACgC,IAAL,CAAU,OAAV,EAAmByB,KAAnB;IACD,CARD;;IAUAzD,KAAI,CAAC8C,aAAL,CAAmBoJ,MAAnB,GAA4B;MAC1B;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,IAAIlM,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWiF,IAA5B,IAAoCrF,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWkC,YAApE,EAAkF;QAChF;MACD,CAFD,MAEO,IAAItC,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWoF,OAA5B,IAAuCxF,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWmF,UAAvE,EAAmF;QACxFvF,KAAI,CAACmM,IAAL,CAAU,KAAV;;QACAnM,KAAI,CAACsE,YAAL,GAAoBnE,IAAI,CAACC,KAAL,CAAWiF,IAA/B;;QACArF,KAAI,CAACwC,sBAAL;MACD,CAJM,MAIA;QACL;QACAxC,KAAI,CAAC8C,aAAL,CAAmBC,KAAnB;MACD;IACF,CAnBD;;IAqBA/C,KAAI,CAAC8C,aAAL,CAAmBsJ,OAAnB,GAA6B;MAC3BpM,KAAI,CAACqC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAW4C,MAA1B;;MACA,IAAIhD,KAAI,CAAC2H,QAAL,CAAclH,oBAAd,IAAsCT,KAAI,CAAC2H,QAAL,CAAclH,oBAAd,EAAtC,CACF;MACA;MAFE,GAGC,CAACT,KAAI,CAAC4C,YAHX,EAGyB;QAEvB5C,KAAI,CAAC+G,WAAL,CAAiBsF,GAAjB,CAAqBC,iBAAOC,SAAP,CAAiBC,UAAtC,EAAkDC,IAAlD;MACD;;MAED9D,OAAO,CAAC+D,OAAR;;MACA1M,KAAI,CAACsG,eAAL;;MAEA,IAAI,CAACtG,KAAI,CAAC4C,YAAV,EAAwB;QACtB;QACA5C,KAAI,CAACgC,IAAL,CAAU,YAAV,EAAwBhC,KAAxB;MACD;IACF,CAjBD;;IAmBAA,KAAI,CAACiD,QAAL,GAAgBpD,MAAM,CAACyJ,OAAvB;;IACAtJ,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,QAAjB,EAA2BtI,KAAI,CAACmD,SAAhC;;IACAnD,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,SAAjB,EAA4BtI,KAAI,CAAC2M,UAAjC;;IACA3M,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,gBAAjB,EAAmCtI,KAAI,CAAC4M,iBAAxC;;IACA5M,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,WAAjB,EAA8BtI,KAAI,CAAC6M,YAAnC;;IAEA7M,KAAI,CAACsI,EAAL,CAAQ,OAAR,EAAiB,iBAAK;MACpBtI,KAAI,CAAC4B,UAAL,CAAgB6B,KAAhB,CAAsB,YAAtB,EAAoC,OAApC,EAA6C;QAC3ClF,IAAI,EAAEkF,KAAK,CAAClF,IAD+B;QACzBC,OAAO,EAAEiF,KAAK,CAACjF;MADU,CAA7C,EAEGwB,KAFH;;MAIA,IAAIA,KAAI,CAACiD,QAAL,IAAiBjD,KAAI,CAACiD,QAAL,CAAcM,MAAd,KAAyB,cAA9C,EAA8D;QAC5DvD,KAAI,CAAC6C,sBAAL;MACD;IACF,CARD;;IAUA7C,KAAI,CAACsI,EAAL,CAAQ,YAAR,EAAsB;MACpBtI,KAAI,CAAC6C,sBAAL;IACD,CAFD;;;EAGD;;EAvZDwE,sBAAIlH,cAAJ,EAAI,WAAJ,EAAa;IAHb;;;SAGA;MACE,OAAO,KAAK2H,UAAZ;IACD,CAFY;oBAAA;;EAAA,CAAb;EAQAT,sBAAIlH,cAAJ,EAAI,OAAJ,EAAS;IAJT;;;;SAIA;MACE,OAAO,KAAK8F,MAAZ;IACD,CAFQ;oBAAA;;EAAA,CAAT;EAiZA;;;;;;EAKA9F,qDAA0B2M,MAA1B,EAAoD;IAClD,OAAO,KAAKhK,aAAL,CAAmBiK,wBAAnB,CAA4CD,MAA5C,CAAP;EACD,CAFD;EAIA;;;;;;;EAKA3M,uCAAY6M,OAAZ,EAA6B;IAC3B,OAAO,KAAKlK,aAAL,CAAmBmK,WAAnB,CAA+BD,OAA/B,CAAP;EACD,CAFD;EAIA;;;;;;EAIA7M,kCAAOL,OAAP,EAAmC;IAAnC;;IACE,IAAI,KAAKuC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWC,OAAhC,EAAyC;MACvC;IACD;;IAEDP,OAAO,GAAGA,OAAO,IAAI,EAArB;IACA,IAAMoN,gBAAgB,GAAGpN,OAAO,CAACoN,gBAAR,IAA4B,KAAKvF,QAAL,CAAcuF,gBAAnE;IACA,IAAMC,cAAc,GAAGrN,OAAO,CAACqN,cAAR,IAA0B,KAAKxF,QAAL,CAAcwF,cAAxC,IAA0D,EAAjF;IACA,IAAMC,gBAAgB,GAAGD,cAAc,CAACE,KAAf,IAAwB;MAAEA,KAAK,EAAE;IAAT,CAAjD;IAEA,KAAKhL,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWmF,UAA1B;;IAEA,IAAM+H,OAAO,GAAG;MACd,IAAItN,KAAI,CAACqC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWmF,UAAhC,EAA4C;QAC1C;QACAvF,KAAI,CAAC6C,sBAAL;;QACA7C,KAAI,CAAC8C,aAAL,CAAmBC,KAAnB;;QACA;MACD;;MAED,IAAMwK,QAAQ,GAAG,UAAC3I,EAAD,EAAwBiD,cAAxB,EAA+C;QAC9D;QACA,IAAM2F,SAAS,GAAGxN,KAAI,CAAC8H,UAAL,KAAoB3H,IAAI,CAAC4H,aAAL,CAAmBC,QAAvC,GACd,mBADc,GAEd,oBAFJ;;QAGAhI,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmCkP,SAAnC,EAA8C,IAA9C,EAAoDxN,KAApD;;QAEA,IAAI,OAAO6H,cAAP,KAA0B,QAA9B,EAAwC;UACtC7H,KAAI,CAACmC,wBAAL,GAAgC0F,cAAhC;QACD,CAT6D,CAW9D;;;QACM;QAAA,IAAE3B,wBAAF;QAAA,IAAauH,4BAAb;;QACNzN,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,UAArB,EAAiC,OAAjC,EAA0C;UACxCoP,YAAY,EAAED,WAD0B;UAExCE,cAAc,EAAEzH;QAFwB,CAA1C,EAGGlG,KAHH,EAb8D,CAkB9D;;;QACAA,KAAI,CAACgF,QAAL,CAAc4I,MAAd,CAAqBhJ,EAArB;MACD,CApBD;;MAsBA,IAAMoI,OAAO,GAAG,OAAOhN,KAAI,CAAC2H,QAAL,CAAckG,UAArB,KAAoC,UAApC,IAAkD7N,KAAI,CAAC2H,QAAL,CAAckG,UAAd,EAAlE;;MACA,IAAIvM,KAAK,CAACwM,OAAN,CAAcd,OAAd,CAAJ,EAA4B;QAC1BhN,KAAI,CAAC8C,aAAL,CAAmBmK,WAAnB,CAA+BD,OAA/B,EAAwCe,KAAxC,CAA8C,aAC5C;UACA;UACA;QACD,CAJD;MAKD;;MAED/N,KAAI,CAACiD,QAAL,CAAc+K,WAAd,CAA0B,QAA1B,EAAoChO,KAAI,CAACiO,SAAzC;;MAEA,IAAIjO,KAAI,CAAC8H,UAAL,KAAoB3H,IAAI,CAAC4H,aAAL,CAAmBC,QAA3C,EAAqD;QACnDhI,KAAI,CAACoC,WAAL,GAAmB,IAAnB;;QACApC,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,QAAjB,EAA2BtI,KAAI,CAACkO,SAAL,CAAeC,IAAf,CAAoBnO,KAApB,CAA3B;;QACAA,KAAI,CAAC8C,aAAL,CAAmBsL,kBAAnB,CAAsCpO,KAAI,CAAC0C,UAAL,CAAgBC,OAAtD,EAA+D3C,KAAI,CAAC2H,QAAL,CAAcnH,QAA7E,EACE2M,cADF,EACkBD,gBADlB,EACoCK,QADpC;MAED,CALD,MAKO;QACL,IAAMc,MAAM,GAAG/M,KAAK,CAACgN,IAAN,CAAWtO,KAAI,CAACoH,gBAAL,CAAsBE,OAAtB,EAAX,EAA4C9F,GAA5C,CAAgD,gBAAI;UAClE,OAAG+M,kBAAkB,CAACxD,IAAI,CAAC,CAAD,CAAL,CAAlB,GAA2B,GAA3B,GAA+BwD,kBAAkB,CAACxD,IAAI,CAAC,CAAD,CAAL,CAApD;QAA+D,CADjD,EACmDyD,IADnD,CACwD,GADxD,CAAf;;QAEAxO,KAAI,CAACiD,QAAL,CAAcqF,EAAd,CAAiB,QAAjB,EAA2BtI,KAAI,CAACkO,SAAL,CAAeC,IAAf,CAAoBnO,KAApB,CAA3B;;QACAA,KAAI,CAAC8C,aAAL,CAAmB2L,gBAAnB,CAAoCzO,KAAI,CAACiD,QAAL,CAAcyL,KAAlD,EAAyDL,MAAzD,EAAiErO,KAAI,CAACwD,oBAAtE,EACE2J,cADF,EACkBD,gBADlB,EACoCK,QADpC;MAED;IACF,CArDD;;IAuDA,IAAI,KAAK5F,QAAL,CAAcgH,YAAlB,EAAgC;MAC9B,KAAKhH,QAAL,CAAcgH,YAAd,CAA2B,IAA3B;IACD;;IAED,IAAMC,WAAW,GAAG,OAAO,KAAKjH,QAAL,CAAckH,cAArB,KAAwC,UAAxC,IAAsD,KAAKlH,QAAL,CAAckH,cAAd,EAA1E;;IAEA,IAAMC,OAAO,GAAGF,WAAW,GACvB,KAAK9L,aAAL,CAAmBiK,wBAAnB,CAA4C6B,WAA5C,CADuB,GAEvB,KAAK9L,aAAL,CAAmBiM,mBAAnB,CAAuC3B,gBAAvC,CAFJ;IAIA0B,OAAO,CAACE,IAAR,CAAa;MACXhP,KAAI,CAAC4B,UAAL,CAAgBtD,IAAhB,CAAqB,gBAArB,EAAuC,WAAvC,EAAoD;QAClDwD,IAAI,EAAE;UAAEsL,gBAAgB;QAAlB;MAD4C,CAApD,EAEGpN,KAFH;;MAIAsN,OAAO;IACR,CAND,EAMG,UAAC7J,KAAD,EAA2B;MAC5B,IAAIhF,WAAJ;;MAEA,IAAIgF,KAAK,CAAClF,IAAN,KAAe,KAAf,IACC,CAAC,uBAAD,EAA0B,iBAA1B,EAA6C0Q,OAA7C,CAAqDxL,KAAK,CAAC+C,IAA3D,MAAqE,CAAC,CAD3E,EAC8E;QAC5E/H,WAAW,GAAG,IAAIC,yBAAgBwQ,qBAApB,EAAd;;QACAlP,KAAI,CAAC4B,UAAL,CAAgB6B,KAAhB,CAAsB,gBAAtB,EAAwC,QAAxC,EAAkD;UAChD3B,IAAI,EAAE;YACJsL,gBAAgB,kBADZ;YAEJ3J,KAAK;UAFD;QAD0C,CAAlD,EAKGzD,KALH;MAMD,CATD,MASO;QACLvB,WAAW,GAAG,IAAIC,yBAAgByQ,sBAApB,EAAd;;QAEAnP,KAAI,CAAC4B,UAAL,CAAgB6B,KAAhB,CAAsB,gBAAtB,EAAwC,QAAxC,EAAkD;UAChD3B,IAAI,EAAE;YACJsL,gBAAgB,kBADZ;YAEJ3J,KAAK;UAFD;QAD0C,CAAlD,EAKGzD,KALH;MAMD;;MAEDA,KAAI,CAAC2D,WAAL;;MACA3D,KAAI,CAACgC,IAAL,CAAU,OAAV,EAAmBvD,WAAnB;IACD,CA/BD;EAgCD,CA7GD;EA+GA;;;;;EAGA0B;IACE,KAAKwD,WAAL;EACD,CAFD;EAIA;;;;;EAGAxD;IACE,OAAO,KAAK2C,aAAL,IAAsB,KAAKA,aAAL,CAAmBgK,MAAhD;EACD,CAFD;EAIA;;;;;EAGA3M;IACE,OAAO,KAAK2C,aAAL,IAAsB,KAAKA,aAAL,CAAmBsM,aAAhD;EACD,CAFD;EAIA;;;;;EAGAjP;IACE,IAAI,KAAKkC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWC,OAAhC,EAAyC;MACvC;IACD;;IAED,KAAKgC,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAW4C,MAA1B;;IACA,KAAKF,aAAL,CAAmBuM,MAAnB,CAA0B,KAAK3M,UAAL,CAAgBC,OAA1C;;IACA,KAAKf,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,kBAAnC,EAAuD,IAAvD,EAA6D,IAA7D;;IAEA,IAAI,KAAK4I,SAAT,EAAoB;MAClB,KAAKA,SAAL;IACD;EACF,CAZD;EAcA;;;;;EAGA/G;IACE,OAAO,KAAK2C,aAAL,CAAmB3B,OAA1B;EACD,CAFD;EAIA;;;;;;EAIAhB,gCAAKmP,UAAL,EAA+B;IAA1B;MAAAA;IAA0B;;IAC7B,IAAMC,QAAQ,GAAG,KAAKzM,aAAL,CAAmB3B,OAApC;;IACA,KAAK2B,aAAL,CAAmBqJ,IAAnB,CAAwBmD,UAAxB;;IAEA,IAAMnO,OAAO,GAAG,KAAK2B,aAAL,CAAmB3B,OAAnC;;IACA,IAAIoO,QAAQ,KAAKpO,OAAjB,EAA0B;MACxB,KAAKS,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC6C,OAAO,GAAG,OAAH,GAAa,SAAvD,EAAkE,IAAlE,EAAwE,IAAxE;;MACA,KAAKa,IAAL,CAAU,MAAV,EAAkBb,OAAlB,EAA2B,IAA3B;IACD;EACF,CATD;EAWA;;;;;;;;;;;;;EAWAhB,wCAAaqP,KAAb,EAAyCC,KAAzC,EAAmE;IACjE,IAAI,OAAOD,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,KAAK,IAA9C,EAAoD;MAClD,OAAO,KAAKE,qBAAL,EAAP;IACD;;IAED,IAAI,CAACrI,MAAM,CAAC9F,MAAP,CAAcpB,IAAI,CAACwP,aAAnB,EAAkCC,QAAlC,CAA2CJ,KAA3C,CAAL,EAAwD;MACtD,MAAM,IAAI9Q,6BAAJ,CAAyB,oCAAkC2I,MAAM,CAAC9F,MAAP,CAAcpB,IAAI,CAACwP,aAAnB,CAA3D,CAAN;IACD;;IAED,IAAI,OAAOF,KAAP,KAAiB,WAAjB,IAAgCA,KAAK,KAAK,IAA1C,IAAkD,CAACpI,MAAM,CAAC9F,MAAP,CAAcpB,IAAI,CAAC0P,aAAnB,EAAkCD,QAAlC,CAA2CH,KAA3C,CAAvD,EAA0G;MACxG,MAAM,IAAI/Q,6BAAJ,CAAyB,oCAAkC2I,MAAM,CAAC9F,MAAP,CAAcpB,IAAI,CAAC0P,aAAnB,CAA3D,CAAN;IACD;;IAED,OAAO,KAAKjO,UAAL,CAAgBtD,IAAhB,CAAqB,UAArB,EAAiC,UAAjC,EAA6C;MAClDwR,UAAU,EAAEL,KADsC;MAElDM,aAAa,EAAEP;IAFmC,CAA7C,EAGJ,IAHI,EAGE,IAHF,CAAP;EAID,CAjBD;EAmBA;;;;;EAGArP;IACE,IAAI,KAAKkC,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWC,OAAhC,EAAyC;MACvC;IACD;;IAED,KAAK4C,QAAL,CAAc+M,MAAd,CAAqB,KAAKtN,UAAL,CAAgBC,OAArC;;IACA,KAAKN,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAW4C,MAA1B;IACA,KAAKhB,IAAL,CAAU,QAAV;;IACA,KAAKc,aAAL,CAAmBkN,MAAnB,CAA0B,KAAKtN,UAAL,CAAgBC,OAA1C;;IACA,KAAKf,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,mBAAnC,EAAwD,IAAxD,EAA8D,IAA9D;EACD,CAVD;EAYA;;;;;;EAIA6B,sCAAW8P,MAAX,EAAyB;IACvB,IAAIA,MAAM,CAACC,KAAP,CAAa,WAAb,CAAJ,EAA+B;MAC7B,MAAM,IAAIxR,6BAAJ,CAAyB,0CAAzB,CAAN;IACD;;IAED,IAAMyR,QAAQ,GAAa,EAA3B;IACAF,MAAM,CAACG,KAAP,CAAa,EAAb,EAAiBC,OAAjB,CAAyB,UAACC,KAAD,EAAc;MACrC,IAAIC,IAAI,GAAID,KAAK,KAAK,GAAX,GAAkB,SAAOA,KAAzB,GAAmC,EAA9C;;MACA,IAAIC,IAAI,KAAK,OAAb,EAAsB;QAAEA,IAAI,GAAG,OAAP;MAAiB;;MACzC,IAAIA,IAAI,KAAK,OAAb,EAAsB;QAAEA,IAAI,GAAG,OAAP;MAAiB;;MACzCJ,QAAQ,CAAC/J,IAAT,CAAcmK,IAAd;IACD,CALD,EANuB,CAavB;;IACA,CAAC,SAASC,aAAT,CAAuBC,UAAvB,EAAmCC,cAAnC,EAAiD;MAChD,IAAMJ,KAAK,GAAuBH,QAAQ,CAACQ,KAAT,EAAlC;;MAEA,IAAIL,KAAJ,EAAW;QACT,IAAII,cAAJ,EAAoB;UAClBA,cAAc,CAACjE,IAAf,CAAoB6D,KAApB;QACD,CAFD,MAEO;UACLG,UAAU,CAACpE,GAAX,CAAeiE,KAAf,EAA0C7D,IAA1C;QACD;MACF;;MAED,IAAI0D,QAAQ,CAAC9J,MAAb,EAAqB;QACnB2C,UAAU,CAACwH,aAAa,CAACrC,IAAd,CAAmB,IAAnB,EAAyBsC,UAAzB,CAAD,EAAuC,GAAvC,CAAV;MACD;IACF,CAdD,EAcG,KAAK1J,WAdR,EAcqB,KAAKY,QAAL,CAAc+I,cAdnC;;IAgBA,IAAME,UAAU,GAAG,KAAK9N,aAAL,CAAmB+N,qBAAnB,EAAnB;;IAEA,SAASC,UAAT,CAAoBC,KAApB,EAAmC;MACjC,IAAI,CAACA,KAAK,CAAC1K,MAAX,EAAmB;QAAE;MAAS;;MAC9B,IAAMkK,IAAI,GAAuBQ,KAAK,CAACJ,KAAN,EAAjC;;MAEA,IAAIJ,IAAI,IAAIA,IAAI,CAAClK,MAAjB,EAAyB;QACvBuK,UAAU,CAACE,UAAX,CAAsBP,IAAtB,EAA4BtS,kBAA5B,EAAgDF,mBAAhD;MACD;;MAEDiL,UAAU,CAAC8H,UAAU,CAAC3C,IAAX,CAAgB,IAAhB,EAAsB4C,KAAtB,CAAD,EAA+B/S,mBAA/B,CAAV;IACD;;IAED,IAAI4S,UAAJ,EAAgB;MACd,IAAI,EAAE,mBAAmBA,UAArB,KAAoCA,UAAU,CAACI,aAAnD,EAAkE;QAChE,KAAK5N,IAAL,CAAU9E,IAAV,CAAe,oCAAf,EADgE,CAEhE;QACA;QACA;;;QACAwS,UAAU,CAACb,MAAM,CAACG,KAAP,CAAa,GAAb,CAAD,CAAV;QACA;MACD;;MAED,KAAKhN,IAAL,CAAU9E,IAAV,CAAe,kCAAf;IACD,CAtDsB,CAwDvB;;;IACA,KAAK8E,IAAL,CAAU9E,IAAV,CAAe,6BAAf;;IAEA,IAAI,KAAK2E,QAAL,KAAkB,IAAlB,IAA0B,KAAKA,QAAL,CAAcM,MAAd,KAAyB,cAAvD,EAAuE;MACrE,KAAKN,QAAL,CAAcsN,IAAd,CAAmB,KAAK7N,UAAL,CAAgBC,OAAnC,EAA4CsN,MAA5C;IACD,CAFD,MAEO;MACL,IAAMxM,KAAK,GAAG,IAAI/E,uBAAcC,eAAlB,CAAkC,wDAAlC,CAAd;MACA,KAAKqD,IAAL,CAAU,OAAV,EAAmByB,KAAnB;IACD;EACF,CAjED;EAmEA;;;;;EAGAtD;IACE,OAAO,KAAKkC,OAAZ;EACD,CAFD;EAUA;;;;;;;;;;;;EAUQlC,8BAAR,UAAqB8Q,aAArB,EAA4CC,aAA5C,EACqBC,SADrB,EACwCC,SADxC,EACmE;IACjE,IAAMC,gBAAgB,GAAYH,aAAa,IAAI,EAAnD;IACA,IAAII,SAAS,GAAW,CAAxB;;IAEA,IAAIH,SAAS,KAAKF,aAAlB,EAAiC;MAC/BK,SAAS,GAAGJ,aAAZ;IACD;;IAED,IAAII,SAAS,IAAI,EAAjB,EAAqB;MACnB,KAAK3K,YAAL,CAAkB,cAAlB,EAAkC,oBAAkByK,SAAlB,GAA2B,QAA7D,EAAuE,EAAvE,EAA2EE,SAA3E,EAAsF,KAAtF;IACD,CAFD,MAEO,IAAID,gBAAJ,EAAsB;MAC3B,KAAK1K,YAAL,CAAkB,cAAlB,EAAkC,oBAAkByK,SAAlB,GAA2B,QAA7D,EAAuE,EAAvE,EAA2EE,SAA3E,EAAsF,IAAtF;IACD;;IAED,OAAOA,SAAP;EACD,CAhBO;EAkBR;;;;;EAGQnR,wCAAR;IAAA;;IACE,IAAMoR,OAAO,GAAG;MACd,IAAI,CAACvR,KAAI,CAACiD,QAAV,EAAoB;QAAE;MAAS;;MAE/BjD,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,QAA7B,EAAuClD,KAAI,CAACkO,SAA5C;;MACAlO,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,QAA7B,EAAuClD,KAAI,CAACmD,SAA5C;;MACAnD,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,QAA7B,EAAuClD,KAAI,CAACiO,SAA5C;;MACAjO,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,SAA7B,EAAwClD,KAAI,CAAC2M,UAA7C;;MACA3M,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,gBAA7B,EAA+ClD,KAAI,CAAC4M,iBAApD;;MACA5M,KAAI,CAACiD,QAAL,CAAcC,cAAd,CAA6B,WAA7B,EAA0ClD,KAAI,CAAC6M,YAA/C;IACD,CATD,CADF,CAYE;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;IACA;;;IACA0E,OAAO;IACPvI,UAAU,CAACuI,OAAD,EAAU,CAAV,CAAV;EACD,CA1BO;EA4BR;;;;;EAGQpR,sCAAR;IACE,IAAM8B,OAAO,GAA4C;MACvDuP,QAAQ,EAAE,KAAK9O,UAAL,CAAgBC,OAD6B;MAEvD8G,IAAI,EAAE,CAAC,CAAC,KAAK9B,QAAL,CAAc8B,IAFiC;MAGvDgI,WAAW,EAAEhU,CAAC,CAACiU,eAHwC;MAIvDC,eAAe,EAAE,KAAKhK,QAAL,CAAciK;IAJwB,CAAzD;;IAOA,IAAI,KAAKjK,QAAL,CAAckK,OAAlB,EAA2B;MACzB5P,OAAO,CAAC4P,OAAR,GAAkB,KAAKlK,QAAL,CAAckK,OAAhC;IACD;;IAED,IAAI,KAAKlK,QAAL,CAAcmK,MAAlB,EAA0B;MACxB7P,OAAO,CAAC6P,MAAR,GAAiB,KAAKnK,QAAL,CAAcmK,MAA/B;IACD;;IAED7P,OAAO,CAACmP,SAAR,GAAoB,KAAKtJ,UAAzB;IACA,OAAO7F,OAAP;EACD,CAlBO;EAoBR;;;;;;;EAKQ9B,6BAAR,UAAoB3B,OAApB,EAA6CuT,SAA7C,EAAgE;IAC9DvT,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GAA8BA,OAA9B,GAAwC,IAAlD;;IAEA,IAAI,KAAK6D,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWiF,IAA5B,IACG,KAAKhD,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWmF,UAD/B,IAEG,KAAKlD,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWkC,YAF/B,IAGG,KAAKD,OAAL,KAAiBlC,IAAI,CAACC,KAAL,CAAWoF,OAHnC,EAG4C;MAC1C;IACD;;IAED,KAAKpC,IAAL,CAAU9E,IAAV,CAAe,kBAAf,EAV8D,CAY9D;;;IACA,IAAI,KAAK2E,QAAL,KAAkB,IAAlB,IAA0B,KAAKA,QAAL,CAAcM,MAAd,KAAyB,cAAnD,IAAqE,KAAKG,iBAA9E,EAAiG;MAC/F,IAAMjB,OAAO,GAAuB,KAAKC,UAAL,CAAgBC,OAAhB,IAA2B,KAAKa,oBAApE;;MACA,IAAIf,OAAJ,EAAa;QACX,KAAKQ,QAAL,CAAc+O,MAAd,CAAqBvP,OAArB,EAA8BjE,OAA9B;MACD;IACF;;IAED,KAAKqE,sBAAL;;IACA,KAAKC,aAAL,CAAmBC,KAAnB;;IAEA,IAAI,CAACgP,SAAL,EAAgB;MACd,KAAKnQ,UAAL,CAAgBtD,IAAhB,CAAqB,YAArB,EAAmC,uBAAnC,EAA4D,IAA5D,EAAkE,IAAlE;IACD;EACF,CA1BO;EAqER;;;;;EAGQ6B,wCAAR;IACE,IAAM8R,YAAY,GAAG,KAAKC,aAA1B;;IACA,IAAI,KAAK9P,WAAT,EAAsB;MACpB,KAAK+P,uBAAL;;MACA,KAAK7M,gBAAL,GAAwBnF,IAAI,CAACC,KAAL,CAAWiF,IAAnC;;MACA,IAAI,KAAKvC,aAAL,IAAsB,KAAKA,aAAL,CAAmBS,MAAnB,KAA8B,MAAxD,EAAgE;QAC9D,KAAKlB,OAAL,GAAelC,IAAI,CAACC,KAAL,CAAWiF,IAA1B;;QACA,IAAI,CAAC,KAAK6M,aAAV,EAAyB;UACvB,KAAKA,aAAL,GAAqB,IAArB;UACA,KAAKlQ,IAAL,CAAU,QAAV,EAAoB,IAApB;QACD;MACF;IACF;EACF,CAbO;EAkRR;;;;;;EAIQ7B,uCAAR;IACE,OAAO,KAAKyB,UAAL,CAAgBtD,IAAhB,CAAqB,UAArB,EAAiC,eAAjC,EAAkD,IAAlD,EAAwD,IAAxD,EAA8D,IAA9D,CAAP;EACD,CAFO;EAIR;;;;;EAGQ6B,iCAAR;IAAA;;IACE,IAAI,KAAKgG,eAAL,CAAqBE,MAArB,KAAgC,CAApC,EAAuC;MACrC;IACD;;IAED,KAAKzE,UAAL,CAAgBwQ,WAAhB,CACE,yBADF,EAC6B,gBAD7B,EAC+C,KAAKjM,eAAL,CAAqBkM,MAArB,CAA4B,CAA5B,CAD/C,EAC+E,KAAKC,oBAAL,EAD/E,EAC4G,IAD5G,EAEEvE,KAFF,CAEQ,UAAC/B,CAAD,EAAO;MACbhM,KAAI,CAACoD,IAAL,CAAU+B,IAAV,CAAe,qDAAf,EAAsE6G,CAAtE;IACD,CAJD;EAKD,CAVO;EAiDR;;;;;;EAIQ7L,6BAAR,UAAoB8B,OAApB,EAAmD;IACjD,IAAMsQ,OAAO,GAAGtQ,OAAO,CAACQ,OAAxB;;IACA,IAAI,CAAC8P,OAAL,EAAc;MAAE;IAAS;;IAEzB,KAAK7P,UAAL,CAAgBC,OAAhB,GAA0B4P,OAA1B;IACA,KAAKzP,aAAL,CAAmByP,OAAnB,GAA6BA,OAA7B;EACD,CANO;EAhuCR;;;;;;EAIOpS,gBAAW;IAAM;EAAqB,CAAtC;;EAmuCT;AAAC,CAxuCD,CAAmBqS,qBAAnB;;AA0uCA,WAAUrS,IAAV,EAAc;EAkFZ;;;EAGA,IAAYC,KAAZ;;EAAA,WAAYA,KAAZ,EAAiB;IACfA;IACAA;IACAA;IACAA;IACAA;IACAA;EACD,CAPD,EAAYA,KAAK,GAALD,4BAAK,EAAL,CAAZ;EASA;;;;;;EAIA,IAAY0P,aAAZ;;EAAA,WAAYA,aAAZ,EAAyB;IACvBA;IACAA;IACAA;IACAA;IACAA;IACAA;EACD,CAPD,EAAYA,aAAa,GAAb1P,4CAAa,EAAb,CAAZ;EASA;;;;;;EAIA,IAAYwP,aAAZ;;EAAA,WAAYA,aAAZ,EAAyB;IACvBA;IACAA;IACAA;IACAA;IACAA;EACD,CAND,EAAYA,aAAa,GAAbxP,4CAAa,EAAb,CAAZ;EAQA;;;;;EAGA,IAAY4H,aAAZ;;EAAA,WAAYA,aAAZ,EAAyB;IACvBA;IACAA;EACD,CAHD,EAAYA,aAAa,GAAb5H,4CAAa,EAAb,CAAZ;EAKA;;;;;EAGA,IAAYsS,KAAZ;;EAAA,WAAYA,KAAZ,EAAiB;IACfA;IACAA;EACD,CAHD,EAAYA,KAAK,GAALtS,4BAAK,EAAL,CAAZ;EAKA;;;;;EAGA,IAAYuS,yBAAZ;;EAAA,WAAYA,yBAAZ,EAAqC;IACnCA;IACAA;EACD,CAHD,EAAYA,yBAAyB,GAAzBvS,oEAAyB,EAAzB,CAAZ;EAKA;;;;;EAGA,IAAYgJ,YAAZ;;EAAA,WAAYA,YAAZ,EAAwB;IACtBA;IACAA;IACAA;IACAA;EACD,CALD,EAAYA,YAAY,GAAZhJ,0CAAY,EAAZ,CAAZ;AAkND,CApWD,EAAUA,IAAI,KAAJA,IAAI,MAAd;;AAsWA,SAASqI,mBAAT,GAA4B;EAC1B,OAAO,0CAA0CmK,OAA1C,CAAkD,OAAlD,EAA2D,aAAC;IACjE;IACA,IAAMC,CAAC,GAAGlR,IAAI,CAACmR,MAAL,KAAgB,EAAhB,GAAqB,CAA/B;IACA,IAAMC,CAAC,GAAGC,CAAC,KAAK,GAAN,GAAYH,CAAZ,GAAiBA,CAAC,GAAG,GAAJ,GAAU,GAArC;IACA;;IACA,OAAOE,CAAC,CAACE,QAAF,CAAW,EAAX,CAAP;EACD,CANM,CAAP;AAOD;;AAEDC,kBAAe9S,IAAf","names":["Backoff","require","C","BACKOFF_CONFIG","factor","initialDelay","maxDelay","randomisationFactor","DTMF_INTER_TONE_GAP","DTMF_PAUSE_DURATION","DTMF_TONE_DURATION","METRICS_BATCH_SIZE","METRICS_DELAY","MEDIA_DISCONNECT_ERROR","disconnect","info","code","message","twilioError","errors_1","ConnectionError","MULTIPLE_THRESHOLD_WARNING_NAMES","packetsLostFraction","max","maxAverage","WARNING_NAMES","audioInputLevel","audioOutputLevel","bytesReceived","bytesSent","jitter","mos","rtt","WARNING_PREFIXES","maxDuration","min","minStandardDeviation","__extends","config","options","_super","_this","log_1","getInstance","Call","State","Pending","MediaHandler","PeerConnection","offerSdp","shouldPlayDisconnect","Map","groupPrefix","warningName","threshold","value","wasCleared","warningData","groupSuffix","groupName","isMuted","level","payloadData","Array","values","map","val","Math","round","_publisher","post","data","emitName","emit","payload","reconnect","_signalingReconnectToken","_isAnswered","_status","Reconnecting","_setCallSid","_maybeTransitionToOpen","callsid","parameters","CallSid","_isCancelled","_cleanupEventListeners","_mediaHandler","close","Closed","_pstream","removeListener","_onCancel","_log","version","getSDP","status","outboundConnectionId","error","_shouldSendHangup","_disconnect","type","ConnectionDisconnected","ConnectionFailed","IceGatheringFailed","LowBytes","isEndOfIceCycle","util_1","window","navigator","onerror","_mediaStatus","Date","now","_mediaReconnectStartTime","_mediaReconnectBackoff","backoff","pc","isIceDisconnected","iceConnectionState","hasLowBytesWarning","_monitor","hasActiveWarning","mediaReconnectionError","warn","reset","Open","_signalingStatus","Connecting","Ringing","hasEarlyMedia","sdp","sample","callMetrics","inputVolume","_latestInputVolume","outputVolume","_latestOutputVolume","_codec","codecName","_metricsSamples","push","length","_publishMetrics","test","name","warningPrefix","warning","_emitWarning","_reemitWarning","_isUnifiedPlanDefault","isUnifiedPlanDefault","_soundcache","soundcache","onIgnore","_onIgnore","twimlParams","customParameters","Object","entries","_a","key","String","assign","_options","callParameters","reconnectToken","_direction","CallDirection","Incoming","Outgoing","callerInfo","StirStatus","isVerified","exponential","on","iceRestart","generateTempCallSid","publisher","preflight","monitor","StatsMonitor","statsMonitor_1","_onRTCSample","disableWarnings","setTimeout","enableWarnings","_onMediaFailure","MediaFailure","_reemitWarningCleared","audioHelper","pstream","getUserMedia","codecPreferences","dscp","forceAggressiveIceNomination","isUnifiedPlan","maxAverageBitrate","_inputVolumeStreak","_checkVolume","_outputVolumeStreak","onvolume","internalInputVolume","internalOutputVolume","addVolumes","ondtlstransportstatechange","state","onpcconnectionstatechange","dtlsTransport","getRTCDtlsTransport","onicecandidate","candidate","icecandidate_1","toPayload","debug","onselectedcandidatepairchange","pair","localCandidatePayload","local","remoteCandidatePayload","remote","local_candidate","remote_candidate","oniceconnectionstatechange","onicegatheringfailure","onicegatheringstatechange","onsignalingstatechange","ondisconnected","msg","onfailed","onconnected","_onMediaReconnected","onreconnected","e","UnknownError","onopen","mute","onclose","get","device_1","SoundName","Disconnect","play","disable","_onRinging","_onTransportClose","_onConnected","stream","setInputTracksFromStream","sinkIds","_setSinkIds","rtcConfiguration","rtcConstraints","audioConstraints","audio","connect","onAnswer","eventName","codecParams","codec_params","selected_codec","enable","getSinkIds","isArray","catch","addListener","_onHangup","_onAnswer","bind","answerIncomingCall","params","from","encodeURIComponent","join","makeOutgoingCall","token","beforeAccept","inputStream","getInputStream","promise","openWithConstraints","then","indexOf","PermissionDeniedError","AcquisitionFailedError","_remoteStream","ignore","shouldMute","wasMuted","score","issue","_postFeedbackDeclined","FeedbackScore","includes","FeedbackIssue","issue_name","quality_score","reject","digits","match","sequence","split","forEach","digit","dtmf","playNextDigit","soundCache","dialtonePlayer","shift","dtmfSender","getOrCreateDTMFSender","insertDTMF","dtmfs","canInsertDTMF","currentVolume","currentStreak","lastValue","direction","wasWarningRaised","newStreak","cleanup","call_sid","sdk_version","RELEASE_VERSION","selected_region","selectedRegion","gateway","region","wasRemote","hangup","wasConnected","_wasConnected","_onSignalingReconnected","postMetrics","splice","_createMetricPayload","callSid","events_1","Codec","IceGatheringFailureReason","replace","r","random","v","c","toString","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/call.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @publicapi\n * @internal\n */\nimport { EventEmitter } from 'events';\nimport Device from './device';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  GeneralErrors,\n  InvalidArgumentError,\n  MediaErrors,\n  SignalingErrors,\n  TwilioError,\n  UserMediaErrors,\n} from './errors';\nimport Log from './log';\nimport { IceCandidate, RTCIceCandidate } from './rtc/icecandidate';\nimport RTCSample from './rtc/sample';\nimport RTCWarning from './rtc/warning';\nimport StatsMonitor from './statsMonitor';\nimport { isChrome } from './util';\n\nconst Backoff = require('backoff');\nconst C = require('./constants');\nconst { PeerConnection } = require('./rtc');\nconst { getPreferredCodecInfo } = require('./rtc/sdp');\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IAudioHelper = any;\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPeerConnection = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst BACKOFF_CONFIG = {\n  factor: 1.1,\n  initialDelay: 1,\n  maxDelay: 30000,\n  randomisationFactor: 0.5,\n};\n\nconst DTMF_INTER_TONE_GAP: number = 70;\nconst DTMF_PAUSE_DURATION: number = 500;\nconst DTMF_TONE_DURATION: number = 160;\n\nconst METRICS_BATCH_SIZE: number = 10;\nconst METRICS_DELAY: number = 5000;\n\nconst MEDIA_DISCONNECT_ERROR = {\n  disconnect: true,\n  info: {\n    code: 31003,\n    message: 'Connection with Twilio was interrupted.',\n    twilioError: new MediaErrors.ConnectionError(),\n  },\n};\n\nconst MULTIPLE_THRESHOLD_WARNING_NAMES: Record<string, Record<string, string>> = {\n  // The stat `packetsLostFraction` is monitored by two separate thresholds,\n  // `maxAverage` and `max`. Each threshold emits a different warning name.\n  packetsLostFraction: {\n    max: 'packet-loss',\n    maxAverage: 'packets-lost-fraction',\n  },\n};\n\nconst WARNING_NAMES: Record<string, string> = {\n  audioInputLevel: 'audio-input-level',\n  audioOutputLevel: 'audio-output-level',\n  bytesReceived: 'bytes-received',\n  bytesSent: 'bytes-sent',\n  jitter: 'jitter',\n  mos: 'mos',\n  rtt: 'rtt',\n};\n\nconst WARNING_PREFIXES: Record<string, string> = {\n  max: 'high-',\n  maxAverage: 'high-',\n  maxDuration: 'constant-',\n  min: 'low-',\n  minStandardDeviation: 'constant-',\n};\n\n/**\n * A {@link Call} represents a media and signaling connection to a TwiML application.\n * @publicapi\n */\nclass Call extends EventEmitter {\n  /**\n   * String representation of the {@link Call} class.\n   * @private\n   */\n  static toString = () => '[Twilio.Call class]';\n\n  /**\n   * Returns caller verification information about the caller.\n   * If no caller verification information is available this will return null.\n   */\n  readonly callerInfo: Call.CallerInfo | null;\n\n  /**\n   * The custom parameters sent to (outgoing) or received by (incoming) the TwiML app.\n   */\n  readonly customParameters: Map<string, string>;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  get direction(): Call.CallDirection {\n    return this._direction;\n  }\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  get codec(): string {\n    return this._codec;\n  }\n\n  /**\n   * The temporary CallSid for this call, if it's outbound.\n   */\n  readonly outboundConnectionId?: string;\n\n  /**\n   * Call parameters received from Twilio for an incoming call.\n   */\n  parameters: Record<string, string> = { };\n\n  /**\n   * Audio codec used for this {@link Call}. Expecting {@link Call.Codec} but\n   * will copy whatever we get from RTC stats.\n   */\n  private _codec: string;\n\n  /**\n   * Whether this {@link Call} is incoming or outgoing.\n   */\n  private readonly _direction: Call.CallDirection;\n\n  /**\n   * The number of times input volume has been the same consecutively.\n   */\n  private _inputVolumeStreak: number = 0;\n\n  /**\n   * Whether the call has been answered.\n   */\n  private _isAnswered: boolean = false;\n\n  /**\n   * Whether the call has been cancelled.\n   */\n  private _isCancelled: boolean = false;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private readonly _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * The most recent public input volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestInputVolume: number = 0;\n\n  /**\n   * The most recent public output volume value. 0 -> 1 representing -100 to -30 dB.\n   */\n  private _latestOutputVolume: number = 0;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * The MediaHandler (Twilio PeerConnection) this {@link Call} is using for\n   * media signaling.\n   */\n  private _mediaHandler: IPeerConnection;\n\n  /**\n   * An instance of Backoff for media reconnection\n   */\n  private _mediaReconnectBackoff: any;\n\n  /**\n   * Timestamp for the initial media reconnection\n   */\n  private _mediaReconnectStartTime: number;\n\n  /**\n   * State of the {@link Call}'s media.\n   */\n  private _mediaStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A batch of metrics samples to send to Insights. Gets cleared after\n   * each send and appended to on each new sample.\n   */\n  private readonly _metricsSamples: Call.CallMetrics[] = [];\n\n  /**\n   * An instance of StatsMonitor.\n   */\n  private readonly _monitor: StatsMonitor;\n\n  /**\n   * Method to be run after {@link Call.ignore} is called.\n   */\n  private _onIgnore: () => void;\n\n  /**\n   * Options passed to this {@link Call}.\n   */\n  private _options: Call.Options = {\n    MediaHandler: PeerConnection,\n    offerSdp: null,\n    shouldPlayDisconnect: () => true,\n  };\n\n  /**\n   * The number of times output volume has been the same consecutively.\n   */\n  private _outputVolumeStreak: number = 0;\n\n  /**\n   * The PStream instance to use for Twilio call signaling.\n   */\n  private readonly _pstream: IPStream;\n\n  /**\n   * An instance of EventPublisher.\n   */\n  private readonly _publisher: IPublisher;\n\n  /**\n   * Whether the {@link Call} should send a hangup on disconnect.\n   */\n  private _shouldSendHangup: boolean = true;\n\n  /**\n   * The signaling reconnection token used to re-establish a lost signaling connection.\n   */\n  private _signalingReconnectToken: string | undefined;\n\n  /**\n   * State of the {@link Call}'s signaling.\n   */\n  private _signalingStatus: Call.State = Call.State.Pending;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private readonly _soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * State of the {@link Call}.\n   */\n  private _status: Call.State = Call.State.Pending;\n\n  /**\n   * Whether the {@link Call} has been connected. Used to determine if we are reconnected.\n   */\n  private _wasConnected: boolean = false;\n\n  /**\n   * @constructor\n   * @private\n   * @param config - Mandatory configuration options\n   * @param [options] - Optional settings\n   */\n  constructor(config: Call.Config, options?: Call.Options) {\n    super();\n\n    this._isUnifiedPlanDefault = config.isUnifiedPlanDefault;\n    this._soundcache = config.soundcache;\n\n    if (typeof config.onIgnore === 'function') {\n      this._onIgnore = config.onIgnore;\n    }\n\n    const message = options && options.twimlParams || { };\n    this.customParameters = new Map(\n      Object.entries(message).map(([key, val]: [string, any]): [string, string] => [key, String(val)]));\n\n    Object.assign(this._options, options);\n\n    if (this._options.callParameters) {\n      this.parameters = this._options.callParameters;\n    }\n\n    if (this._options.reconnectToken) {\n      this._signalingReconnectToken = this._options.reconnectToken;\n    }\n\n    this._direction = this.parameters.CallSid ? Call.CallDirection.Incoming : Call.CallDirection.Outgoing;\n\n    if (this._direction === Call.CallDirection.Incoming && this.parameters) {\n      this.callerInfo = this.parameters.StirStatus\n        ? { isVerified: this.parameters.StirStatus === 'TN-Validation-Passed-A' }\n        : null;\n    } else {\n      this.callerInfo = null;\n    }\n\n    this._mediaReconnectBackoff = Backoff.exponential(BACKOFF_CONFIG);\n    this._mediaReconnectBackoff.on('ready', () => this._mediaHandler.iceRestart());\n\n    // temporary call sid to be used for outgoing calls\n    this.outboundConnectionId = generateTempCallSid();\n\n    const publisher = this._publisher = config.publisher;\n\n    if (this._direction === Call.CallDirection.Incoming) {\n      publisher.info('connection', 'incoming', null, this);\n    } else {\n      publisher.info('connection', 'outgoing', { preflight: this._options.preflight }, this);\n    }\n\n    const monitor = this._monitor = new (this._options.StatsMonitor || StatsMonitor)();\n    monitor.on('sample', this._onRTCSample);\n\n    // First 20 seconds or so are choppy, so let's not bother with these warnings.\n    monitor.disableWarnings();\n    setTimeout(() => monitor.enableWarnings(), METRICS_DELAY);\n\n    monitor.on('warning', (data: RTCWarning, wasCleared?: boolean) => {\n      if (data.name === 'bytesSent' || data.name === 'bytesReceived') {\n        this._onMediaFailure(Call.MediaFailure.LowBytes);\n      }\n      this._reemitWarning(data, wasCleared);\n    });\n    monitor.on('warning-cleared', (data: RTCWarning) => {\n      this._reemitWarningCleared(data);\n    });\n\n    this._mediaHandler = new (this._options.MediaHandler)\n      (config.audioHelper, config.pstream, config.getUserMedia, {\n        codecPreferences: this._options.codecPreferences,\n        dscp: this._options.dscp,\n        forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n        isUnifiedPlan: this._isUnifiedPlanDefault,\n        maxAverageBitrate: this._options.maxAverageBitrate,\n        preflight: this._options.preflight,\n      });\n\n    this.on('volume', (inputVolume: number, outputVolume: number): void => {\n      this._inputVolumeStreak = this._checkVolume(\n        inputVolume, this._inputVolumeStreak, this._latestInputVolume, 'input');\n      this._outputVolumeStreak = this._checkVolume(\n        outputVolume, this._outputVolumeStreak, this._latestOutputVolume, 'output');\n      this._latestInputVolume = inputVolume;\n      this._latestOutputVolume = outputVolume;\n    });\n\n    this._mediaHandler.onvolume = (inputVolume: number, outputVolume: number,\n                                   internalInputVolume: number, internalOutputVolume: number) => {\n      // (rrowland) These values mock the 0 -> 32767 format used by legacy getStats. We should look into\n      // migrating to a newer standard, either 0.0 -> linear or -127 to 0 in dB, matching the range\n      // chosen below.\n      monitor.addVolumes((internalInputVolume / 255) * 32767, (internalOutputVolume / 255) * 32767);\n\n      // (rrowland) 0.0 -> 1.0 linear\n      this.emit('volume', inputVolume, outputVolume);\n    };\n\n    this._mediaHandler.ondtlstransportstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'dtls-transport-state', state, null, this);\n    };\n\n    this._mediaHandler.onpcconnectionstatechange = (state: string): void => {\n      let level = 'debug';\n      const dtlsTransport = this._mediaHandler.getRTCDtlsTransport();\n\n      if (state === 'failed') {\n        level = dtlsTransport && dtlsTransport.state === 'failed' ? 'error' : 'warning';\n      }\n      this._publisher.post(level, 'pc-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicecandidate = (candidate: RTCIceCandidate): void => {\n      const payload = new IceCandidate(candidate).toPayload();\n      this._publisher.debug('ice-candidate', 'ice-candidate', payload, this);\n    };\n\n    this._mediaHandler.onselectedcandidatepairchange = (pair: RTCIceCandidatePair): void => {\n      const localCandidatePayload = new IceCandidate(pair.local).toPayload();\n      const remoteCandidatePayload = new IceCandidate(pair.remote, true).toPayload();\n\n      this._publisher.debug('ice-candidate', 'selected-ice-candidate-pair', {\n        local_candidate: localCandidatePayload,\n        remote_candidate: remoteCandidatePayload,\n      }, this);\n    };\n\n    this._mediaHandler.oniceconnectionstatechange = (state: string): void => {\n      const level = state === 'failed' ? 'error' : 'debug';\n      this._publisher.post(level, 'ice-connection-state', state, null, this);\n    };\n\n    this._mediaHandler.onicegatheringfailure = (type: Call.IceGatheringFailureReason): void => {\n      this._publisher.warn('ice-gathering-state', type, null, this);\n      this._onMediaFailure(Call.MediaFailure.IceGatheringFailed);\n    };\n\n    this._mediaHandler.onicegatheringstatechange = (state: string): void => {\n      this._publisher.debug('ice-gathering-state', state, null, this);\n    };\n\n    this._mediaHandler.onsignalingstatechange = (state: string): void => {\n      this._publisher.debug('signaling-state', state, null, this);\n    };\n\n    this._mediaHandler.ondisconnected = (msg: string): void => {\n      this._log.info(msg);\n      this._publisher.warn('network-quality-warning-raised', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this.emit('warning', 'ice-connectivity-lost');\n\n      this._onMediaFailure(Call.MediaFailure.ConnectionDisconnected);\n    };\n\n    this._mediaHandler.onfailed = (msg: string): void => {\n      this._onMediaFailure(Call.MediaFailure.ConnectionFailed);\n    };\n\n    this._mediaHandler.onconnected = (): void => {\n      // First time _mediaHandler is connected, but ICE Gathering issued an ICE restart and succeeded.\n      if (this._status === Call.State.Reconnecting) {\n        this._onMediaReconnected();\n      }\n    };\n\n    this._mediaHandler.onreconnected = (msg: string): void => {\n      this._log.info(msg);\n      this._publisher.info('network-quality-warning-cleared', 'ice-connectivity-lost', {\n        message: msg,\n      }, this);\n      this.emit('warning-cleared', 'ice-connectivity-lost');\n      this._onMediaReconnected();\n    };\n\n    this._mediaHandler.onerror = (e: any): void => {\n      if (e.disconnect === true) {\n        this._disconnect(e.info && e.info.message);\n      }\n\n      const error = e.info.twilioError || new GeneralErrors.UnknownError(e.info.message);\n      this._log.error('Received an error from MediaStream:', e);\n      this.emit('error', error);\n    };\n\n    this._mediaHandler.onopen = () => {\n      // NOTE(mroberts): While this may have been happening in previous\n      // versions of Chrome, since Chrome 45 we have seen the\n      // PeerConnection's onsignalingstatechange handler invoked multiple\n      // times in the same signalingState 'stable'. When this happens, we\n      // invoke this onopen function. If we invoke it twice without checking\n      // for _status 'open', we'd accidentally close the PeerConnection.\n      //\n      // See <https://code.google.com/p/webrtc/issues/detail?id=4996>.\n      if (this._status === Call.State.Open || this._status === Call.State.Reconnecting) {\n        return;\n      } else if (this._status === Call.State.Ringing || this._status === Call.State.Connecting) {\n        this.mute(false);\n        this._mediaStatus = Call.State.Open;\n        this._maybeTransitionToOpen();\n      } else {\n        // call was probably canceled sometime before this\n        this._mediaHandler.close();\n      }\n    };\n\n    this._mediaHandler.onclose = () => {\n      this._status = Call.State.Closed;\n      if (this._options.shouldPlayDisconnect && this._options.shouldPlayDisconnect()\n        // Don't play disconnect sound if this was from a cancel event. i.e. the call\n        // was ignored or hung up even before it was answered.\n        && !this._isCancelled) {\n\n        this._soundcache.get(Device.SoundName.Disconnect).play();\n      }\n\n      monitor.disable();\n      this._publishMetrics();\n\n      if (!this._isCancelled) {\n        // tslint:disable no-console\n        this.emit('disconnect', this);\n      }\n    };\n\n    this._pstream = config.pstream;\n    this._pstream.on('cancel', this._onCancel);\n    this._pstream.on('ringing', this._onRinging);\n    this._pstream.on('transportClose', this._onTransportClose);\n    this._pstream.on('connected', this._onConnected);\n\n    this.on('error', error => {\n      this._publisher.error('connection', 'error', {\n        code: error.code, message: error.message,\n      }, this);\n\n      if (this._pstream && this._pstream.status === 'disconnected') {\n        this._cleanupEventListeners();\n      }\n    });\n\n    this.on('disconnect', () => {\n      this._cleanupEventListeners();\n    });\n  }\n\n  /**\n   * Set the audio input tracks from a given stream.\n   * @param stream\n   * @private\n   */\n  _setInputTracksFromStream(stream: MediaStream | null): Promise<void> {\n    return this._mediaHandler.setInputTracksFromStream(stream);\n  }\n\n  /**\n   * Set the audio output sink IDs.\n   * @param sinkIds\n   * @private\n   */\n  _setSinkIds(sinkIds: string[]): Promise<void> {\n    return this._mediaHandler._setSinkIds(sinkIds);\n  }\n\n  /**\n   * Accept the incoming {@link Call}.\n   * @param [options]\n   */\n  accept(options?: Call.AcceptOptions): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    options = options || { };\n    const rtcConfiguration = options.rtcConfiguration || this._options.rtcConfiguration;\n    const rtcConstraints = options.rtcConstraints || this._options.rtcConstraints || { };\n    const audioConstraints = rtcConstraints.audio || { audio: true };\n\n    this._status = Call.State.Connecting;\n\n    const connect = () => {\n      if (this._status !== Call.State.Connecting) {\n        // call must have been canceled\n        this._cleanupEventListeners();\n        this._mediaHandler.close();\n        return;\n      }\n\n      const onAnswer = (pc: RTCPeerConnection, reconnectToken?: string) => {\n        // Report that the call was answered, and directionality\n        const eventName = this._direction === Call.CallDirection.Incoming\n          ? 'accepted-by-local'\n          : 'accepted-by-remote';\n        this._publisher.info('connection', eventName, null, this);\n\n        if (typeof reconnectToken === 'string') {\n          this._signalingReconnectToken = reconnectToken;\n        }\n\n        // Report the preferred codec and params as they appear in the SDP\n        const { codecName, codecParams } = getPreferredCodecInfo(this._mediaHandler.version.getSDP());\n        this._publisher.info('settings', 'codec', {\n          codec_params: codecParams,\n          selected_codec: codecName,\n        }, this);\n\n        // Enable RTC monitoring\n        this._monitor.enable(pc);\n      };\n\n      const sinkIds = typeof this._options.getSinkIds === 'function' && this._options.getSinkIds();\n      if (Array.isArray(sinkIds)) {\n        this._mediaHandler._setSinkIds(sinkIds).catch(() => {\n          // (rrowland) We don't want this to throw to console since the customer\n          // can't control this. This will most commonly be rejected on browsers\n          // that don't support setting sink IDs.\n        });\n      }\n\n      this._pstream.addListener('hangup', this._onHangup);\n\n      if (this._direction === Call.CallDirection.Incoming) {\n        this._isAnswered = true;\n        this._pstream.on('answer', this._onAnswer.bind(this));\n        this._mediaHandler.answerIncomingCall(this.parameters.CallSid, this._options.offerSdp,\n          rtcConstraints, rtcConfiguration, onAnswer);\n      } else {\n        const params = Array.from(this.customParameters.entries()).map(pair =>\n         `${encodeURIComponent(pair[0])}=${encodeURIComponent(pair[1])}`).join('&');\n        this._pstream.on('answer', this._onAnswer.bind(this));\n        this._mediaHandler.makeOutgoingCall(this._pstream.token, params, this.outboundConnectionId,\n          rtcConstraints, rtcConfiguration, onAnswer);\n      }\n    };\n\n    if (this._options.beforeAccept) {\n      this._options.beforeAccept(this);\n    }\n\n    const inputStream = typeof this._options.getInputStream === 'function' && this._options.getInputStream();\n\n    const promise = inputStream\n      ? this._mediaHandler.setInputTracksFromStream(inputStream)\n      : this._mediaHandler.openWithConstraints(audioConstraints);\n\n    promise.then(() => {\n      this._publisher.info('get-user-media', 'succeeded', {\n        data: { audioConstraints },\n      }, this);\n\n      connect();\n    }, (error: Record<string, any>) => {\n      let twilioError;\n\n      if (error.code === 31208\n        || ['PermissionDeniedError', 'NotAllowedError'].indexOf(error.name) !== -1) {\n        twilioError = new UserMediaErrors.PermissionDeniedError();\n        this._publisher.error('get-user-media', 'denied', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      } else {\n        twilioError = new UserMediaErrors.AcquisitionFailedError();\n\n        this._publisher.error('get-user-media', 'failed', {\n          data: {\n            audioConstraints,\n            error,\n          },\n        }, this);\n      }\n\n      this._disconnect();\n      this.emit('error', twilioError);\n    });\n  }\n\n  /**\n   * Disconnect from the {@link Call}.\n   */\n  disconnect(): void {\n    this._disconnect();\n  }\n\n  /**\n   * Get the local MediaStream, if set.\n   */\n  getLocalStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler.stream;\n  }\n\n  /**\n   * Get the remote MediaStream, if set.\n   */\n  getRemoteStream(): MediaStream | undefined {\n    return this._mediaHandler && this._mediaHandler._remoteStream;\n  }\n\n  /**\n   * Ignore the incoming {@link Call}.\n   */\n  ignore(): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._status = Call.State.Closed;\n    this._mediaHandler.ignore(this.parameters.CallSid);\n    this._publisher.info('connection', 'ignored-by-local', null, this);\n\n    if (this._onIgnore) {\n      this._onIgnore();\n    }\n  }\n\n  /**\n   * Check whether call is muted\n   */\n  isMuted(): boolean {\n    return this._mediaHandler.isMuted;\n  }\n\n  /**\n   * Mute incoming audio.\n   * @param shouldMute - Whether the incoming audio should be muted. Defaults to true.\n   */\n  mute(shouldMute: boolean = true): void {\n    const wasMuted = this._mediaHandler.isMuted;\n    this._mediaHandler.mute(shouldMute);\n\n    const isMuted = this._mediaHandler.isMuted;\n    if (wasMuted !== isMuted) {\n      this._publisher.info('connection', isMuted ? 'muted' : 'unmuted', null, this);\n      this.emit('mute', isMuted, this);\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has given call quality feedback. Called without a score, this\n   *   will report that the customer declined to give feedback.\n   * @param score - The end-user's rating of the call; an\n   *   integer 1 through 5. Or undefined if the user declined to give\n   *   feedback.\n   * @param issue - The primary issue the end user\n   *   experienced on the call. Can be: ['one-way-audio', 'choppy-audio',\n   *   'dropped-call', 'audio-latency', 'noisy-call', 'echo']\n   */\n  postFeedback(score?: Call.FeedbackScore, issue?: Call.FeedbackIssue): Promise<void> {\n    if (typeof score === 'undefined' || score === null) {\n      return this._postFeedbackDeclined();\n    }\n\n    if (!Object.values(Call.FeedbackScore).includes(score)) {\n      throw new InvalidArgumentError(`Feedback score must be one of: ${Object.values(Call.FeedbackScore)}`);\n    }\n\n    if (typeof issue !== 'undefined' && issue !== null && !Object.values(Call.FeedbackIssue).includes(issue)) {\n      throw new InvalidArgumentError(`Feedback issue must be one of: ${Object.values(Call.FeedbackIssue)}`);\n    }\n\n    return this._publisher.info('feedback', 'received', {\n      issue_name: issue,\n      quality_score: score,\n    }, this, true);\n  }\n\n  /**\n   * Reject the incoming {@link Call}.\n   */\n  reject(): void {\n    if (this._status !== Call.State.Pending) {\n      return;\n    }\n\n    this._pstream.reject(this.parameters.CallSid);\n    this._status = Call.State.Closed;\n    this.emit('reject');\n    this._mediaHandler.reject(this.parameters.CallSid);\n    this._publisher.info('connection', 'rejected-by-local', null, this);\n  }\n\n  /**\n   * Send a string of digits.\n   * @param digits\n   */\n  sendDigits(digits: string): void {\n    if (digits.match(/[^0-9*#w]/)) {\n      throw new InvalidArgumentError('Illegal character passed into sendDigits');\n    }\n\n    const sequence: string[] = [];\n    digits.split('').forEach((digit: string) => {\n      let dtmf = (digit !== 'w') ? `dtmf${digit}` : '';\n      if (dtmf === 'dtmf*') { dtmf = 'dtmfs'; }\n      if (dtmf === 'dtmf#') { dtmf = 'dtmfh'; }\n      sequence.push(dtmf);\n    });\n\n    // Binds soundCache to be used in recursion until all digits have been played.\n    (function playNextDigit(soundCache, dialtonePlayer) {\n      const digit: string | undefined = sequence.shift();\n\n      if (digit) {\n        if (dialtonePlayer) {\n          dialtonePlayer.play(digit);\n        } else {\n          soundCache.get(digit as Device.SoundName).play();\n        }\n      }\n\n      if (sequence.length) {\n        setTimeout(playNextDigit.bind(null, soundCache), 200);\n      }\n    })(this._soundcache, this._options.dialtonePlayer);\n\n    const dtmfSender = this._mediaHandler.getOrCreateDTMFSender();\n\n    function insertDTMF(dtmfs: string[]) {\n      if (!dtmfs.length) { return; }\n      const dtmf: string | undefined = dtmfs.shift();\n\n      if (dtmf && dtmf.length) {\n        dtmfSender.insertDTMF(dtmf, DTMF_TONE_DURATION, DTMF_INTER_TONE_GAP);\n      }\n\n      setTimeout(insertDTMF.bind(null, dtmfs), DTMF_PAUSE_DURATION);\n    }\n\n    if (dtmfSender) {\n      if (!('canInsertDTMF' in dtmfSender) || dtmfSender.canInsertDTMF) {\n        this._log.info('Sending digits using RTCDTMFSender');\n        // NOTE(mroberts): We can't just map 'w' to ',' since\n        // RTCDTMFSender's pause duration is 2 s and Twilio's is more\n        // like 500 ms. Instead, we will fudge it with setTimeout.\n        insertDTMF(digits.split('w'));\n        return;\n      }\n\n      this._log.info('RTCDTMFSender cannot insert DTMF');\n    }\n\n    // send pstream message to send DTMF\n    this._log.info('Sending digits over PStream');\n\n    if (this._pstream !== null && this._pstream.status !== 'disconnected') {\n      this._pstream.dtmf(this.parameters.CallSid, digits);\n    } else {\n      const error = new GeneralErrors.ConnectionError('Could not send DTMF: Signaling channel is disconnected');\n      this.emit('error', error);\n    }\n  }\n\n  /**\n   * Get the current {@link Call} status.\n   */\n  status(): Call.State {\n    return this._status;\n  }\n\n  /**\n   * String representation of {@link Call} instance.\n   * @private\n   */\n  toString = () => '[Twilio.Call instance]';\n\n  /**\n   * Check the volume passed, emitting a warning if one way audio is detected or cleared.\n   * @param currentVolume - The current volume for this direction\n   * @param streakFieldName - The name of the field on the {@link Call} object that tracks how many times the\n   *   current value has been repeated consecutively.\n   * @param lastValueFieldName - The name of the field on the {@link Call} object that tracks the most recent\n   *   volume for this direction\n   * @param direction - The directionality of this audio track, either 'input' or 'output'\n   * @returns The current streak; how many times in a row the same value has been polled.\n   */\n  private _checkVolume(currentVolume: number, currentStreak: number,\n                       lastValue: number, direction: 'input'|'output'): number {\n    const wasWarningRaised: boolean = currentStreak >= 10;\n    let newStreak: number = 0;\n\n    if (lastValue === currentVolume) {\n      newStreak = currentStreak;\n    }\n\n    if (newStreak >= 10) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, false);\n    } else if (wasWarningRaised) {\n      this._emitWarning('audio-level-', `constant-audio-${direction}-level`, 10, newStreak, true);\n    }\n\n    return newStreak;\n  }\n\n  /**\n   * Clean up event listeners.\n   */\n  private _cleanupEventListeners(): void {\n    const cleanup = () => {\n      if (!this._pstream) { return; }\n\n      this._pstream.removeListener('answer', this._onAnswer);\n      this._pstream.removeListener('cancel', this._onCancel);\n      this._pstream.removeListener('hangup', this._onHangup);\n      this._pstream.removeListener('ringing', this._onRinging);\n      this._pstream.removeListener('transportClose', this._onTransportClose);\n      this._pstream.removeListener('connected', this._onConnected);\n    };\n\n    // This is kind of a hack, but it lets us avoid rewriting more code.\n    // Basically, there's a sequencing problem with the way PeerConnection raises\n    // the\n    //\n    //   Cannot establish call. SDK is disconnected\n    //\n    // error in Call#accept. It calls PeerConnection#onerror, which emits\n    // the error event on Call. An error handler on Call then calls\n    // cleanupEventListeners, but then control returns to Call#accept. It's\n    // at this point that we add a listener for the answer event that never gets\n    // removed. setTimeout will allow us to rerun cleanup again, _after_\n    // Call#accept returns.\n    cleanup();\n    setTimeout(cleanup, 0);\n  }\n\n  /**\n   * Create the payload wrapper for a batch of metrics to be sent to Insights.\n   */\n  private _createMetricPayload(): Partial<Record<string, string|boolean>> {\n    const payload: Partial<Record<string, string|boolean>> = {\n      call_sid: this.parameters.CallSid,\n      dscp: !!this._options.dscp,\n      sdk_version: C.RELEASE_VERSION,\n      selected_region: this._options.selectedRegion,\n    };\n\n    if (this._options.gateway) {\n      payload.gateway = this._options.gateway;\n    }\n\n    if (this._options.region) {\n      payload.region = this._options.region;\n    }\n\n    payload.direction = this._direction;\n    return payload;\n  }\n\n  /**\n   * Disconnect the {@link Call}.\n   * @param message - A message explaining why the {@link Call} is being disconnected.\n   * @param wasRemote - Whether the disconnect was triggered locally or remotely.\n   */\n  private _disconnect(message?: string | null, wasRemote?: boolean): void {\n    message = typeof message === 'string' ? message : null;\n\n    if (this._status !== Call.State.Open\n        && this._status !== Call.State.Connecting\n        && this._status !== Call.State.Reconnecting\n        && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    this._log.info('Disconnecting...');\n\n    // send pstream hangup message\n    if (this._pstream !== null && this._pstream.status !== 'disconnected' && this._shouldSendHangup) {\n      const callsid: string | undefined = this.parameters.CallSid || this.outboundConnectionId;\n      if (callsid) {\n        this._pstream.hangup(callsid, message);\n      }\n    }\n\n    this._cleanupEventListeners();\n    this._mediaHandler.close();\n\n    if (!wasRemote) {\n      this._publisher.info('connection', 'disconnected-by-local', null, this);\n    }\n  }\n\n  private _emitWarning = (groupPrefix: string, warningName: string, threshold: number,\n                          value: number|number[], wasCleared?: boolean, warningData?: RTCWarning): void => {\n    const groupSuffix = wasCleared ? '-cleared' : '-raised';\n    const groupName = `${groupPrefix}warning${groupSuffix}`;\n\n    // Ignore constant input if the Call is muted (Expected)\n    if (warningName === 'constant-audio-input-level' && this.isMuted()) {\n      return;\n    }\n\n    let level = wasCleared ? 'info' : 'warning';\n\n    // Avoid throwing false positives as warnings until we refactor volume metrics\n    if (warningName === 'constant-audio-output-level') {\n      level = 'info';\n    }\n\n    const payloadData: Record<string, any> = { threshold };\n\n    if (value) {\n      if (value instanceof Array) {\n        payloadData.values = value.map((val: any) => {\n          if (typeof val === 'number') {\n            return Math.round(val * 100) / 100;\n          }\n\n          return value;\n        });\n      } else {\n        payloadData.value = value;\n      }\n    }\n\n    this._publisher.post(level, groupName, warningName, { data: payloadData }, this);\n\n    if (warningName !== 'constant-audio-output-level') {\n      const emitName = wasCleared ? 'warning-cleared' : 'warning';\n      this.emit(emitName, warningName, warningData && !wasCleared ? warningData : null);\n    }\n  }\n\n  /**\n   * Transition to {@link CallStatus.Open} if criteria is met.\n   */\n  private _maybeTransitionToOpen(): void {\n    const wasConnected = this._wasConnected;\n    if (this._isAnswered) {\n      this._onSignalingReconnected();\n      this._signalingStatus = Call.State.Open;\n      if (this._mediaHandler && this._mediaHandler.status === 'open') {\n        this._status = Call.State.Open;\n        if (!this._wasConnected) {\n          this._wasConnected = true;\n          this.emit('accept', this);\n        }\n      }\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is answered.\n   * @param payload\n   */\n  private _onAnswer = (payload: Record<string, any>): void => {\n    if (typeof payload.reconnect === 'string') {\n      this._signalingReconnectToken = payload.reconnect;\n    }\n\n    // answerOnBridge=false will send a 183 which we need to catch in _onRinging when\n    // the enableRingingState flag is disabled. In that case, we will receive a 200 after\n    // the callee accepts the call firing a second `accept` event if we don't\n    // short circuit here.\n    if (this._isAnswered && this._status !== Call.State.Reconnecting) {\n      return;\n    }\n\n    this._setCallSid(payload);\n    this._isAnswered = true;\n    this._maybeTransitionToOpen();\n  }\n\n  /**\n   * Called when the {@link Call} is cancelled.\n   * @param payload\n   */\n  private _onCancel = (payload: Record<string, any>): void => {\n    // (rrowland) Is this check necessary? Verify, and if so move to pstream / VSP module.\n    const callsid = payload.callsid;\n    if (this.parameters.CallSid === callsid) {\n      this._isCancelled = true;\n      this._publisher.info('connection', 'cancel', null, this);\n      this._cleanupEventListeners();\n      this._mediaHandler.close();\n\n      this._status = Call.State.Closed;\n      this.emit('cancel');\n      this._pstream.removeListener('cancel', this._onCancel);\n    }\n  }\n\n  /**\n   * Called when we receive a connected event from pstream.\n   * Re-emits the event.\n   */\n  private _onConnected = (): void => {\n    this._log.info('Received connected from pstream');\n    if (this._signalingReconnectToken) {\n      this._pstream.reconnect(\n        this._mediaHandler.version.getSDP(),\n        this.parameters.CallSid,\n        this._signalingReconnectToken,\n      );\n    }\n  }\n\n  /**\n   * Called when the {@link Call} is hung up.\n   * @param payload\n   */\n  private _onHangup = (payload: Record<string, any>): void => {\n    if (this.status() === Call.State.Closed) {\n      return;\n    }\n\n    /**\n     *  see if callsid passed in message matches either callsid or outbound id\n     *  call should always have either callsid or outbound id\n     *  if no callsid passed hangup anyways\n     */\n    if (payload.callsid && (this.parameters.CallSid || this.outboundConnectionId)) {\n      if (payload.callsid !== this.parameters.CallSid\n          && payload.callsid !== this.outboundConnectionId) {\n        return;\n      }\n    } else if (payload.callsid) {\n      // hangup is for another call\n      return;\n    }\n\n    this._log.info('Received HANGUP from gateway');\n    if (payload.error) {\n      const error = new GeneralErrors.ConnectionError('Error sent from gateway in HANGUP');\n      this._log.error('Received an error from the gateway:', error);\n      this.emit('error', error);\n    }\n    this._shouldSendHangup = false;\n    this._publisher.info('connection', 'disconnected-by-remote', null, this);\n    this._disconnect(null, true);\n    this._cleanupEventListeners();\n  }\n\n  /**\n   * Called when there is a media failure.\n   * Manages all media-related states and takes action base on the states\n   * @param type - Type of media failure\n   */\n  private _onMediaFailure = (type: Call.MediaFailure): void => {\n    const {\n      ConnectionDisconnected, ConnectionFailed, IceGatheringFailed, LowBytes,\n    } = Call.MediaFailure;\n\n    // These types signifies the end of a single ICE cycle\n    const isEndOfIceCycle = type === ConnectionFailed || type === IceGatheringFailed;\n\n    // All browsers except chrome doesn't update pc.iceConnectionState and pc.connectionState\n    // after issuing an ICE Restart, which we use to determine if ICE Restart is complete.\n    // Since we cannot detect if ICE Restart is complete, we will not retry.\n    if (!isChrome(window, window.navigator) && type === ConnectionFailed) {\n      return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n    }\n\n    // Ignore subsequent requests if ice restart is in progress\n    if (this._mediaStatus === Call.State.Reconnecting) {\n\n      // This is a retry. Previous ICE Restart failed\n      if (isEndOfIceCycle) {\n\n        // We already exceeded max retry time.\n        if (Date.now() - this._mediaReconnectStartTime > BACKOFF_CONFIG.maxDelay) {\n          this._log.info('Exceeded max ICE retries');\n          return this._mediaHandler.onerror(MEDIA_DISCONNECT_ERROR);\n        }\n\n        // Issue ICE restart with backoff\n        try {\n          this._mediaReconnectBackoff.backoff();\n        } catch (error) {\n          // Catch and ignore 'Backoff in progress.' errors. If a backoff is\n          // ongoing and we try to start another one, there shouldn't be a\n          // problem.\n          if (!(error.message && error.message === 'Backoff in progress.')) {\n            throw error;\n          }\n        }\n      }\n\n      return;\n    }\n\n    const pc = this._mediaHandler.version.pc;\n    const isIceDisconnected = pc && pc.iceConnectionState === 'disconnected';\n    const hasLowBytesWarning = this._monitor.hasActiveWarning('bytesSent', 'min')\n      || this._monitor.hasActiveWarning('bytesReceived', 'min');\n\n    // Only certain conditions can trigger media reconnection\n    if ((type === LowBytes && isIceDisconnected)\n      || (type === ConnectionDisconnected && hasLowBytesWarning)\n      || isEndOfIceCycle) {\n\n      const mediaReconnectionError = new MediaErrors.ConnectionError('Media connection failed.');\n      this._log.warn('ICE Connection disconnected.');\n      this._publisher.warn('connection', 'error', mediaReconnectionError, this);\n      this._publisher.info('connection', 'reconnecting', null, this);\n\n      this._mediaReconnectStartTime = Date.now();\n      this._status = Call.State.Reconnecting;\n      this._mediaStatus = Call.State.Reconnecting;\n      this._mediaReconnectBackoff.reset();\n      this._mediaReconnectBackoff.backoff();\n\n      this.emit('reconnecting', mediaReconnectionError);\n    }\n  }\n\n  /**\n   * Called when media call is restored\n   */\n  private _onMediaReconnected = (): void => {\n    // Only trigger once.\n    // This can trigger on pc.onIceConnectionChange and pc.onConnectionChange.\n    if (this._mediaStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('ICE Connection reestablished.');\n    this._mediaStatus = Call.State.Open;\n\n    if (this._signalingStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * When we get a RINGING signal from PStream, update the {@link Call} status.\n   * @param payload\n   */\n  private _onRinging = (payload: Record<string, any>): void => {\n    this._setCallSid(payload);\n\n    // If we're not in 'connecting' or 'ringing' state, this event was received out of order.\n    if (this._status !== Call.State.Connecting && this._status !== Call.State.Ringing) {\n      return;\n    }\n\n    const hasEarlyMedia = !!payload.sdp;\n    this._status = Call.State.Ringing;\n    this._publisher.info('connection', 'outgoing-ringing', { hasEarlyMedia }, this);\n    this.emit('ringing', hasEarlyMedia);\n  }\n\n  /**\n   * Called each time StatsMonitor emits a sample.\n   * Emits stats event and batches the call stats metrics and sends them to Insights.\n   * @param sample\n   */\n  private _onRTCSample = (sample: RTCSample): void => {\n    const callMetrics: Call.CallMetrics = {\n      ...sample,\n      inputVolume: this._latestInputVolume,\n      outputVolume: this._latestOutputVolume,\n    };\n\n    this._codec = callMetrics.codecName;\n\n    this._metricsSamples.push(callMetrics);\n    if (this._metricsSamples.length >= METRICS_BATCH_SIZE) {\n      this._publishMetrics();\n    }\n\n    this.emit('sample', sample);\n  }\n\n  /**\n   * Called when signaling is restored\n   */\n  private _onSignalingReconnected = (): void => {\n    if (this._signalingStatus !== Call.State.Reconnecting) {\n      return;\n    }\n    this._log.info('Signaling Connection reestablished.');\n\n    this._signalingStatus = Call.State.Open;\n\n    if (this._mediaStatus === Call.State.Open) {\n      this._publisher.info('connection', 'reconnected', null, this);\n      this.emit('reconnected');\n      this._status = Call.State.Open;\n    }\n  }\n\n  /**\n   * Called when we receive a transportClose event from pstream.\n   * Re-emits the event.\n   */\n  private _onTransportClose = (): void => {\n    this._log.error('Received transportClose from pstream');\n    this.emit('transportClose');\n    if (this._signalingReconnectToken) {\n      this._status = Call.State.Reconnecting;\n      this._signalingStatus = Call.State.Reconnecting;\n      this.emit('reconnecting', new SignalingErrors.ConnectionDisconnected());\n    } else {\n      this._status = Call.State.Closed;\n      this._signalingStatus = Call.State.Closed;\n    }\n  }\n\n  /**\n   * Post an event to Endpoint Analytics indicating that the end user\n   *   has ignored a request for feedback.\n   */\n  private _postFeedbackDeclined(): Promise<void> {\n    return this._publisher.info('feedback', 'received-none', null, this, true);\n  }\n\n  /**\n   * Publish the current set of queued metrics samples to Insights.\n   */\n  private _publishMetrics(): void {\n    if (this._metricsSamples.length === 0) {\n      return;\n    }\n\n    this._publisher.postMetrics(\n      'quality-metrics-samples', 'metrics-sample', this._metricsSamples.splice(0), this._createMetricPayload(), this,\n    ).catch((e: any) => {\n      this._log.warn('Unable to post metrics to Insights. Received error:', e);\n    });\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning as a {@link Call}.warning or .warning-cleared event.\n   * @param warningData\n   * @param wasCleared - Whether this is a -cleared or -raised event.\n   */\n  private _reemitWarning = (warningData: Record<string, any>, wasCleared?: boolean): void => {\n    const groupPrefix = /^audio/.test(warningData.name) ?\n      'audio-level-' : 'network-quality-';\n\n    const warningPrefix = WARNING_PREFIXES[warningData.threshold.name];\n\n    /**\n     * NOTE: There are two \"packet-loss\" warnings: `high-packet-loss` and\n     * `high-packets-lost-fraction`, so in this case we need to use a different\n     * `WARNING_NAME` mapping.\n     */\n    let warningName: string | undefined;\n    if (warningData.name in MULTIPLE_THRESHOLD_WARNING_NAMES) {\n      warningName = MULTIPLE_THRESHOLD_WARNING_NAMES[warningData.name][warningData.threshold.name];\n    } else if (warningData.name in WARNING_NAMES) {\n      warningName = WARNING_NAMES[warningData.name];\n    }\n\n    const warning: string = warningPrefix + warningName;\n\n    this._emitWarning(groupPrefix, warning, warningData.threshold.value,\n                      warningData.values || warningData.value, wasCleared, warningData);\n  }\n\n  /**\n   * Re-emit an StatsMonitor warning-cleared as a .warning-cleared event.\n   * @param warningData\n   */\n  private _reemitWarningCleared = (warningData: Record<string, any>): void => {\n    this._reemitWarning(warningData, true);\n  }\n\n  /**\n   * Set the CallSid\n   * @param payload\n   */\n  private _setCallSid(payload: Record<string, string>): void {\n    const callSid = payload.callsid;\n    if (!callSid) { return; }\n\n    this.parameters.CallSid = callSid;\n    this._mediaHandler.callSid = callSid;\n  }\n}\n\nnamespace Call {\n  /**\n   * Emitted when the {@link Call} is accepted.\n   * @param call - The {@link Call}.\n   * @example `call.on('accept', call => { })`\n   * @event\n   */\n  declare function acceptEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} is canceled.\n   * @example `call.on('cancel', () => { })`\n   * @event\n   */\n  declare function cancelEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} is disconnected.\n   * @param call - The {@link Call}.\n   * @example `call.on('disconnect', call => { })`\n   * @event\n   */\n  declare function disconnectEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} receives an error.\n   * @param error\n   * @example `call.on('error', error => { })`\n   * @event\n   */\n  declare function errorEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when the {@link Call} is muted or unmuted.\n   * @param isMuted - Whether the {@link Call} is muted.\n   * @param call - The {@link Call}.\n   * @example `call.on('mute', (isMuted, call) => { })`\n   * @event\n   */\n  declare function muteEvent(isMuted: boolean, call: Call): void;\n\n  /**\n   * Emitted when the {@link Call} has regained media connectivity.\n   * @example `call.on('reconnected', () => { })`\n   * @event\n   */\n  declare function reconnectedEvent(): void;\n\n  /**\n   * Emitted when the {@link Call} has lost media connectivity and is reconnecting.\n   * @param error - The {@link TwilioError} that caused the media connectivity loss\n   * @example `call.on('reconnecting', error => { })`\n   * @event\n   */\n  declare function reconnectingEvent(error: TwilioError): void;\n\n  /**\n   * Emitted when the {@link Call} is rejected.\n   * @example `call.on('reject', () => { })`\n   * @event\n   */\n  declare function rejectEvent(): void;\n\n  /**\n   * Emitted every 50ms with the current input and output volumes, as a percentage of maximum\n   * volume, between -100dB and -30dB. Represented by a floating point number.\n   * @param inputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @param outputVolume - A floating point number between 0.0 and 1.0 inclusive.\n   * @example `call.on('volume', (inputVolume, outputVolume) => { })`\n   * @event\n   */\n  declare function volumeEvent(inputVolume: number, outputVolume: number): void;\n\n  /**\n   * Emitted when the {@link Call} gets a webrtc sample object.\n   * This event is published every second.\n   * @param sample\n   * @example `call.on('sample', sample => { })`\n   * @event\n   */\n  declare function sampleEvent(sample: RTCSample): void;\n\n  /**\n   * Possible states of the {@link Call}.\n   */\n  export enum State {\n    Closed = 'closed',\n    Connecting = 'connecting',\n    Open = 'open',\n    Pending = 'pending',\n    Reconnecting = 'reconnecting',\n    Ringing = 'ringing',\n  }\n\n  /**\n   * Different issues that may have been experienced during a call, that can be\n   * reported to Twilio Insights via {@link Call}.postFeedback().\n   */\n  export enum FeedbackIssue {\n    AudioLatency = 'audio-latency',\n    ChoppyAudio = 'choppy-audio',\n    DroppedCall = 'dropped-call',\n    Echo = 'echo',\n    NoisyCall = 'noisy-call',\n    OneWayAudio = 'one-way-audio',\n  }\n\n  /**\n   * A rating of call quality experienced during a call, to be reported to Twilio Insights\n   * via {@link Call}.postFeedback().\n   */\n  export enum FeedbackScore {\n    One = 1,\n    Two,\n    Three,\n    Four,\n    Five,\n  }\n\n  /**\n   * The directionality of the {@link Call}, whether incoming or outgoing.\n   */\n  export enum CallDirection {\n    Incoming = 'INCOMING',\n    Outgoing = 'OUTGOING',\n  }\n\n  /**\n   * Valid audio codecs to use for the media connection.\n   */\n  export enum Codec {\n    Opus = 'opus',\n    PCMU = 'pcmu',\n  }\n\n  /**\n   * Possible ICE Gathering failures\n   */\n  export enum IceGatheringFailureReason {\n    None = 'none',\n    Timeout = 'timeout',\n  }\n\n  /**\n   * Possible media failures\n   */\n  export enum MediaFailure {\n    ConnectionDisconnected = 'ConnectionDisconnected',\n    ConnectionFailed = 'ConnectionFailed',\n    IceGatheringFailed = 'IceGatheringFailed',\n    LowBytes = 'LowBytes',\n  }\n\n  /**\n   * Options to be used to acquire media tracks and connect media.\n   */\n  export interface AcceptOptions {\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * MediaStreamConstraints to pass to getUserMedia when making or accepting a Call.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n  }\n\n  /**\n   * A CallerInfo provides caller verification information.\n   */\n  export interface CallerInfo {\n    /**\n     * Whether or not the caller's phone number has been verified by\n     * Twilio using SHAKEN/STIR validation. True if the caller has\n     * been validated at level 'A', false if the caller has been\n     * verified at any lower level or has failed validation.\n     */\n    isVerified: boolean;\n  }\n\n  /**\n   * Mandatory config options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Config {\n    /**\n     * An AudioHelper instance to be used for input/output devices.\n     */\n    audioHelper: IAudioHelper;\n\n    /**\n     * A method to use for getUserMedia.\n     */\n    getUserMedia: (constraints: MediaStreamConstraints) => Promise<MediaStream>;\n\n    /**\n     * Whether or not the browser uses unified-plan SDP by default.\n     */\n    isUnifiedPlanDefault: boolean;\n\n    /**\n     * A function to be called after {@link Call.ignore} is called.\n     */\n    onIgnore: () => void;\n\n    /**\n     * The PStream instance to use for Twilio call signaling.\n     */\n    pstream: IPStream;\n\n    /**\n     * An EventPublisher instance to use for publishing events\n     */\n    publisher: IPublisher;\n\n    /**\n     * A Map of Sounds to play.\n     */\n    soundcache: Map<Device.SoundName, ISound>;\n  }\n\n  /**\n   * Options to be passed to the {@link Call} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * A method to call before Call.accept is processed.\n     */\n    beforeAccept?: (call: Call) => void;\n\n    /**\n     * Custom format context parameters associated with this call.\n     */\n    callParameters?: Record<string, string>;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Codec[];\n\n    /**\n     * A DialTone player, to play mock DTMF sounds.\n     */\n    dialtonePlayer?: DialtonePlayer;\n\n    /**\n     * Whether or not to enable DSCP.\n     */\n    dscp?: boolean;\n\n    /**\n     * Experimental feature.\n     * Force Chrome's ICE agent to use aggressive nomination when selecting a candidate pair.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * The gateway currently connected to.\n     */\n    gateway?: string;\n\n    /**\n     * A method that returns the current input MediaStream set on {@link Device}.\n     */\n    getInputStream?: () => MediaStream;\n\n    /**\n     * A method that returns the current SinkIDs set on {@link Device}.\n     */\n    getSinkIds?: () => string[];\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * Custom MediaHandler (PeerConnection) constructor.\n     */\n    MediaHandler?: IPeerConnection;\n\n    /**\n     * The offer SDP, if this is an incoming call.\n     */\n    offerSdp?: string | null;\n\n    /**\n     * Whether this is a preflight call or not\n     */\n    preflight?: boolean;\n\n    /**\n     * A reconnect token for the {@link Call}. Passed in for incoming {@link Calls}.\n     */\n    reconnectToken?: string;\n\n    /**\n     * The Region currently connected to.\n     */\n    region?: string;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * RTC Constraints to pass to getUserMedia when making or accepting a Call.\n     * The format of this object depends on browser.\n     */\n    rtcConstraints?: MediaStreamConstraints;\n\n    /**\n     * The region passed to {@link Device} on setup.\n     */\n    selectedRegion?: string;\n\n    /**\n     * Whether the disconnect sound should be played.\n     */\n    shouldPlayDisconnect?: () => boolean;\n\n    /**\n     * An override for the StatsMonitor dependency.\n     */\n    StatsMonitor?: new () => StatsMonitor;\n\n    /**\n     * TwiML params for the call. May be set for either outgoing or incoming calls.\n     */\n    twimlParams?: Record<string, any>;\n  }\n\n  /**\n   * Call metrics published to Insight Metrics.\n   * This include rtc samples and audio information.\n   * @private\n   */\n  export interface CallMetrics extends RTCSample {\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    inputVolume: number;\n\n    /**\n     * Percentage of maximum volume, between 0.0 to 1.0, representing -100 to -30 dB.\n     */\n    outputVolume: number;\n  }\n}\n\nfunction generateTempCallSid() {\n  return 'TJSxxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {\n    /* tslint:disable:no-bitwise */\n    const r = Math.random() * 16 | 0;\n    const v = c === 'x' ? r : (r & 0x3 | 0x8);\n    /* tslint:enable:no-bitwise */\n    return v.toString(16);\n  });\n}\n\nexport default Call;\n"]},"metadata":{},"sourceType":"script"}