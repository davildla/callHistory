{"ast":null,"code":"import { Grammar } from \"../grammar/grammar.js\";\nimport { URI } from \"../grammar/uri.js\";\nimport { DigestAuthentication } from \"../core/messages/digest-authentication.js\";\nimport { IncomingRequestMessage } from \"../core/messages/incoming-request-message.js\";\nimport { IncomingResponseMessage } from \"../core/messages/incoming-response-message.js\";\nimport { Levels } from \"../core/log/levels.js\";\nimport { LoggerFactory } from \"../core/log/logger-factory.js\";\nimport { Parser } from \"../core/messages/parser.js\";\nimport { UserAgentCore } from \"../core/user-agent-core/user-agent-core.js\";\nimport { createRandomToken, utf8Length } from \"../core/messages/utils.js\";\nimport { defaultSessionDescriptionHandlerFactory } from \"../platform/web/session-description-handler/session-description-handler-factory-default.js\";\nimport { Transport as WebTransport } from \"../platform/web/transport/transport.js\";\nimport { LIBRARY_VERSION } from \"../version.js\";\nimport { EmitterImpl } from \"./emitter.js\";\nimport { Invitation } from \"./invitation.js\";\nimport { Inviter } from \"./inviter.js\";\nimport { Message } from \"./message.js\";\nimport { Notification } from \"./notification.js\";\nimport { SIPExtension, UserAgentRegisteredOptionTags } from \"./user-agent-options.js\";\nimport { UserAgentState } from \"./user-agent-state.js\";\n/**\n * A user agent sends and receives requests using a `Transport`.\n *\n * @remarks\n * A user agent (UA) is associated with a user via the user's SIP address of record (AOR)\n * and acts on behalf of that user to send and receive SIP requests. The user agent can\n * register to receive incoming requests, as well as create and send outbound messages.\n * The user agent also maintains the Transport over which its signaling travels.\n *\n * @public\n */\n\nexport class UserAgent {\n  /**\n   * Constructs a new instance of the `UserAgent` class.\n   * @param options - Options bucket. See {@link UserAgentOptions} for details.\n   */\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    /** @internal */\n    this._publishers = {};\n    /** @internal */\n\n    this._registerers = {};\n    /** @internal */\n\n    this._sessions = {};\n    /** @internal */\n\n    this._subscriptions = {};\n    this._state = UserAgentState.Stopped; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // initialize delegate\n\n    this.delegate = options.delegate; // initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, UserAgent.defaultOptions()), {\n      sipjsId: createRandomToken(5)\n    }), {\n      uri: new URI(\"sip\", \"anonymous.\" + createRandomToken(6), \"anonymous.invalid\")\n    }), {\n      viaHost: createRandomToken(12) + \".invalid\"\n    }), UserAgent.stripUndefinedProperties(options)); // viaHost is hack\n\n    if (this.options.hackIpInContact) {\n      if (typeof this.options.hackIpInContact === \"boolean\" && this.options.hackIpInContact) {\n        const from = 1;\n        const to = 254;\n        const octet = Math.floor(Math.random() * (to - from + 1) + from); // random Test-Net IP (http://tools.ietf.org/html/rfc5735)\n\n        this.options.viaHost = \"192.0.2.\" + octet;\n      } else if (this.options.hackIpInContact) {\n        this.options.viaHost = this.options.hackIpInContact;\n      }\n    } // initialize logger & logger factory\n\n\n    this.loggerFactory = new LoggerFactory();\n    this.logger = this.loggerFactory.getLogger(\"sip.UserAgent\");\n    this.loggerFactory.builtinEnabled = this.options.logBuiltinEnabled;\n    this.loggerFactory.connector = this.options.logConnector;\n\n    switch (this.options.logLevel) {\n      case \"error\":\n        this.loggerFactory.level = Levels.error;\n        break;\n\n      case \"warn\":\n        this.loggerFactory.level = Levels.warn;\n        break;\n\n      case \"log\":\n        this.loggerFactory.level = Levels.log;\n        break;\n\n      case \"debug\":\n        this.loggerFactory.level = Levels.debug;\n        break;\n\n      default:\n        break;\n    }\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(key => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value = this.options[key];\n\n        switch (key) {\n          case \"uri\":\n          case \"sessionDescriptionHandlerFactory\":\n            this.logger.log(\"路 \" + key + \": \" + value);\n            break;\n\n          case \"authorizationPassword\":\n            this.logger.log(\"路 \" + key + \": \" + \"NOT SHOWN\");\n            break;\n\n          case \"transportConstructor\":\n            this.logger.log(\"路 \" + key + \": \" + value.name);\n            break;\n\n          default:\n            this.logger.log(\"路 \" + key + \": \" + JSON.stringify(value));\n        }\n      });\n    } // guard deprecated transport options (remove this in version 16.x)\n\n\n    if (this.options.transportOptions) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const optionsDeprecated = this.options.transportOptions;\n      const maxReconnectionAttemptsDeprecated = optionsDeprecated.maxReconnectionAttempts;\n      const reconnectionTimeoutDeprecated = optionsDeprecated.reconnectionTimeout;\n\n      if (maxReconnectionAttemptsDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"maxReconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      }\n\n      if (reconnectionTimeoutDeprecated !== undefined) {\n        const deprecatedMessage = `The transport option \"reconnectionTimeout\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n        this.logger.warn(deprecatedMessage);\n      } // hack\n\n\n      if (options.reconnectionDelay === undefined && reconnectionTimeoutDeprecated !== undefined) {\n        this.options.reconnectionDelay = reconnectionTimeoutDeprecated;\n      }\n\n      if (options.reconnectionAttempts === undefined && maxReconnectionAttemptsDeprecated !== undefined) {\n        this.options.reconnectionAttempts = maxReconnectionAttemptsDeprecated;\n      }\n    } // guard deprecated user agent options (remove this in version 16.x)\n\n\n    if (options.reconnectionDelay !== undefined) {\n      const deprecatedMessage = `The user agent option \"reconnectionDelay\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n      this.logger.warn(deprecatedMessage);\n    }\n\n    if (options.reconnectionAttempts !== undefined) {\n      const deprecatedMessage = `The user agent option \"reconnectionAttempts\" as has apparently been specified and has been deprecated. ` + \"It will no longer be available starting with SIP.js release 0.16.0. Please update accordingly.\";\n      this.logger.warn(deprecatedMessage);\n    } // Initialize Transport\n\n\n    this._transport = new this.options.transportConstructor(this.getLogger(\"sip.Transport\"), this.options.transportOptions);\n    this.initTransportCallbacks(); // Initialize Contact\n\n    this._contact = this.initContact(); // Set instance id\n\n    this._instanceId = this.options.instanceId ? this.options.instanceId : UserAgent.newUUID();\n\n    if (Grammar.parse(this._instanceId, \"uuid\") === -1) {\n      throw new Error(\"Invalid instanceId.\");\n    } // Initialize UserAgentCore\n\n\n    this._userAgentCore = this.initCore();\n  }\n  /**\n   * Create a URI instance from a string.\n   * @param uri - The string to parse.\n   *\n   * @remarks\n   * Returns undefined if the syntax of the URI is invalid.\n   * The syntax must conform to a SIP URI as defined in the RFC.\n   * 25 Augmented BNF for the SIP Protocol\n   * https://tools.ietf.org/html/rfc3261#section-25\n   *\n   * @example\n   * ```ts\n   * const uri = UserAgent.makeURI(\"sip:edgar@example.com\");\n   * ```\n   */\n\n\n  static makeURI(uri) {\n    return Grammar.URIParse(uri);\n  }\n  /** Default user agent options. */\n\n\n  static defaultOptions() {\n    return {\n      allowLegacyNotifications: false,\n      authorizationHa1: \"\",\n      authorizationPassword: \"\",\n      authorizationUsername: \"\",\n      delegate: {},\n      contactName: \"\",\n      contactParams: {\n        transport: \"ws\"\n      },\n      displayName: \"\",\n      forceRport: false,\n      gracefulShutdown: true,\n      hackAllowUnregisteredOptionTags: false,\n      hackIpInContact: false,\n      hackViaTcp: false,\n      instanceId: \"\",\n      instanceIdAlwaysAdded: false,\n      logBuiltinEnabled: true,\n      logConfiguration: true,\n      logConnector: () => {\n        /* noop */\n      },\n      logLevel: \"log\",\n      noAnswerTimeout: 60,\n      preloadedRouteSet: [],\n      reconnectionAttempts: 0,\n      reconnectionDelay: 4,\n      sendInitialProvisionalResponse: true,\n      sessionDescriptionHandlerFactory: defaultSessionDescriptionHandlerFactory(),\n      sessionDescriptionHandlerFactoryOptions: {},\n      sipExtension100rel: SIPExtension.Unsupported,\n      sipExtensionReplaces: SIPExtension.Unsupported,\n      sipExtensionExtraSupported: [],\n      sipjsId: \"\",\n      transportConstructor: WebTransport,\n      transportOptions: {},\n      uri: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n      userAgentString: \"SIP.js/\" + LIBRARY_VERSION,\n      viaHost: \"\"\n    };\n  } // http://stackoverflow.com/users/109538/broofa\n\n\n  static newUUID() {\n    const UUID = \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, c => {\n      const r = Math.floor(Math.random() * 16);\n      const v = c === \"x\" ? r : r % 4 + 8;\n      return v.toString(16);\n    });\n    return UUID;\n  }\n  /**\n   * Strip properties with undefined values from options.\n   * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n   * https://github.com/Microsoft/TypeScript/issues/13195\n   * @param options - Options to reduce\n   */\n\n\n  static stripUndefinedProperties(options) {\n    return Object.keys(options).reduce((object, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (options[key] !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        object[key] = options[key];\n      }\n\n      return object;\n    }, {});\n  }\n  /**\n   * User agent configuration.\n   */\n\n\n  get configuration() {\n    return this.options;\n  }\n  /**\n   * User agent contact.\n   */\n\n\n  get contact() {\n    return this._contact;\n  }\n  /**\n   * User agent instance id.\n   */\n\n\n  get instanceId() {\n    return this._instanceId;\n  }\n  /**\n   * User agent state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * User agent state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * User agent transport.\n   */\n\n\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * User agent core.\n   */\n\n\n  get userAgentCore() {\n    return this._userAgentCore;\n  }\n  /**\n   * The logger.\n   */\n\n\n  getLogger(category, label) {\n    return this.loggerFactory.getLogger(category, label);\n  }\n  /**\n   * The logger factory.\n   */\n\n\n  getLoggerFactory() {\n    return this.loggerFactory;\n  }\n  /**\n   * True if transport is connected.\n   */\n\n\n  isConnected() {\n    return this.transport.isConnected();\n  }\n  /**\n   * Reconnect the transport.\n   */\n\n\n  reconnect() {\n    if (this.state === UserAgentState.Stopped) {\n      return Promise.reject(new Error(\"User agent stopped.\"));\n    } // Make sure we don't call synchronously\n\n\n    return Promise.resolve().then(() => this.transport.connect());\n  }\n  /**\n   * Start the user agent.\n   *\n   * @remarks\n   * Resolves if transport connects, otherwise rejects.\n   * Calling `start()` after calling `stop()` will fail if `stop()` has yet to resolve.\n   *\n   * @example\n   * ```ts\n   * userAgent.start()\n   *   .then(() => {\n   *     // userAgent.isConnected() === true\n   *   })\n   *   .catch((error: Error) => {\n   *     // userAgent.isConnected() === false\n   *   });\n   * ```\n   */\n\n\n  start() {\n    if (this.state === UserAgentState.Started) {\n      this.logger.warn(`User agent already started`);\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Starting ${this.configuration.uri}`); // Transition state\n\n    this.transitionState(UserAgentState.Started);\n    return this.transport.connect();\n  }\n  /**\n   * Stop the user agent.\n   *\n   * @remarks\n   * Resolves when the user agent has completed a graceful shutdown.\n   * ```txt\n   * 1) Sessions terminate.\n   * 2) Registerers unregister.\n   * 3) Subscribers unsubscribe.\n   * 4) Publishers unpublish.\n   * 5) Transport disconnects.\n   * 6) User Agent Core resets.\n   * ```\n   * The user agent state transistions to stopped once these steps have been completed.\n   * Calling `start()` after calling `stop()` will fail if `stop()` has yet to resolve.\n   *\n   * NOTE: While this is a \"graceful shutdown\", it can also be very slow one if you\n   * are waiting for the returned Promise to resolve. The disposal of the clients and\n   * dialogs is done serially - waiting on one to finish before moving on to the next.\n   * This can be slow if there are lot of subscriptions to unsubscribe for example.\n   *\n   * THE SLOW PACE IS INTENTIONAL!\n   * While one could spin them all down in parallel, this could slam the remote server.\n   * It is bad practice to denial of service attack (DoS attack) servers!!!\n   * Moreover, production servers will automatically blacklist clients which send too\n   * many requests in too short a period of time - dropping any additional requests.\n   *\n   * If a different approach to disposing is needed, one can implement whatever is\n   * needed and execute that prior to calling `stop()`. Alternatively one may simply\n   * not wait for the Promise returned by `stop()` to complete.\n   */\n\n\n  async stop() {\n    if (this.state === UserAgentState.Stopped) {\n      this.logger.warn(`User agent already stopped`);\n      return Promise.resolve();\n    }\n\n    this.logger.log(`Stopping ${this.configuration.uri}`); // The default behavior is to cleanup dialogs and registrations. This is not that...\n\n    if (!this.options.gracefulShutdown) {\n      // Dispose of the transport (disconnecting)\n      this.logger.log(`Dispose of transport`);\n      this.transport.dispose().catch(error => {\n        this.logger.error(error.message);\n        throw error;\n      }); // Dispose of the user agent core (resetting)\n\n      this.logger.log(`Dispose of core`);\n      this.userAgentCore.dispose(); // Reset dialogs and registrations\n\n      this._publishers = {};\n      this._registerers = {};\n      this._sessions = {};\n      this._subscriptions = {};\n      this.transitionState(UserAgentState.Stopped);\n      return Promise.resolve();\n    } // Be careful here to use a local references as start() can be called\n    // again before we complete and we don't want to touch new clients\n    // and we don't want to step on the new instances (or vice versa).\n\n\n    const publishers = Object.assign({}, this._publishers);\n    const registerers = Object.assign({}, this._registerers);\n    const sessions = Object.assign({}, this._sessions);\n    const subscriptions = Object.assign({}, this._subscriptions);\n    const transport = this.transport;\n    const userAgentCore = this.userAgentCore; //\n    // At this point we have completed the state transition and everything\n    // following will effectively run async and MUST NOT cause any issues\n    // if UserAgent.start() is called while the following code continues.\n    //\n    // TODO: Minor optimization.\n    // The disposal in all cases involves, in part, sending messages which\n    // is not worth doing if the transport is not connected as we know attempting\n    // to send messages will be futile. But none of these disposal methods check\n    // if that's is the case and it would be easy for them to do so at this point.\n    // Dispose of Registerers\n\n    this.logger.log(`Dispose of registerers`);\n\n    for (const id in registerers) {\n      if (registerers[id]) {\n        await registerers[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._registerers[id];\n          throw error;\n        });\n      }\n    } // Dispose of Sessions\n\n\n    this.logger.log(`Dispose of sessions`);\n\n    for (const id in sessions) {\n      if (sessions[id]) {\n        await sessions[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._sessions[id];\n          throw error;\n        });\n      }\n    } // Dispose of Subscriptions\n\n\n    this.logger.log(`Dispose of subscriptions`);\n\n    for (const id in subscriptions) {\n      if (subscriptions[id]) {\n        await subscriptions[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._subscriptions[id];\n          throw error;\n        });\n      }\n    } // Dispose of Publishers\n\n\n    this.logger.log(`Dispose of publishers`);\n\n    for (const id in publishers) {\n      if (publishers[id]) {\n        await publishers[id].dispose().catch(error => {\n          this.logger.error(error.message);\n          delete this._publishers[id];\n          throw error;\n        });\n      }\n    } // Dispose of the transport (disconnecting)\n\n\n    this.logger.log(`Dispose of transport`);\n    await transport.dispose().catch(error => {\n      this.logger.error(error.message);\n      throw error;\n    }); // Dispose of the user agent core (resetting)\n\n    this.logger.log(`Dispose of core`);\n    userAgentCore.dispose(); // Transition state\n\n    this.transitionState(UserAgentState.Stopped);\n  }\n  /**\n   * Used to avoid circular references.\n   * @internal\n   */\n\n\n  _makeInviter(targetURI, options) {\n    return new Inviter(this, targetURI, options);\n  }\n  /**\n   * Attempt reconnection up to `maxReconnectionAttempts` times.\n   * @param reconnectionAttempt - Current attempt number.\n   */\n\n\n  attemptReconnection() {\n    let reconnectionAttempt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const reconnectionAttempts = this.options.reconnectionAttempts;\n    const reconnectionDelay = this.options.reconnectionDelay;\n\n    if (reconnectionAttempt > reconnectionAttempts) {\n      this.logger.log(`Maximum reconnection attempts reached`);\n      return;\n    }\n\n    this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - trying`);\n    setTimeout(() => {\n      this.reconnect().then(() => {\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - succeeded`);\n      }).catch(error => {\n        this.logger.error(error.message);\n        this.logger.log(`Reconnection attempt ${reconnectionAttempt} of ${reconnectionAttempts} - failed`);\n        this.attemptReconnection(++reconnectionAttempt);\n      });\n    }, reconnectionAttempt === 1 ? 0 : reconnectionDelay * 1000);\n  }\n  /**\n   * Initialize contact.\n   */\n\n\n  initContact() {\n    var _this = this;\n\n    const contactName = this.options.contactName !== \"\" ? this.options.contactName : createRandomToken(8);\n    const contactParams = this.options.contactParams;\n    const contact = {\n      pubGruu: undefined,\n      tempGruu: undefined,\n      uri: new URI(\"sip\", contactName, this.options.viaHost, undefined, contactParams),\n      toString: function () {\n        let contactToStringOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        const anonymous = contactToStringOptions.anonymous || false;\n        const outbound = contactToStringOptions.outbound || false;\n        const register = contactToStringOptions.register || false;\n        let contactString = \"<\"; // 3.3.  Using a GRUU\n        // Once a user agent obtains GRUUs from the registrar, it uses them in\n        // several ways.  First, it uses them as the contents of the Contact\n        // header field in non-REGISTER requests and responses that it emits\n        // (for example, an INVITE request and 200 OK response).\n        // https://datatracker.ietf.org/doc/html/rfc5627#section-3.3\n\n        if (anonymous) {\n          contactString += _this.contact.tempGruu || `sip:anonymous@anonymous.invalid;transport=${contactParams.transport ? contactParams.transport : \"ws\"}`;\n        } else if (register) {\n          contactString += _this.contact.uri;\n        } else {\n          contactString += _this.contact.pubGruu || _this.contact.uri;\n        }\n\n        if (outbound) {\n          contactString += \";ob\";\n        }\n\n        contactString += \">\";\n\n        if (_this.options.instanceIdAlwaysAdded) {\n          contactString += ';+sip.instance=\"<urn:uuid:' + _this._instanceId + '>\"';\n        }\n\n        return contactString;\n      }\n    };\n    return contact;\n  }\n  /**\n   * Initialize user agent core.\n   */\n\n\n  initCore() {\n    // supported options\n    let supportedOptionTags = [];\n    supportedOptionTags.push(\"outbound\"); // TODO: is this really supported?\n\n    if (this.options.sipExtension100rel === SIPExtension.Supported) {\n      supportedOptionTags.push(\"100rel\");\n    }\n\n    if (this.options.sipExtensionReplaces === SIPExtension.Supported) {\n      supportedOptionTags.push(\"replaces\");\n    }\n\n    if (this.options.sipExtensionExtraSupported) {\n      supportedOptionTags.push(...this.options.sipExtensionExtraSupported);\n    }\n\n    if (!this.options.hackAllowUnregisteredOptionTags) {\n      supportedOptionTags = supportedOptionTags.filter(optionTag => UserAgentRegisteredOptionTags[optionTag]);\n    }\n\n    supportedOptionTags = Array.from(new Set(supportedOptionTags)); // array of unique values\n    // FIXME: TODO: This was ported, but this is and was just plain broken.\n\n    const supportedOptionTagsResponse = supportedOptionTags.slice();\n\n    if (this.contact.pubGruu || this.contact.tempGruu) {\n      supportedOptionTagsResponse.push(\"gruu\");\n    } // core configuration\n\n\n    const userAgentCoreConfiguration = {\n      aor: this.options.uri,\n      contact: this.contact,\n      displayName: this.options.displayName,\n      loggerFactory: this.loggerFactory,\n      hackViaTcp: this.options.hackViaTcp,\n      routeSet: this.options.preloadedRouteSet,\n      supportedOptionTags,\n      supportedOptionTagsResponse,\n      sipjsId: this.options.sipjsId,\n      userAgentHeaderFieldValue: this.options.userAgentString,\n      viaForceRport: this.options.forceRport,\n      viaHost: this.options.viaHost,\n      authenticationFactory: () => {\n        const username = this.options.authorizationUsername ? this.options.authorizationUsername : this.options.uri.user; // if authorization username not provided, use uri user as username\n\n        const password = this.options.authorizationPassword ? this.options.authorizationPassword : undefined;\n        const ha1 = this.options.authorizationHa1 ? this.options.authorizationHa1 : undefined;\n        return new DigestAuthentication(this.getLoggerFactory(), ha1, username, password);\n      },\n      transportAccessor: () => this.transport\n    };\n    const userAgentCoreDelegate = {\n      onInvite: incomingInviteRequest => {\n        var _a;\n\n        const invitation = new Invitation(this, incomingInviteRequest);\n        incomingInviteRequest.delegate = {\n          onCancel: cancel => {\n            invitation._onCancel(cancel);\n          },\n          // eslint-disable-next-line @typescript-eslint/no-unused-vars\n          onTransportError: error => {\n            // A server transaction MUST NOT discard transaction state based only on\n            // encountering a non-recoverable transport error when sending a\n            // response.  Instead, the associated INVITE server transaction state\n            // machine MUST remain in its current state.  (Timers will eventually\n            // cause it to transition to the \"Terminated\" state).\n            // https://tools.ietf.org/html/rfc6026#section-7.1\n            // As noted in the comment above, we are to leaving it to the transaction\n            // timers to eventually cause the transaction to sort itself out in the case\n            // of a transport failure in an invite server transaction. This delegate method\n            // is here simply here for completeness and to make it clear that it provides\n            // nothing more than informational hook into the core. That is, if you think\n            // you should be trying to deal with a transport error here, you are likely wrong.\n            this.logger.error(\"A transport error has occurred while handling an incoming INVITE request.\");\n          }\n        }; // FIXME: Ported - 100 Trying send should be configurable.\n        // Only required if TU will not respond in 200ms.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n        incomingInviteRequest.trying(); // The Replaces header contains information used to match an existing\n        // SIP dialog (call-id, to-tag, and from-tag).  Upon receiving an INVITE\n        // with a Replaces header, the User Agent (UA) attempts to match this\n        // information with a confirmed or early dialog.\n        // https://tools.ietf.org/html/rfc3891#section-3\n\n        if (this.options.sipExtensionReplaces !== SIPExtension.Unsupported) {\n          const message = incomingInviteRequest.message;\n          const replaces = message.parseHeader(\"replaces\");\n\n          if (replaces) {\n            const callId = replaces.call_id;\n\n            if (typeof callId !== \"string\") {\n              throw new Error(\"Type of call id is not string\");\n            }\n\n            const toTag = replaces.replaces_to_tag;\n\n            if (typeof toTag !== \"string\") {\n              throw new Error(\"Type of to tag is not string\");\n            }\n\n            const fromTag = replaces.replaces_from_tag;\n\n            if (typeof fromTag !== \"string\") {\n              throw new Error(\"type of from tag is not string\");\n            }\n\n            const targetDialogId = callId + toTag + fromTag;\n            const targetDialog = this.userAgentCore.dialogs.get(targetDialogId); // If no match is found, the UAS rejects the INVITE and returns a 481\n            // Call/Transaction Does Not Exist response.  Likewise, if the Replaces\n            // header field matches a dialog which was not created with an INVITE,\n            // the UAS MUST reject the request with a 481 response.\n            // https://tools.ietf.org/html/rfc3891#section-3\n\n            if (!targetDialog) {\n              invitation.reject({\n                statusCode: 481\n              });\n              return;\n            } // If the Replaces header field matches a confirmed dialog, it checks\n            // for the presence of the \"early-only\" flag in the Replaces header\n            // field.  (This flag allows the UAC to prevent a potentially\n            // undesirable race condition described in Section 7.1.) If the flag is\n            // present, the UA rejects the request with a 486 Busy response.\n            // https://tools.ietf.org/html/rfc3891#section-3\n\n\n            if (!targetDialog.early && replaces.early_only === true) {\n              invitation.reject({\n                statusCode: 486\n              });\n              return;\n            } // Provide a handle on the session being replaced.\n\n\n            const targetSession = this._sessions[callId + fromTag] || this._sessions[callId + toTag] || undefined;\n\n            if (!targetSession) {\n              throw new Error(\"Session does not exist.\");\n            }\n\n            invitation._replacee = targetSession;\n          }\n        } // Delegate invitation handling.\n\n\n        if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) {\n          if (invitation.autoSendAnInitialProvisionalResponse) {\n            invitation.progress().then(() => {\n              var _a;\n\n              if (((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onInvite) === undefined) {\n                throw new Error(\"onInvite undefined.\");\n              }\n\n              this.delegate.onInvite(invitation);\n            });\n            return;\n          }\n\n          this.delegate.onInvite(invitation);\n          return;\n        } // A common scenario occurs when the callee is currently not willing or\n        // able to take additional calls at this end system.  A 486 (Busy Here)\n        // SHOULD be returned in such a scenario.\n        // https://tools.ietf.org/html/rfc3261#section-13.3.1.3\n\n\n        invitation.reject({\n          statusCode: 486\n        });\n      },\n      onMessage: incomingMessageRequest => {\n        if (this.delegate && this.delegate.onMessage) {\n          const message = new Message(incomingMessageRequest);\n          this.delegate.onMessage(message);\n        } else {\n          // Accept the MESSAGE request, but do nothing with it.\n          incomingMessageRequest.accept();\n        }\n      },\n      onNotify: incomingNotifyRequest => {\n        // NOTIFY requests are sent to inform subscribers of changes in state to\n        // which the subscriber has a subscription.  Subscriptions are created\n        // using the SUBSCRIBE method.  In legacy implementations, it is\n        // possible that other means of subscription creation have been used.\n        // However, this specification does not allow the creation of\n        // subscriptions except through SUBSCRIBE requests and (for backwards-\n        // compatibility) REFER requests [RFC3515].\n        // https://tools.ietf.org/html/rfc6665#section-3.2\n        if (this.delegate && this.delegate.onNotify) {\n          const notification = new Notification(incomingNotifyRequest);\n          this.delegate.onNotify(notification);\n        } else {\n          // Per the above which obsoletes https://tools.ietf.org/html/rfc3265,\n          // the use of out of dialog NOTIFY is obsolete, but...\n          if (this.options.allowLegacyNotifications) {\n            incomingNotifyRequest.accept(); // Accept the NOTIFY request, but do nothing with it.\n          } else {\n            incomingNotifyRequest.reject({\n              statusCode: 481\n            });\n          }\n        }\n      },\n      onRefer: incomingReferRequest => {\n        this.logger.warn(\"Received an out of dialog REFER request\"); // TOOD: this.delegate.onRefer(...)\n\n        if (this.delegate && this.delegate.onReferRequest) {\n          this.delegate.onReferRequest(incomingReferRequest);\n        } else {\n          incomingReferRequest.reject({\n            statusCode: 405\n          });\n        }\n      },\n      onRegister: incomingRegisterRequest => {\n        this.logger.warn(\"Received an out of dialog REGISTER request\"); // TOOD: this.delegate.onRegister(...)\n\n        if (this.delegate && this.delegate.onRegisterRequest) {\n          this.delegate.onRegisterRequest(incomingRegisterRequest);\n        } else {\n          incomingRegisterRequest.reject({\n            statusCode: 405\n          });\n        }\n      },\n      onSubscribe: incomingSubscribeRequest => {\n        this.logger.warn(\"Received an out of dialog SUBSCRIBE request\"); // TOOD: this.delegate.onSubscribe(...)\n\n        if (this.delegate && this.delegate.onSubscribeRequest) {\n          this.delegate.onSubscribeRequest(incomingSubscribeRequest);\n        } else {\n          incomingSubscribeRequest.reject({\n            statusCode: 405\n          });\n        }\n      }\n    };\n    return new UserAgentCore(userAgentCoreConfiguration, userAgentCoreDelegate);\n  }\n\n  initTransportCallbacks() {\n    this.transport.onConnect = () => this.onTransportConnect();\n\n    this.transport.onDisconnect = error => this.onTransportDisconnect(error);\n\n    this.transport.onMessage = message => this.onTransportMessage(message);\n  }\n\n  onTransportConnect() {\n    if (this.state === UserAgentState.Stopped) {\n      return;\n    }\n\n    if (this.delegate && this.delegate.onConnect) {\n      this.delegate.onConnect();\n    }\n  }\n\n  onTransportDisconnect(error) {\n    if (this.state === UserAgentState.Stopped) {\n      return;\n    }\n\n    if (this.delegate && this.delegate.onDisconnect) {\n      this.delegate.onDisconnect(error);\n    } // Only attempt to reconnect if network/server dropped the connection.\n\n\n    if (error && this.options.reconnectionAttempts > 0) {\n      this.attemptReconnection();\n    }\n  }\n\n  onTransportMessage(messageString) {\n    const message = Parser.parseMessage(messageString, this.getLogger(\"sip.Parser\"));\n\n    if (!message) {\n      this.logger.warn(\"Failed to parse incoming message. Dropping.\");\n      return;\n    }\n\n    if (this.state === UserAgentState.Stopped && message instanceof IncomingRequestMessage) {\n      this.logger.warn(`Received ${message.method} request while stopped. Dropping.`);\n      return;\n    } // A valid SIP request formulated by a UAC MUST, at a minimum, contain\n    // the following header fields: To, From, CSeq, Call-ID, Max-Forwards,\n    // and Via; all of these header fields are mandatory in all SIP\n    // requests.\n    // https://tools.ietf.org/html/rfc3261#section-8.1.1\n\n\n    const hasMinimumHeaders = () => {\n      const mandatoryHeaders = [\"from\", \"to\", \"call_id\", \"cseq\", \"via\"];\n\n      for (const header of mandatoryHeaders) {\n        if (!message.hasHeader(header)) {\n          this.logger.warn(`Missing mandatory header field : ${header}.`);\n          return false;\n        }\n      }\n\n      return true;\n    }; // Request Checks\n\n\n    if (message instanceof IncomingRequestMessage) {\n      // This is port of SanityCheck.minimumHeaders().\n      if (!hasMinimumHeaders()) {\n        this.logger.warn(`Request missing mandatory header field. Dropping.`);\n        return;\n      } // FIXME: This is non-standard and should be a configurable behavior (desirable regardless).\n      // Custom SIP.js check to reject request from ourself (this instance of SIP.js).\n      // This is port of SanityCheck.rfc3261_16_3_4().\n\n\n      if (!message.toTag && message.callId.substr(0, 5) === this.options.sipjsId) {\n        this.userAgentCore.replyStateless(message, {\n          statusCode: 482\n        });\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to reject requests if body length wrong.\n      // This is port of SanityCheck.rfc3261_18_3_request().\n\n\n      const len = utf8Length(message.body);\n      const contentLength = message.getHeader(\"content-length\");\n\n      if (contentLength && len < Number(contentLength)) {\n        this.userAgentCore.replyStateless(message, {\n          statusCode: 400\n        });\n        return;\n      }\n    } // Response Checks\n\n\n    if (message instanceof IncomingResponseMessage) {\n      // This is port of SanityCheck.minimumHeaders().\n      if (!hasMinimumHeaders()) {\n        this.logger.warn(`Response missing mandatory header field. Dropping.`);\n        return;\n      } // Custom SIP.js check to drop responses if multiple Via headers.\n      // This is port of SanityCheck.rfc3261_8_1_3_3().\n\n\n      if (message.getHeaders(\"via\").length > 1) {\n        this.logger.warn(\"More than one Via header field present in the response. Dropping.\");\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to drop responses if bad Via header.\n      // This is port of SanityCheck.rfc3261_18_1_2().\n\n\n      if (message.via.host !== this.options.viaHost || message.via.port !== undefined) {\n        this.logger.warn(\"Via sent-by in the response does not match UA Via host value. Dropping.\");\n        return;\n      } // FIXME: This should be Transport check before we get here (Section 18).\n      // Custom SIP.js check to reject requests if body length wrong.\n      // This is port of SanityCheck.rfc3261_18_3_response().\n\n\n      const len = utf8Length(message.body);\n      const contentLength = message.getHeader(\"content-length\");\n\n      if (contentLength && len < Number(contentLength)) {\n        this.logger.warn(\"Message body length is lower than the value in Content-Length header field. Dropping.\");\n        return;\n      }\n    } // Handle Request\n\n\n    if (message instanceof IncomingRequestMessage) {\n      this.userAgentCore.receiveIncomingRequestFromTransport(message);\n      return;\n    } // Handle Response\n\n\n    if (message instanceof IncomingResponseMessage) {\n      this.userAgentCore.receiveIncomingResponseFromTransport(message);\n      return;\n    }\n\n    throw new Error(\"Invalid message type.\");\n  }\n  /**\n   * Transition state.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  transitionState(newState, error) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate state transition\n\n\n    switch (this._state) {\n      case UserAgentState.Started:\n        if (newState !== UserAgentState.Stopped) {\n          invalidTransition();\n        }\n\n        break;\n\n      case UserAgentState.Stopped:\n        if (newState !== UserAgentState.Started) {\n          invalidTransition();\n        }\n\n        break;\n\n      default:\n        throw new Error(\"Unknown state.\");\n    } // Update state\n\n\n    this.logger.log(`Transitioned from ${this._state} to ${newState}`);\n    this._state = newState;\n\n    this._stateEventEmitter.emit(this._state);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}