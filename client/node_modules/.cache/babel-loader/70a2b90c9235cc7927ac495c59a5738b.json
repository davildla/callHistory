{"ast":null,"code":"import { Dialog } from \"../dialogs/dialog.js\";\nimport { SessionDialog } from \"../dialogs/session-dialog.js\";\nimport { SignalingState } from \"../session/session.js\";\nimport { InviteClientTransaction } from \"../transactions/invite-client-transaction.js\";\nimport { TransactionState } from \"../transactions/transaction-state.js\";\nimport { UserAgentClient } from \"./user-agent-client.js\";\n/**\n * INVITE UAC.\n * @remarks\n * 13 Initiating a Session\n * https://tools.ietf.org/html/rfc3261#section-13\n * 13.1 Overview\n * https://tools.ietf.org/html/rfc3261#section-13.1\n * 13.2 UAC Processing\n * https://tools.ietf.org/html/rfc3261#section-13.2\n * @public\n */\n\nexport class InviteUserAgentClient extends UserAgentClient {\n  constructor(core, message, delegate) {\n    super(InviteClientTransaction, core, message, delegate);\n    this.confirmedDialogAcks = new Map();\n    this.confirmedDialogs = new Map();\n    this.earlyDialogs = new Map();\n    this.delegate = delegate;\n  }\n\n  dispose() {\n    // The UAC core considers the INVITE transaction completed 64*T1 seconds\n    // after the reception of the first 2xx response.  At this point all the\n    // early dialogs that have not transitioned to established dialogs are\n    // terminated.  Once the INVITE transaction is considered completed by\n    // the UAC core, no more new 2xx responses are expected to arrive.\n    //\n    // If, after acknowledging any 2xx response to an INVITE, the UAC does\n    // not want to continue with that dialog, then the UAC MUST terminate\n    // the dialog by sending a BYE request as described in Section 15.\n    // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n    this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n    this.earlyDialogs.clear();\n    super.dispose();\n  }\n  /**\n   * Special case for transport error while sending ACK.\n   * @param error - Transport error\n   */\n\n\n  onTransportError(error) {\n    if (this.transaction.state === TransactionState.Calling) {\n      return super.onTransportError(error);\n    } // If not in 'calling' state, the transport error occurred while sending an ACK.\n\n\n    this.logger.error(error.message);\n    this.logger.error(\"User agent client request transport error while sending ACK.\");\n  }\n  /**\n   * Once the INVITE has been passed to the INVITE client transaction, the\n   * UAC waits for responses for the INVITE.\n   * https://tools.ietf.org/html/rfc3261#section-13.2.2\n   * @param incomingResponse - Incoming response to INVITE request.\n   */\n\n\n  receiveResponse(message) {\n    if (!this.authenticationGuard(message)) {\n      return;\n    }\n\n    const statusCode = message.statusCode ? message.statusCode.toString() : \"\";\n\n    if (!statusCode) {\n      throw new Error(\"Response status code undefined.\");\n    }\n\n    switch (true) {\n      case /^100$/.test(statusCode):\n        if (this.delegate && this.delegate.onTrying) {\n          this.delegate.onTrying({\n            message\n          });\n        }\n\n        return;\n\n      case /^1[0-9]{2}$/.test(statusCode):\n        // Zero, one or multiple provisional responses may arrive before one or\n        // more final responses are received.  Provisional responses for an\n        // INVITE request can create \"early dialogs\".  If a provisional response\n        // has a tag in the To field, and if the dialog ID of the response does\n        // not match an existing dialog, one is constructed using the procedures\n        // defined in Section 12.1.2.\n        //\n        // The early dialog will only be needed if the UAC needs to send a\n        // request to its peer within the dialog before the initial INVITE\n        // transaction completes.  Header fields present in a provisional\n        // response are applicable as long as the dialog is in the early state\n        // (for example, an Allow header field in a provisional response\n        // contains the methods that can be used in the dialog while this is in\n        // the early state).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.1\n        {\n          // Dialogs are created through the generation of non-failure responses\n          // to requests with specific methods.  Within this specification, only\n          // 2xx and 101-199 responses with a To tag, where the request was\n          // INVITE, will establish a dialog.  A dialog established by a non-final\n          // response to a request is in the \"early\" state and it is called an\n          // early dialog.\n          // https://tools.ietf.org/html/rfc3261#section-12.1\n          // Provisional without to tag, no dialog to create.\n          if (!message.toTag) {\n            this.logger.warn(\"Non-100 1xx INVITE response received without a to tag, dropping.\");\n            return;\n          } // When a UAS responds to a request with a response that establishes a\n          // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n          // header field values from the request into the response (including the\n          // URIs, URI parameters, and any Record-Route header field parameters,\n          // whether they are known or unknown to the UAS) and MUST maintain the\n          // order of those values.  The UAS MUST add a Contact header field to\n          // the response.\n          // https://tools.ietf.org/html/rfc3261#section-12.1.1\n          // Provisional without Contact header field, malformed response.\n\n\n          const contact = message.parseHeader(\"contact\");\n\n          if (!contact) {\n            this.logger.error(\"Non-100 1xx INVITE response received without a Contact header field, dropping.\");\n            return;\n          } // Compute dialog state.\n\n\n          const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // Have existing early dialog or create a new one.\n\n          let earlyDialog = this.earlyDialogs.get(dialogState.id);\n\n          if (!earlyDialog) {\n            const transaction = this.transaction;\n\n            if (!(transaction instanceof InviteClientTransaction)) {\n              throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n\n            earlyDialog = new SessionDialog(transaction, this.core, dialogState);\n            this.earlyDialogs.set(earlyDialog.id, earlyDialog);\n          } // Guard against out of order reliable provisional responses.\n          // Note that this is where the rseq tracking is done.\n\n\n          if (!earlyDialog.reliableSequenceGuard(message)) {\n            this.logger.warn(\"1xx INVITE reliable response received out of order or is a retransmission, dropping.\");\n            return;\n          } // If the initial offer is in an INVITE, the answer MUST be in a\n          // reliable non-failure message from UAS back to UAC which is\n          // correlated to that INVITE.  For this specification, that is\n          // only the final 2xx response to that INVITE.  That same exact\n          // answer MAY also be placed in any provisional responses sent\n          // prior to the answer.  The UAC MUST treat the first session\n          // description it receives as the answer, and MUST ignore any\n          // session descriptions in subsequent responses to the initial\n          // INVITE.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n          if (earlyDialog.signalingState === SignalingState.Initial || earlyDialog.signalingState === SignalingState.HaveLocalOffer) {\n            earlyDialog.signalingStateTransition(message);\n          } // Pass response to delegate.\n\n\n          const session = earlyDialog;\n\n          if (this.delegate && this.delegate.onProgress) {\n            this.delegate.onProgress({\n              message,\n              session,\n              prack: options => {\n                const outgoingPrackRequest = session.prack(undefined, options);\n                return outgoingPrackRequest;\n              }\n            });\n          }\n        }\n        return;\n\n      case /^2[0-9]{2}$/.test(statusCode):\n        // Multiple 2xx responses may arrive at the UAC for a single INVITE\n        // request due to a forking proxy.  Each response is distinguished by\n        // the tag parameter in the To header field, and each represents a\n        // distinct dialog, with a distinct dialog identifier.\n        //\n        // If the dialog identifier in the 2xx response matches the dialog\n        // identifier of an existing dialog, the dialog MUST be transitioned to\n        // the \"confirmed\" state, and the route set for the dialog MUST be\n        // recomputed based on the 2xx response using the procedures of Section\n        // 12.2.1.2.  Otherwise, a new dialog in the \"confirmed\" state MUST be\n        // constructed using the procedures of Section 12.1.2.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n        {\n          // Dialogs are created through the generation of non-failure responses\n          // to requests with specific methods.  Within this specification, only\n          // 2xx and 101-199 responses with a To tag, where the request was\n          // INVITE, will establish a dialog.  A dialog established by a non-final\n          // response to a request is in the \"early\" state and it is called an\n          // early dialog.\n          // https://tools.ietf.org/html/rfc3261#section-12.1\n          // Final without to tag, malformed response.\n          if (!message.toTag) {\n            this.logger.error(\"2xx INVITE response received without a to tag, dropping.\");\n            return;\n          } // When a UAS responds to a request with a response that establishes a\n          // dialog (such as a 2xx to INVITE), the UAS MUST copy all Record-Route\n          // header field values from the request into the response (including the\n          // URIs, URI parameters, and any Record-Route header field parameters,\n          // whether they are known or unknown to the UAS) and MUST maintain the\n          // order of those values.  The UAS MUST add a Contact header field to\n          // the response.\n          // https://tools.ietf.org/html/rfc3261#section-12.1.1\n          // Final without Contact header field, malformed response.\n\n\n          const contact = message.parseHeader(\"contact\");\n\n          if (!contact) {\n            this.logger.error(\"2xx INVITE response received without a Contact header field, dropping.\");\n            return;\n          } // Compute dialog state.\n\n\n          const dialogState = Dialog.initialDialogStateForUserAgentClient(this.message, message); // NOTE: Currently our transaction layer is caching the 2xx ACKs and\n          // handling retransmissions of the ACK which is an approach which is\n          // not to spec. In any event, this block is intended to provide a to\n          // spec implementation of ACK retransmissions, but it should not be\n          // hit currently.\n\n          let dialog = this.confirmedDialogs.get(dialogState.id);\n\n          if (dialog) {\n            // Once the ACK has been constructed, the procedures of [4] are used to\n            // determine the destination address, port and transport.  However, the\n            // request is passed to the transport layer directly for transmission,\n            // rather than a client transaction.  This is because the UAC core\n            // handles retransmissions of the ACK, not the transaction layer.  The\n            // ACK MUST be passed to the client transport every time a\n            // retransmission of the 2xx final response that triggered the ACK\n            // arrives.\n            // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n            const outgoingAckRequest = this.confirmedDialogAcks.get(dialogState.id);\n\n            if (outgoingAckRequest) {\n              const transaction = this.transaction;\n\n              if (!(transaction instanceof InviteClientTransaction)) {\n                throw new Error(\"Client transaction not instance of InviteClientTransaction.\");\n              }\n\n              transaction.ackResponse(outgoingAckRequest.message);\n            } else {// If still waiting for an ACK, drop the retransmission of the 2xx final response.\n            }\n\n            return;\n          } // If the dialog identifier in the 2xx response matches the dialog\n          // identifier of an existing dialog, the dialog MUST be transitioned to\n          // the \"confirmed\" state, and the route set for the dialog MUST be\n          // recomputed based on the 2xx response using the procedures of Section\n          // 12.2.1.2. Otherwise, a new dialog in the \"confirmed\" state MUST be\n          // constructed using the procedures of Section 12.1.2.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n\n          dialog = this.earlyDialogs.get(dialogState.id);\n\n          if (dialog) {\n            dialog.confirm();\n            dialog.recomputeRouteSet(message);\n            this.earlyDialogs.delete(dialog.id);\n            this.confirmedDialogs.set(dialog.id, dialog);\n          } else {\n            const transaction = this.transaction;\n\n            if (!(transaction instanceof InviteClientTransaction)) {\n              throw new Error(\"Transaction not instance of InviteClientTransaction.\");\n            }\n\n            dialog = new SessionDialog(transaction, this.core, dialogState);\n            this.confirmedDialogs.set(dialog.id, dialog);\n          } // If the initial offer is in an INVITE, the answer MUST be in a\n          // reliable non-failure message from UAS back to UAC which is\n          // correlated to that INVITE.  For this specification, that is\n          // only the final 2xx response to that INVITE.  That same exact\n          // answer MAY also be placed in any provisional responses sent\n          // prior to the answer.  The UAC MUST treat the first session\n          // description it receives as the answer, and MUST ignore any\n          // session descriptions in subsequent responses to the initial\n          // INVITE.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.1\n\n\n          if (dialog.signalingState === SignalingState.Initial || dialog.signalingState === SignalingState.HaveLocalOffer) {\n            dialog.signalingStateTransition(message);\n          } // Session Initiated! :)\n\n\n          const session = dialog; // The UAC core MUST generate an ACK request for each 2xx received from\n          // the transaction layer.  The header fields of the ACK are constructed\n          // in the same way as for any request sent within a dialog (see Section\n          // 12) with the exception of the CSeq and the header fields related to\n          // authentication.  The sequence number of the CSeq header field MUST be\n          // the same as the INVITE being acknowledged, but the CSeq method MUST\n          // be ACK.  The ACK MUST contain the same credentials as the INVITE.  If\n          // the 2xx contains an offer (based on the rules above), the ACK MUST\n          // carry an answer in its body.  If the offer in the 2xx response is not\n          // acceptable, the UAC core MUST generate a valid answer in the ACK and\n          // then send a BYE immediately.\n          // https://tools.ietf.org/html/rfc3261#section-13.2.2.4\n\n          if (this.delegate && this.delegate.onAccept) {\n            this.delegate.onAccept({\n              message,\n              session,\n              ack: options => {\n                const outgoingAckRequest = session.ack(options);\n                this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n                return outgoingAckRequest;\n              }\n            });\n          } else {\n            const outgoingAckRequest = session.ack();\n            this.confirmedDialogAcks.set(session.id, outgoingAckRequest);\n          }\n        }\n        return;\n\n      case /^3[0-9]{2}$/.test(statusCode):\n        // 12.3 Termination of a Dialog\n        //\n        // Independent of the method, if a request outside of a dialog generates\n        // a non-2xx final response, any early dialogs created through\n        // provisional responses to that request are terminated.  The mechanism\n        // for terminating confirmed dialogs is method specific.  In this\n        // specification, the BYE method terminates a session and the dialog\n        // associated with it.  See Section 15 for details.\n        // https://tools.ietf.org/html/rfc3261#section-12.3\n        // All early dialogs are considered terminated upon reception of the\n        // non-2xx final response.\n        //\n        // After having received the non-2xx final response the UAC core\n        // considers the INVITE transaction completed.  The INVITE client\n        // transaction handles the generation of ACKs for the response (see\n        // Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n        this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n        this.earlyDialogs.clear(); // A 3xx response may contain one or more Contact header field values\n        // providing new addresses where the callee might be reachable.\n        // Depending on the status code of the 3xx response (see Section 21.3),\n        // the UAC MAY choose to try those new addresses.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.2\n\n        if (this.delegate && this.delegate.onRedirect) {\n          this.delegate.onRedirect({\n            message\n          });\n        }\n\n        return;\n\n      case /^[4-6][0-9]{2}$/.test(statusCode):\n        // 12.3 Termination of a Dialog\n        //\n        // Independent of the method, if a request outside of a dialog generates\n        // a non-2xx final response, any early dialogs created through\n        // provisional responses to that request are terminated.  The mechanism\n        // for terminating confirmed dialogs is method specific.  In this\n        // specification, the BYE method terminates a session and the dialog\n        // associated with it.  See Section 15 for details.\n        // https://tools.ietf.org/html/rfc3261#section-12.3\n        // All early dialogs are considered terminated upon reception of the\n        // non-2xx final response.\n        //\n        // After having received the non-2xx final response the UAC core\n        // considers the INVITE transaction completed.  The INVITE client\n        // transaction handles the generation of ACKs for the response (see\n        // Section 17).\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n        this.earlyDialogs.forEach(earlyDialog => earlyDialog.dispose());\n        this.earlyDialogs.clear(); // A single non-2xx final response may be received for the INVITE.  4xx,\n        // 5xx and 6xx responses may contain a Contact header field value\n        // indicating the location where additional information about the error\n        // can be found.  Subsequent final responses (which would only arrive\n        // under error conditions) MUST be ignored.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.2.3\n\n        if (this.delegate && this.delegate.onReject) {\n          this.delegate.onReject({\n            message\n          });\n        }\n\n        return;\n\n      default:\n        throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    throw new Error(`Executing what should be an unreachable code path receiving ${statusCode} response.`);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}