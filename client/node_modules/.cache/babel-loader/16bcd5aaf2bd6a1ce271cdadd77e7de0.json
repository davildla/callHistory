{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar WebSocket = require(\"ws\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\"); // tslint:disable-next-line\n\n\nvar Backoff = require('backoff');\n\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\n/**\n * All possible states of WSTransport.\n */\n\nvar WSTransportState;\n\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\n\n\nvar WSTransport =\n/** @class */\nfunction (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n\n\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n\n\n    _this.state = WSTransportState.Closed;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n\n\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason); // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n\n\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n\n        var wasConnected = // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open || // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open; // Only fallback if this is not the first error\n        // and if we were not connected previously\n\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n\n        _this._shouldFallback = true;\n      }\n\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n\n\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n\n\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout(); // Filter and respond to heartbeats\n\n\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n\n        return;\n      }\n\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n\n\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n\n      _this._setState(WSTransportState.Open);\n\n      clearTimeout(_this._connectTimeout);\n\n      _this._setHeartbeatTimeout();\n\n      _this.emit('open');\n    };\n\n    _this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n    var initialDelay = 100;\n\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    var backoffConfig = {\n      factor: 2.0,\n      initialDelay: initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number' ? Math.max(options.backoffMaxMs, 3000) : 20000,\n      randomisationFactor: 0.40\n    };\n\n    _this._log.info('Initializing transport backoff using config: ', backoffConfig);\n\n    _this._backoff = Backoff.exponential(backoffConfig);\n    _this._uris = uris;\n    _this._WebSocket = options.WebSocket || WebSocket; // Called when a backoff timer is started.\n\n    _this._backoff.on('backoff', function (_, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n    }); // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n\n\n    _this._backoff.on('ready', function (attempt) {\n      if (_this.state === WSTransportState.Closed) {\n        return;\n      }\n\n      _this._connect(attempt + 1);\n    });\n\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n\n\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n\n      return;\n    }\n\n    this._connect();\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n\n\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n\n      this._closeSocket();\n\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n\n\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose);\n\n    this._socket.removeEventListener('error', this._onSocketError);\n\n    this._socket.removeEventListener('message', this._onSocketMessage);\n\n    this._socket.removeEventListener('open', this._onSocketOpen);\n\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    } // Reset backoff counter if connection was open for long enough to be considered successful\n\n\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n\n\n  WSTransport.prototype._connect = function (retryCount) {\n    var _this = this;\n\n    if (retryCount) {\n      this._log.info(\"Attempting to reconnect (retry #\" + retryCount + \")...\");\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n\n    var socket = null;\n\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n\n      this._close();\n\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._uris[this._uriIndex],\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n\n      _this._moveUriIndex();\n\n      _this._closeSocket();\n    }, this._connectTimeoutMs);\n    socket.addEventListener('close', this._onSocketClose);\n    socket.addEventListener('error', this._onSocketError);\n    socket.addEventListener('message', this._onSocketMessage);\n    socket.addEventListener('open', this._onSocketOpen);\n    this._socket = socket;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n\n\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n\n      _this._shouldFallback = true;\n\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n\n\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._uris[this._uriIndex];\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return WSTransport;\n}(events_1.EventEmitter);\n\nexports.default = WSTransport;","map":{"version":3,"mappings":"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","names":["Backoff","require","CONNECT_SUCCESS_TIMEOUT","CONNECT_TIMEOUT","HEARTBEAT_TIMEOUT","WSTransportState","exports","__extends","uris","options","_super","_this","Closed","log_1","getInstance","_uriIndex","_uris","length","event","_log","info","code","reason","emit","message","twilioError","errors_1","ConnectionError","wasConnected","state","Open","_previousState","_shouldFallback","_moveUriIndex","_closeSocket","err","ConnectionDisconnected","_setHeartbeatTimeout","_socket","data","send","_timeOpened","Date","now","_setState","clearTimeout","_connectTimeout","_connectTimeoutMs","connectTimeoutMs","initialDelay","Math","floor","random","backoffConfig","factor","maxDelay","backoffMaxMs","max","randomisationFactor","_backoff","exponential","_WebSocket","WebSocket","on","_","delay","attempt","_connect","WSTransport","_close","readyState","CONNECTING","OPEN","e","_heartbeatTimeout","removeEventListener","_onSocketClose","_onSocketError","_onSocketMessage","_onSocketOpen","close","reset","backoff","retryCount","Connecting","socket","setTimeout","addEventListener","Object","events_1"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/twilio-client/lib/twilio/wstransport.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport * as WebSocket from 'ws';\nimport { SignalingErrors } from './errors';\nimport Log from './log';\n\n// tslint:disable-next-line\nconst Backoff = require('backoff');\n\nconst CONNECT_SUCCESS_TIMEOUT = 10000;\nconst CONNECT_TIMEOUT = 5000;\nconst HEARTBEAT_TIMEOUT = 15000;\n\nexport interface IMessageEvent {\n  data: string;\n  target: WebSocket;\n  type: string;\n}\n\n/**\n * All possible states of WSTransport.\n */\nexport enum WSTransportState {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  Connecting = 'connecting',\n\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n  Closed = 'closed',\n\n  /**\n   * The underlying WebSocket is open and active.\n   */\n  Open = 'open',\n}\n\n/**\n * Options to be passed to the WSTransport constructor.\n */\nexport interface IWSTransportConstructorOptions {\n  /**\n   * Maximum time to wait before attempting to reconnect the signaling websocket.\n   * Default is 20000ms. Minimum is 3000ms.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  connectTimeoutMs?: number;\n\n  /**\n   * A WebSocket factory to use instead of WebSocket.\n   */\n  WebSocket?: any;\n}\n\n/**\n * WebSocket Transport\n */\nexport default class WSTransport extends EventEmitter {\n  /**\n   * The current state of the WSTransport.\n   */\n  state: WSTransportState = WSTransportState.Closed;\n\n  /**\n   * The backoff instance used to schedule reconnection attempts.\n   */\n  private readonly _backoff: any;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _connectTimeout?: any;\n\n  /**\n   * Time in milliseconds before websocket times out when attempting to connect\n   */\n  private _connectTimeoutMs?: number;\n\n  /**\n   * The current connection timeout. If it times out, we've failed to connect\n   * and should try again.\n   *\n   * We use any here because NodeJS returns a Timer and browser returns a number\n   * and one can't be cast to the other, despite their working interoperably.\n   */\n  private _heartbeatTimeout?: any;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Previous state of the connection\n   */\n  private _previousState: WSTransportState;\n\n  /**\n   * Whether we should attempt to fallback if we receive an applicable error\n   * when trying to connect to a signaling endpoint.\n   */\n  private _shouldFallback: boolean = false;\n\n  /**\n   * The currently connecting or open WebSocket.\n   */\n  private _socket?: WebSocket;\n\n  /**\n   * The time the active connection was opened.\n   */\n  private _timeOpened?: number;\n\n  /**\n   * The current uri index that the transport is connected to.\n   */\n  private _uriIndex: number = 0;\n\n  /**\n   * List of URI of the endpoints to connect to.\n   */\n  private readonly _uris: string[];\n\n  /**\n   * The constructor to use for WebSocket\n   */\n  private readonly _WebSocket: typeof WebSocket;\n\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n  constructor(uris: string[], options: IWSTransportConstructorOptions = { }) {\n    super();\n\n    this._connectTimeoutMs = options.connectTimeoutMs || CONNECT_TIMEOUT;\n\n    let initialDelay = 100;\n    if (uris && uris.length > 1) {\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay = Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000;\n    }\n\n    const backoffConfig = {\n      factor: 2.0,\n      initialDelay,\n      maxDelay: typeof options.backoffMaxMs === 'number'\n        ? Math.max(options.backoffMaxMs, 3000)\n        : 20000,\n      randomisationFactor: 0.40,\n    };\n\n    this._log.info('Initializing transport backoff using config: ', backoffConfig);\n    this._backoff = Backoff.exponential(backoffConfig);\n\n    this._uris = uris;\n    this._WebSocket = options.WebSocket || WebSocket;\n\n    // Called when a backoff timer is started.\n    this._backoff.on('backoff', (_: any, delay: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._log.info(`Will attempt to reconnect WebSocket in ${delay}ms`);\n    });\n\n    // Called when a backoff timer ends. We want to try to reconnect\n    // the WebSocket at this point.\n    this._backoff.on('ready', (attempt: number) => {\n      if (this.state === WSTransportState.Closed) { return; }\n      this._connect(attempt + 1);\n    });\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  close(): void {\n    this._log.info('WSTransport.close() called...');\n    this._close();\n  }\n\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n  open(): void {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket &&\n        (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n      return;\n    }\n\n    this._connect();\n  }\n\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n  send(message: string): boolean {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n      this._closeSocket();\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n  private _close(): void {\n    this._setState(WSTransportState.Closed);\n    this._closeSocket();\n  }\n\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n  private _closeSocket(): void {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose as any);\n    this._socket.removeEventListener('error', this._onSocketError as any);\n    this._socket.removeEventListener('message', this._onSocketMessage as any);\n    this._socket.removeEventListener('open', this._onSocketOpen as any);\n\n    if (this._socket.readyState === WebSocket.CONNECTING ||\n        this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    }\n\n    // Reset backoff counter if connection was open for long enough to be considered successful\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._backoff.reset();\n    }\n\n    this._backoff.backoff();\n    delete this._socket;\n\n    this.emit('close');\n  }\n\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n  private _connect(retryCount?: number): void {\n    if (retryCount) {\n      this._log.info(`Attempting to reconnect (retry #${retryCount})...`);\n    } else {\n      this._log.info('Attempting to connect...');\n    }\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n    let socket = null;\n    try {\n      socket = new this._WebSocket(this._uris[this._uriIndex]);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n      this._close();\n      this.emit('error', {\n        code: 31000,\n        message: e.message || `Could not connect to ${this._uris[this._uriIndex]}`,\n        twilioError: new SignalingErrors.ConnectionDisconnected(),\n      });\n      return;\n    }\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(() => {\n      this._log.info('WebSocket connection attempt timed out.');\n      this._moveUriIndex();\n      this._closeSocket();\n    }, this._connectTimeoutMs);\n\n    socket.addEventListener('close', this._onSocketClose as any);\n    socket.addEventListener('error', this._onSocketError as any);\n    socket.addEventListener('message', this._onSocketMessage as any);\n    socket.addEventListener('open', this._onSocketOpen as any);\n    this._socket = socket;\n  }\n\n  /**\n   * Move the uri index to the next index\n   * If the index is at the end, the index goes back to the first one.\n   */\n  private _moveUriIndex = (): void => {\n    this._uriIndex++;\n    if (this._uriIndex >= this._uris.length) {\n      this._uriIndex = 0;\n    }\n  }\n\n  /**\n   * Called in response to WebSocket#close event.\n   */\n  private _onSocketClose = (event: CloseEvent): void => {\n    this._log.info(`Received websocket close event code: ${event.code}. Reason: ${event.reason}`);\n    // 1006: Abnormal close. When the server is unreacheable\n    // 1015: TLS Handshake error\n    if (event.code === 1006 || event.code === 1015) {\n      this.emit('error', {\n        code: 31005,\n        message: event.reason ||\n          'Websocket connection to Twilio\\'s signaling servers were ' +\n          'unexpectedly ended. If this is happening consistently, there may ' +\n          'be an issue resolving the hostname provided. If a region or an ' +\n          'edge is being specified in Device setup, ensure it is valid.',\n        twilioError: new SignalingErrors.ConnectionError(),\n      });\n\n      const wasConnected = (\n        // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        this.state === WSTransportState.Open ||\n\n        // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        this._previousState === WSTransportState.Open\n      );\n\n      // Only fallback if this is not the first error\n      // and if we were not connected previously\n      if (this._shouldFallback || !wasConnected) {\n        this._moveUriIndex();\n      }\n\n      this._shouldFallback = true;\n    }\n    this._closeSocket();\n  }\n\n  /**\n   * Called in response to WebSocket#error event.\n   */\n  private _onSocketError = (err: Error): void => {\n    this._log.info(`WebSocket received error: ${err.message}`);\n    this.emit('error', {\n      code: 31000,\n      message: err.message || 'WSTransport socket error',\n      twilioError: new SignalingErrors.ConnectionDisconnected(),\n    });\n  }\n\n  /**\n   * Called in response to WebSocket#message event.\n   */\n  private _onSocketMessage = (message: IMessageEvent): void => {\n    // Clear heartbeat timeout on any incoming message, as they\n    // all indicate an active connection.\n    this._setHeartbeatTimeout();\n\n    // Filter and respond to heartbeats\n    if (this._socket && message.data === '\\n') {\n      this._socket.send('\\n');\n      return;\n    }\n\n    this.emit('message', message);\n  }\n\n  /**\n   * Called in response to WebSocket#open event.\n   */\n  private _onSocketOpen = (): void => {\n    this._log.info('WebSocket opened successfully.');\n    this._timeOpened = Date.now();\n    this._shouldFallback = false;\n    this._setState(WSTransportState.Open);\n    clearTimeout(this._connectTimeout);\n\n    this._setHeartbeatTimeout();\n    this.emit('open');\n  }\n\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n  private _setHeartbeatTimeout(): void {\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(() => {\n      this._log.info(`No messages received in ${HEARTBEAT_TIMEOUT / 1000} seconds. Reconnecting...`);\n      this._shouldFallback = true;\n      this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  }\n\n  /**\n   * Set the current and previous state\n   */\n  private _setState(state: WSTransportState): void {\n    this._previousState = this.state;\n    this.state = state;\n  }\n\n  /**\n   * The uri the transport is currently connected to\n   */\n  get uri(): string {\n    return this._uris[this._uriIndex];\n  }\n}\n"]},"metadata":{},"sourceType":"script"}