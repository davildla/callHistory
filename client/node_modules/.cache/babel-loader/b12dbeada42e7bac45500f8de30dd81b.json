{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Tools\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar WebSocket = require(\"ws\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\"); // tslint:disable-next-line\n\n\nvar Backoff = require('backoff');\n\nvar CONNECT_SUCCESS_TIMEOUT = 10000;\nvar CONNECT_TIMEOUT = 5000;\nvar HEARTBEAT_TIMEOUT = 15000;\nvar MAX_PREFERRED_DURATION = 15000;\nvar MAX_PRIMARY_DURATION = Infinity;\nvar MAX_PREFERRED_DELAY = 1000;\nvar MAX_PRIMARY_DELAY = 20000;\n/**\n * All possible states of WSTransport.\n */\n\nvar WSTransportState;\n\n(function (WSTransportState) {\n  /**\n   * The WebSocket is not open but is trying to connect.\n   */\n  WSTransportState[\"Connecting\"] = \"connecting\";\n  /**\n   * The WebSocket is not open and is not trying to connect.\n   */\n\n  WSTransportState[\"Closed\"] = \"closed\";\n  /**\n   * The underlying WebSocket is open and active.\n   */\n\n  WSTransportState[\"Open\"] = \"open\";\n})(WSTransportState = exports.WSTransportState || (exports.WSTransportState = {}));\n/**\n * WebSocket Transport\n */\n\n\nvar WSTransport =\n/** @class */\nfunction (_super) {\n  __extends(WSTransport, _super);\n  /**\n   * @constructor\n   * @param uris - List of URI of the endpoints to connect to.\n   * @param [options] - Constructor options.\n   */\n\n\n  function WSTransport(uris, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The current state of the WSTransport.\n     */\n\n\n    _this.state = WSTransportState.Closed;\n    /**\n     * Start timestamp values for backoffs.\n     */\n\n    _this._backoffStartTime = {\n      preferred: null,\n      primary: null\n    };\n    /**\n     * The URI that the transport is connecting or connected to. The value of this\n     * property is `null` if a connection attempt has not been made yet.\n     */\n\n    _this._connectedUri = null;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * Whether we should attempt to fallback if we receive an applicable error\n     * when trying to connect to a signaling endpoint.\n     */\n\n    _this._shouldFallback = false;\n    /**\n     * The current uri index that the transport is connected to.\n     */\n\n    _this._uriIndex = 0;\n    /**\n     * Move the uri index to the next index\n     * If the index is at the end, the index goes back to the first one.\n     */\n\n    _this._moveUriIndex = function () {\n      _this._uriIndex++;\n\n      if (_this._uriIndex >= _this._uris.length) {\n        _this._uriIndex = 0;\n      }\n    };\n    /**\n     * Called in response to WebSocket#close event.\n     */\n\n\n    _this._onSocketClose = function (event) {\n      _this._log.info(\"Received websocket close event code: \" + event.code + \". Reason: \" + event.reason); // 1006: Abnormal close. When the server is unreacheable\n      // 1015: TLS Handshake error\n\n\n      if (event.code === 1006 || event.code === 1015) {\n        _this.emit('error', {\n          code: 31005,\n          message: event.reason || 'Websocket connection to Twilio\\'s signaling servers were ' + 'unexpectedly ended. If this is happening consistently, there may ' + 'be an issue resolving the hostname provided. If a region or an ' + 'edge is being specified in Device setup, ensure it is valid.',\n          twilioError: new errors_1.SignalingErrors.ConnectionError()\n        });\n\n        var wasConnected = // Only in Safari and certain Firefox versions, on network interruption, websocket drops right away with 1006\n        // Let's check current state if it's open, meaning we should not fallback\n        // because we're coming from a previously connected session\n        _this.state === WSTransportState.Open || // But on other browsers, websocket doesn't drop\n        // but our heartbeat catches it, setting the internal state to \"Connecting\".\n        // With this, we should check the previous state instead.\n        _this._previousState === WSTransportState.Open; // Only fallback if this is not the first error\n        // and if we were not connected previously\n\n        if (_this._shouldFallback || !wasConnected) {\n          _this._moveUriIndex();\n        }\n\n        _this._shouldFallback = true;\n      }\n\n      _this._closeSocket();\n    };\n    /**\n     * Called in response to WebSocket#error event.\n     */\n\n\n    _this._onSocketError = function (err) {\n      _this._log.info(\"WebSocket received error: \" + err.message);\n\n      _this.emit('error', {\n        code: 31000,\n        message: err.message || 'WSTransport socket error',\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n    };\n    /**\n     * Called in response to WebSocket#message event.\n     */\n\n\n    _this._onSocketMessage = function (message) {\n      // Clear heartbeat timeout on any incoming message, as they\n      // all indicate an active connection.\n      _this._setHeartbeatTimeout(); // Filter and respond to heartbeats\n\n\n      if (_this._socket && message.data === '\\n') {\n        _this._socket.send('\\n');\n\n        return;\n      }\n\n      _this.emit('message', message);\n    };\n    /**\n     * Called in response to WebSocket#open event.\n     */\n\n\n    _this._onSocketOpen = function () {\n      _this._log.info('WebSocket opened successfully.');\n\n      _this._timeOpened = Date.now();\n      _this._shouldFallback = false;\n\n      _this._setState(WSTransportState.Open);\n\n      clearTimeout(_this._connectTimeout);\n\n      _this._resetBackoffs();\n\n      _this._setHeartbeatTimeout();\n\n      _this.emit('open');\n    };\n\n    _this._options = __assign(__assign({}, WSTransport.defaultConstructorOptions), options);\n    _this._uris = uris;\n    _this._backoff = _this._setupBackoffs();\n    return _this;\n  }\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype.close = function () {\n    this._log.info('WSTransport.close() called...');\n\n    this._close();\n  };\n  /**\n   * Attempt to open a WebSocket connection.\n   */\n\n\n  WSTransport.prototype.open = function () {\n    this._log.info('WSTransport.open() called...');\n\n    if (this._socket && (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN)) {\n      this._log.info('WebSocket already open.');\n\n      return;\n    }\n\n    if (this._preferredUri) {\n      this._connect(this._preferredUri);\n    } else {\n      this._connect(this._uris[this._uriIndex]);\n    }\n  };\n  /**\n   * Send a message through the WebSocket connection.\n   * @param message - A message to send to the endpoint.\n   * @returns Whether the message was sent.\n   */\n\n\n  WSTransport.prototype.send = function (message) {\n    // We can't send the message if the WebSocket isn't open\n    if (!this._socket || this._socket.readyState !== WebSocket.OPEN) {\n      return false;\n    }\n\n    try {\n      this._socket.send(message);\n    } catch (e) {\n      // Some unknown error occurred. Reset the socket to get a fresh session.\n      this._log.info('Error while sending message:', e.message);\n\n      this._closeSocket();\n\n      return false;\n    }\n\n    return true;\n  };\n  /**\n   * Update the preferred URI to connect to. Useful for Call signaling\n   * reconnection, which requires connecting on the same edge. If `null` is\n   * passed, the preferred URI is unset and the original `uris` array and\n   * `uriIndex` is used to determine the signaling URI to connect to.\n   * @param uri\n   */\n\n\n  WSTransport.prototype.updatePreferredURI = function (uri) {\n    this._preferredUri = uri;\n  };\n  /**\n   * Update acceptable URIs to reconnect to. Resets the URI index to 0.\n   */\n\n\n  WSTransport.prototype.updateURIs = function (uris) {\n    if (typeof uris === 'string') {\n      uris = [uris];\n    }\n\n    this._uris = uris;\n    this._uriIndex = 0;\n  };\n  /**\n   * Close the WebSocket, and don't try to reconnect.\n   */\n\n\n  WSTransport.prototype._close = function () {\n    this._setState(WSTransportState.Closed);\n\n    this._closeSocket();\n  };\n  /**\n   * Close the WebSocket and remove all event listeners.\n   */\n\n\n  WSTransport.prototype._closeSocket = function () {\n    clearTimeout(this._connectTimeout);\n    clearTimeout(this._heartbeatTimeout);\n\n    this._log.info('Closing and cleaning up WebSocket...');\n\n    if (!this._socket) {\n      this._log.info('No WebSocket to clean up.');\n\n      return;\n    }\n\n    this._socket.removeEventListener('close', this._onSocketClose);\n\n    this._socket.removeEventListener('error', this._onSocketError);\n\n    this._socket.removeEventListener('message', this._onSocketMessage);\n\n    this._socket.removeEventListener('open', this._onSocketOpen);\n\n    if (this._socket.readyState === WebSocket.CONNECTING || this._socket.readyState === WebSocket.OPEN) {\n      this._socket.close();\n    } // Reset backoff counter if connection was open for long enough to be considered successful\n\n\n    if (this._timeOpened && Date.now() - this._timeOpened > CONNECT_SUCCESS_TIMEOUT) {\n      this._resetBackoffs();\n    }\n\n    if (this.state !== WSTransportState.Closed) {\n      this._performBackoff();\n    }\n\n    delete this._socket;\n    this.emit('close');\n  };\n  /**\n   * Attempt to connect to the endpoint via WebSocket.\n   * @param [uri] - URI string to connect to.\n   * @param [retryCount] - Retry number, if this is a retry. Undefined if\n   *   first attempt, 1+ if a retry.\n   */\n\n\n  WSTransport.prototype._connect = function (uri, retryCount) {\n    var _this = this;\n\n    this._log.info(typeof retryCount === 'number' ? \"Attempting to reconnect (retry #\" + retryCount + \")...\" : 'Attempting to connect...');\n\n    this._closeSocket();\n\n    this._setState(WSTransportState.Connecting);\n\n    this._connectedUri = uri;\n\n    try {\n      this._socket = new this._options.WebSocket(this._connectedUri);\n    } catch (e) {\n      this._log.info('Could not connect to endpoint:', e.message);\n\n      this._close();\n\n      this.emit('error', {\n        code: 31000,\n        message: e.message || \"Could not connect to \" + this._connectedUri,\n        twilioError: new errors_1.SignalingErrors.ConnectionDisconnected()\n      });\n      return;\n    }\n\n    this._socket.addEventListener('close', this._onSocketClose);\n\n    this._socket.addEventListener('error', this._onSocketError);\n\n    this._socket.addEventListener('message', this._onSocketMessage);\n\n    this._socket.addEventListener('open', this._onSocketOpen);\n\n    delete this._timeOpened;\n    this._connectTimeout = setTimeout(function () {\n      _this._log.info('WebSocket connection attempt timed out.');\n\n      _this._moveUriIndex();\n\n      _this._closeSocket();\n    }, this._options.connectTimeoutMs);\n  };\n  /**\n   * Perform a backoff. If a preferred URI is set (not null), then backoff\n   * using the preferred mechanism. Otherwise, use the primary mechanism.\n   */\n\n\n  WSTransport.prototype._performBackoff = function () {\n    if (this._preferredUri) {\n      this._log.info('Preferred URI set; backing off.');\n\n      this._backoff.preferred.backoff();\n    } else {\n      this._log.info('Preferred URI not set; backing off.');\n\n      this._backoff.primary.backoff();\n    }\n  };\n  /**\n   * Reset both primary and preferred backoff mechanisms.\n   */\n\n\n  WSTransport.prototype._resetBackoffs = function () {\n    this._backoff.preferred.reset();\n\n    this._backoff.primary.reset();\n\n    this._backoffStartTime.preferred = null;\n    this._backoffStartTime.primary = null;\n  };\n  /**\n   * Set a timeout to reconnect after HEARTBEAT_TIMEOUT milliseconds\n   *   have passed without receiving a message over the WebSocket.\n   */\n\n\n  WSTransport.prototype._setHeartbeatTimeout = function () {\n    var _this = this;\n\n    clearTimeout(this._heartbeatTimeout);\n    this._heartbeatTimeout = setTimeout(function () {\n      _this._log.info(\"No messages received in \" + HEARTBEAT_TIMEOUT / 1000 + \" seconds. Reconnecting...\");\n\n      _this._shouldFallback = true;\n\n      _this._closeSocket();\n    }, HEARTBEAT_TIMEOUT);\n  };\n  /**\n   * Set the current and previous state\n   */\n\n\n  WSTransport.prototype._setState = function (state) {\n    this._previousState = this.state;\n    this.state = state;\n  };\n  /**\n   * Set up the primary and preferred backoff mechanisms.\n   */\n\n\n  WSTransport.prototype._setupBackoffs = function () {\n    var _this = this;\n\n    var preferredBackoffConfig = {\n      factor: 2.0,\n      maxDelay: this._options.maxPreferredDelayMs,\n      randomisationFactor: 0.40\n    };\n\n    this._log.info('Initializing preferred transport backoff using config: ', preferredBackoffConfig);\n\n    var preferredBackoff = Backoff.exponential(preferredBackoffConfig);\n    preferredBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff initiated but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect Websocket to preferred URI in \" + delay + \"ms\");\n\n      if (attempt === 0) {\n        _this._backoffStartTime.preferred = Date.now();\n\n        _this._log.info(\"Preferred backoff start; \" + _this._backoffStartTime.preferred);\n      }\n    });\n    preferredBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Preferred backoff ready but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      if (_this._backoffStartTime.preferred === null) {\n        _this._log.info('Preferred backoff start time invalid; not attempting a connection.');\n\n        return;\n      }\n\n      if (Date.now() - _this._backoffStartTime.preferred > _this._options.maxPreferredDurationMs) {\n        _this._log.info('Max preferred backoff attempt time exceeded; falling back to primary backoff.');\n\n        _this._preferredUri = null;\n\n        _this._backoff.primary.backoff();\n\n        return;\n      }\n\n      if (typeof _this._preferredUri !== 'string') {\n        _this._log.info('Preferred URI cleared; falling back to primary backoff.');\n\n        _this._preferredUri = null;\n\n        _this._backoff.primary.backoff();\n\n        return;\n      }\n\n      _this._connect(_this._preferredUri, attempt + 1);\n    });\n    var primaryBackoffConfig = {\n      factor: 2.0,\n      // We only want a random initial delay if there are any fallback edges\n      // Initial delay between 1s and 5s both inclusive\n      initialDelay: this._uris && this._uris.length > 1 ? Math.floor(Math.random() * (5000 - 1000 + 1)) + 1000 : 100,\n      maxDelay: this._options.maxPrimaryDelayMs,\n      randomisationFactor: 0.40\n    };\n\n    this._log.info('Initializing primary transport backoff using config: ', primaryBackoffConfig);\n\n    var primaryBackoff = Backoff.exponential(primaryBackoffConfig);\n    primaryBackoff.on('backoff', function (attempt, delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff initiated but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      _this._log.info(\"Will attempt to reconnect WebSocket in \" + delay + \"ms\");\n\n      if (attempt === 0) {\n        _this._backoffStartTime.primary = Date.now();\n\n        _this._log.info(\"Primary backoff start; \" + _this._backoffStartTime.primary);\n      }\n    });\n    primaryBackoff.on('ready', function (attempt, _delay) {\n      if (_this.state === WSTransportState.Closed) {\n        _this._log.info('Primary backoff ready but transport state is closed; not attempting a connection.');\n\n        return;\n      }\n\n      if (_this._backoffStartTime.primary === null) {\n        _this._log.info('Primary backoff start time invalid; not attempting a connection.');\n\n        return;\n      }\n\n      if (Date.now() - _this._backoffStartTime.primary > _this._options.maxPrimaryDurationMs) {\n        _this._log.info('Max primary backoff attempt time exceeded; not attempting a connection.');\n\n        return;\n      }\n\n      _this._connect(_this._uris[_this._uriIndex], attempt + 1);\n    });\n    return {\n      preferred: preferredBackoff,\n      primary: primaryBackoff\n    };\n  };\n\n  Object.defineProperty(WSTransport.prototype, \"uri\", {\n    /**\n     * The uri the transport is currently connected to\n     */\n    get: function () {\n      return this._connectedUri;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  WSTransport.defaultConstructorOptions = {\n    WebSocket: WebSocket,\n    connectTimeoutMs: CONNECT_TIMEOUT,\n    maxPreferredDelayMs: MAX_PREFERRED_DELAY,\n    maxPreferredDurationMs: MAX_PREFERRED_DURATION,\n    maxPrimaryDelayMs: MAX_PRIMARY_DELAY,\n    maxPrimaryDurationMs: MAX_PRIMARY_DURATION\n  };\n  return WSTransport;\n}(events_1.EventEmitter);\n\nexports.default = WSTransport; //# sourceMappingURL=wstransport.js.map","map":null,"metadata":{},"sourceType":"script"}