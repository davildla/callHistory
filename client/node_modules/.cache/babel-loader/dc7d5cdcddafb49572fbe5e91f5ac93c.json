{"ast":null,"code":"import { TransactionStateError } from \"../exceptions/transaction-state-error.js\";\nimport { constructOutgoingResponse } from \"../messages/outgoing-response.js\";\nimport { newTag } from \"../messages/utils.js\";\nimport { InviteServerTransaction } from \"../transactions/invite-server-transaction.js\";\nimport { NonInviteServerTransaction } from \"../transactions/non-invite-server-transaction.js\";\nimport { TransactionState } from \"../transactions/transaction-state.js\";\n/**\n * User Agent Server (UAS).\n * @remarks\n * A user agent server is a logical entity\n * that generates a response to a SIP request.  The response\n * accepts, rejects, or redirects the request.  This role lasts\n * only for the duration of that transaction.  In other words, if\n * a piece of software responds to a request, it acts as a UAS for\n * the duration of that transaction.  If it generates a request\n * later, it assumes the role of a user agent client for the\n * processing of that transaction.\n * https://tools.ietf.org/html/rfc3261#section-6\n * @public\n */\n\nexport class UserAgentServer {\n  constructor(transactionConstructor, core, message, delegate) {\n    this.transactionConstructor = transactionConstructor;\n    this.core = core;\n    this.message = message;\n    this.delegate = delegate;\n    this.logger = this.loggerFactory.getLogger(\"sip.user-agent-server\");\n    this.toTag = message.toTag ? message.toTag : newTag();\n    this.init();\n  }\n\n  dispose() {\n    this.transaction.dispose();\n  }\n\n  get loggerFactory() {\n    return this.core.loggerFactory;\n  }\n  /** The transaction associated with this request. */\n\n\n  get transaction() {\n    if (!this._transaction) {\n      throw new Error(\"Transaction undefined.\");\n    }\n\n    return this._transaction;\n  }\n\n  accept() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 200\n    };\n\n    if (!this.acceptable) {\n      throw new TransactionStateError(`${this.message.method} not acceptable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 200 || statusCode > 299) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  }\n\n  progress() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 180\n    };\n\n    if (!this.progressable) {\n      throw new TransactionStateError(`${this.message.method} not progressable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 101 || statusCode > 199) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  }\n\n  redirect(contacts) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      statusCode: 302\n    };\n\n    if (!this.redirectable) {\n      throw new TransactionStateError(`${this.message.method} not redirectable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 300 || statusCode > 399) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const contactHeaders = new Array();\n    contacts.forEach(contact => contactHeaders.push(`Contact: ${contact.toString()}`));\n    options.extraHeaders = (options.extraHeaders || []).concat(contactHeaders);\n    const response = this.reply(options);\n    return response;\n  }\n\n  reject() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      statusCode: 480\n    };\n\n    if (!this.rejectable) {\n      throw new TransactionStateError(`${this.message.method} not rejectable in state ${this.transaction.state}.`);\n    }\n\n    const statusCode = options.statusCode;\n\n    if (statusCode < 400 || statusCode > 699) {\n      throw new TypeError(`Invalid statusCode: ${statusCode}`);\n    }\n\n    const response = this.reply(options);\n    return response;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  trying(options) {\n    if (!this.tryingable) {\n      throw new TransactionStateError(`${this.message.method} not tryingable in state ${this.transaction.state}.`);\n    }\n\n    const response = this.reply({\n      statusCode: 100\n    });\n    return response;\n  }\n  /**\n   * If the UAS did not find a matching transaction for the CANCEL\n   * according to the procedure above, it SHOULD respond to the CANCEL\n   * with a 481 (Call Leg/Transaction Does Not Exist).  If the transaction\n   * for the original request still exists, the behavior of the UAS on\n   * receiving a CANCEL request depends on whether it has already sent a\n   * final response for the original request.  If it has, the CANCEL\n   * request has no effect on the processing of the original request, no\n   * effect on any session state, and no effect on the responses generated\n   * for the original request.  If the UAS has not issued a final response\n   * for the original request, its behavior depends on the method of the\n   * original request.  If the original request was an INVITE, the UAS\n   * SHOULD immediately respond to the INVITE with a 487 (Request\n   * Terminated).  A CANCEL request has no impact on the processing of\n   * transactions with any other method defined in this specification.\n   * https://tools.ietf.org/html/rfc3261#section-9.2\n   * @param request - Incoming CANCEL request.\n   */\n\n\n  receiveCancel(message) {\n    // Note: Currently CANCEL is being handled as a special case.\n    // No UAS is created to handle the CANCEL and the response to\n    // it CANCEL is being handled statelessly by the user agent core.\n    // As such, there is currently no way to externally impact the\n    // response to the a CANCEL request.\n    if (this.delegate && this.delegate.onCancel) {\n      this.delegate.onCancel(message);\n    }\n  }\n\n  get acceptable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding || this.transaction.state === TransactionState.Accepted;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get progressable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return false; // https://tools.ietf.org/html/rfc4320#section-4.1\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get redirectable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get rejectable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying || this.transaction.state === TransactionState.Proceeding;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n\n  get tryingable() {\n    if (this.transaction instanceof InviteServerTransaction) {\n      return this.transaction.state === TransactionState.Proceeding;\n    }\n\n    if (this.transaction instanceof NonInviteServerTransaction) {\n      return this.transaction.state === TransactionState.Trying;\n    }\n\n    throw new Error(\"Unknown transaction type.\");\n  }\n  /**\n   * When a UAS wishes to construct a response to a request, it follows\n   * the general procedures detailed in the following subsections.\n   * Additional behaviors specific to the response code in question, which\n   * are not detailed in this section, may also be required.\n   *\n   * Once all procedures associated with the creation of a response have\n   * been completed, the UAS hands the response back to the server\n   * transaction from which it received the request.\n   * https://tools.ietf.org/html/rfc3261#section-8.2.6\n   * @param statusCode - Status code to reply with.\n   * @param options - Reply options bucket.\n   */\n\n\n  reply(options) {\n    if (!options.toTag && options.statusCode !== 100) {\n      options.toTag = this.toTag;\n    }\n\n    options.userAgent = options.userAgent || this.core.configuration.userAgentHeaderFieldValue;\n    options.supported = options.supported || this.core.configuration.supportedOptionTagsResponse;\n    const response = constructOutgoingResponse(this.message, options);\n    this.transaction.receiveResponse(options.statusCode, response.message);\n    return response;\n  }\n\n  init() {\n    // We are the transaction user.\n    const user = {\n      loggerFactory: this.loggerFactory,\n      onStateChange: newState => {\n        if (newState === TransactionState.Terminated) {\n          // Remove the terminated transaction from the core.\n          // eslint-disable-next-line @typescript-eslint/no-use-before-define\n          this.core.userAgentServers.delete(userAgentServerId);\n          this.dispose();\n        }\n      },\n      onTransportError: error => {\n        this.logger.error(error.message);\n\n        if (this.delegate && this.delegate.onTransportError) {\n          this.delegate.onTransportError(error);\n        } else {\n          this.logger.error(\"User agent server response transport error.\");\n        }\n      }\n    }; // Create a new transaction with us as the user.\n\n    const transaction = new this.transactionConstructor(this.message, this.core.transport, user);\n    this._transaction = transaction; // Add the new transaction to the core.\n\n    const userAgentServerId = transaction.id;\n    this.core.userAgentServers.set(transaction.id, this);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}