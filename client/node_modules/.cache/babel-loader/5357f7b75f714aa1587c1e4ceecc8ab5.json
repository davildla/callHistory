{"ast":null,"code":"import { C } from \"../messages/methods/constants.js\";\nimport { Timers } from \"../timers.js\";\nimport { ServerTransaction } from \"./server-transaction.js\";\nimport { TransactionState } from \"./transaction-state.js\";\n/**\n * INVITE Server Transaction.\n * @remarks\n * https://tools.ietf.org/html/rfc3261#section-17.2.1\n * @public\n */\n\nexport class InviteServerTransaction extends ServerTransaction {\n  /**\n   * Constructor.\n   * Upon construction, a \"100 Trying\" reply will be immediately sent.\n   * After construction the transaction will be in the \"proceeding\" state and the transaction\n   * `id` will equal the branch parameter set in the Via header of the incoming request.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   * @param request - Incoming INVITE request from the transport.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Proceeding, \"sip.transaction.ist\");\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    this.stopProgressExtensionTimer();\n\n    if (this.H) {\n      clearTimeout(this.H);\n      this.H = undefined;\n    }\n\n    if (this.I) {\n      clearTimeout(this.I);\n      this.I = undefined;\n    }\n\n    if (this.L) {\n      clearTimeout(this.L);\n      this.L = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"ist\";\n  }\n  /**\n   * Receive requests from transport matching this transaction.\n   * @param request - Request matching this transaction.\n   */\n\n\n  receiveRequest(request) {\n    switch (this.state) {\n      case TransactionState.Proceeding:\n        // If a request retransmission is received while in the \"Proceeding\" state, the most\n        // recent provisional response that was received from the TU MUST be passed to the\n        // transport layer for retransmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE) {\n          if (this.lastProvisionalResponse) {\n            this.send(this.lastProvisionalResponse).catch(error => {\n              this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n            });\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // While in the \"Accepted\" state, any retransmissions of the INVITE\n        // received will match this transaction state machine and will be\n        // absorbed by the machine without changing its state. These\n        // retransmissions are not passed onto the TU.\n        // https://tools.ietf.org/html/rfc6026#section-7.1\n        if (request.method === C.INVITE) {\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // Furthermore, while in the \"Completed\" state, if a request retransmission is\n        // received, the server SHOULD pass the response to the transport for retransmission.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE) {\n          if (!this.lastFinalResponse) {\n            throw new Error(\"Last final response undefined.\");\n          }\n\n          this.send(this.lastFinalResponse).catch(error => {\n            this.logTransportError(error, \"Failed to send retransmission of final response.\");\n          });\n          return;\n        } // If an ACK is received while the server transaction is in the \"Completed\" state,\n        // the server transaction MUST transition to the \"Confirmed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n        if (request.method === C.ACK) {\n          this.stateTransition(TransactionState.Confirmed);\n          return;\n        }\n\n        break;\n\n      case TransactionState.Confirmed:\n        // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n        // triggered from retransmissions of the final response.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (request.method === C.INVITE || request.method === C.ACK) {\n          return;\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        // For good measure absorb any additional messages that arrive (should not happen).\n        if (request.method === C.INVITE || request.method === C.ACK) {\n          return;\n        }\n\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `INVITE server transaction received unexpected ${request.method} request while in state ${this.state}.`;\n    this.logger.warn(message);\n    return;\n  }\n  /**\n   * Receive responses from TU for this transaction.\n   * @param statusCode - Status code of response.\n   * @param response - Response.\n   */\n\n\n  receiveResponse(statusCode, response) {\n    if (statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    switch (this.state) {\n      case TransactionState.Proceeding:\n        // The TU passes any number of provisional responses to the server\n        // transaction. So long as the server transaction is in the\n        // \"Proceeding\" state, each of these MUST be passed to the transport\n        // layer for transmission. They are not sent reliably by the\n        // transaction layer (they are not retransmitted by it) and do not cause\n        // a change in the state of the server transaction.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n        if (statusCode >= 100 && statusCode <= 199) {\n          this.lastProvisionalResponse = response; // Start the progress extension timer only for a non-100 provisional response.\n\n          if (statusCode > 100) {\n            this.startProgressExtensionTimer(); // FIXME: remove\n          }\n\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 1xx response.\");\n          });\n          return;\n        } // If, while in the \"Proceeding\" state, the TU passes a 2xx response\n        // to the server transaction, the server transaction MUST pass this\n        // response to the transport layer for transmission. It is not\n        // retransmitted by the server transaction; retransmissions of 2xx\n        // responses are handled by the TU. The server transaction MUST then\n        // transition to the \"Accepted\" state.\n        // https://tools.ietf.org/html/rfc6026#section-8.5\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.lastFinalResponse = response;\n          this.stateTransition(TransactionState.Accepted);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 2xx response.\");\n          });\n          return;\n        } // While in the \"Proceeding\" state, if the TU passes a response with\n        // status code from 300 to 699 to the server transaction, the response\n        // MUST be passed to the transport layer for transmission, and the state\n        // machine MUST enter the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.lastFinalResponse = response;\n          this.stateTransition(TransactionState.Completed);\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send non-2xx final response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // While in the \"Accepted\" state, if the TU passes a 2xx response,\n        // the server transaction MUST pass the response to the transport layer for transmission.\n        // https://tools.ietf.org/html/rfc6026#section-8.7\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.send(response).catch(error => {\n            this.logTransportError(error, \"Failed to send 2xx response.\");\n          });\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        break;\n\n      case TransactionState.Confirmed:\n        break;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `INVITE server transaction received unexpected ${statusCode} response from TU while in state ${this.state}.`;\n    this.logger.error(message);\n    throw new Error(message);\n  }\n  /**\n   * Retransmit the last 2xx response. This is a noop if not in the \"accepted\" state.\n   */\n\n\n  retransmitAcceptedResponse() {\n    if (this.state === TransactionState.Accepted && this.lastFinalResponse) {\n      this.send(this.lastFinalResponse).catch(error => {\n        this.logTransportError(error, \"Failed to send 2xx response.\");\n      });\n    }\n  }\n  /**\n   * First, the procedures in [4] are followed, which attempt to deliver the response to a backup.\n   * If those should all fail, based on the definition of failure in [4], the server transaction SHOULD\n   * inform the TU that a failure has occurred, and MUST remain in the current state.\n   * https://tools.ietf.org/html/rfc6026#section-8.8\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"INVITE server transaction\";\n  }\n  /**\n   * Execute a state transition.\n   * @param newState - New state.\n   */\n\n\n  stateTransition(newState) {\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Proceeding:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Accepted:\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Confirmed:\n        if (this.state !== TransactionState.Completed) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed && this.state !== TransactionState.Confirmed) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // On any state transition, stop resending provisional responses\n\n\n    this.stopProgressExtensionTimer(); // The purpose of the \"Accepted\" state is to absorb retransmissions of an accepted INVITE request.\n    // Any such retransmissions are absorbed entirely within the server transaction.\n    // They are not passed up to the TU since any downstream UAS cores that accepted the request have\n    // taken responsibility for reliability and will already retransmit their 2xx responses if necessary.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n    if (newState === TransactionState.Accepted) {\n      this.L = setTimeout(() => this.timerL(), Timers.TIMER_L);\n    } // When the \"Completed\" state is entered, timer H MUST be set to fire in 64*T1 seconds for all transports.\n    // Timer H determines when the server transaction abandons retransmitting the response.\n    // If an ACK is received while the server transaction is in the \"Completed\" state,\n    // the server transaction MUST transition to the \"Confirmed\" state.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n    if (newState === TransactionState.Completed) {\n      // FIXME: Missing timer G for unreliable transports.\n      this.H = setTimeout(() => this.timerH(), Timers.TIMER_H);\n    } // The purpose of the \"Confirmed\" state is to absorb any additional ACK messages that arrive,\n    // triggered from retransmissions of the final response. When this state is entered, timer I\n    // is set to fire in T4 seconds for unreliable transports, and zero seconds for reliable\n    // transports. Once timer I fires, the server MUST transition to the \"Terminated\" state.\n    // https://tools.ietf.org/html/rfc3261#section-17.2.1\n\n\n    if (newState === TransactionState.Confirmed) {\n      // FIXME: This timer is not getting set correctly for unreliable transports.\n      this.I = setTimeout(() => this.timerI(), Timers.TIMER_I);\n    } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    } // Update state.\n\n\n    this.setState(newState);\n  }\n  /**\n   * FIXME: UAS Provisional Retransmission Timer. See RFC 3261 Section 13.3.1.1\n   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n   */\n\n\n  startProgressExtensionTimer() {\n    // Start the progress extension timer only for the first non-100 provisional response.\n    if (this.progressExtensionTimer === undefined) {\n      this.progressExtensionTimer = setInterval(() => {\n        this.logger.debug(`Progress extension timer expired for INVITE server transaction ${this.id}.`);\n\n        if (!this.lastProvisionalResponse) {\n          throw new Error(\"Last provisional response undefined.\");\n        }\n\n        this.send(this.lastProvisionalResponse).catch(error => {\n          this.logTransportError(error, \"Failed to send retransmission of provisional response.\");\n        });\n      }, Timers.PROVISIONAL_RESPONSE_INTERVAL);\n    }\n  }\n  /**\n   * FIXME: UAS Provisional Retransmission Timer id. See RFC 3261 Section 13.3.1.1\n   * This is in the wrong place. This is not a transaction level thing. It's a UAS level thing.\n   */\n\n\n  stopProgressExtensionTimer() {\n    if (this.progressExtensionTimer !== undefined) {\n      clearInterval(this.progressExtensionTimer);\n      this.progressExtensionTimer = undefined;\n    }\n  }\n  /**\n   * While in the \"Proceeding\" state, if the TU passes a response with status code\n   * from 300 to 699 to the server transaction, the response MUST be passed to the\n   * transport layer for transmission, and the state machine MUST enter the \"Completed\" state.\n   * For unreliable transports, timer G is set to fire in T1 seconds, and is not set to fire for\n   * reliable transports. If timer G fires, the response is passed to the transport layer once\n   * more for retransmission, and timer G is set to fire in MIN(2*T1, T2) seconds. From then on,\n   * when timer G fires, the response is passed to the transport again for transmission, and\n   * timer G is reset with a value that doubles, unless that value exceeds T2, in which case\n   * it is reset with the value of T2.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerG() {// TODO\n  }\n  /**\n   * If timer H fires while in the \"Completed\" state, it implies that the ACK was never received.\n   * In this case, the server transaction MUST transition to the \"Terminated\" state, and MUST\n   * indicate to the TU that a transaction failure has occurred.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerH() {\n    this.logger.debug(`Timer H expired for INVITE server transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Completed) {\n      this.logger.warn(\"ACK to negative final response was never received, terminating transaction.\");\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * Once timer I fires, the server MUST transition to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.2.1\n   */\n\n\n  timerI() {\n    this.logger.debug(`Timer I expired for INVITE server transaction ${this.id}.`);\n    this.stateTransition(TransactionState.Terminated);\n  }\n  /**\n   * When Timer L fires and the state machine is in the \"Accepted\" state, the machine MUST\n   * transition to the \"Terminated\" state. Once the transaction is in the \"Terminated\" state,\n   * it MUST be destroyed immediately. Timer L reflects the amount of time the server\n   * transaction could receive 2xx responses for retransmission from the\n   * TU while it is waiting to receive an ACK.\n   * https://tools.ietf.org/html/rfc6026#section-7.1\n   * https://tools.ietf.org/html/rfc6026#section-8.7\n   */\n\n\n  timerL() {\n    this.logger.debug(`Timer L expired for INVITE server transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Accepted) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}