{"ast":null,"code":"import { fromBodyLegacy } from \"../core/messages/body.js\";\nimport { C } from \"../core/messages/methods/constants.js\";\nimport { EmitterImpl } from \"./emitter.js\";\nimport { PublisherState } from \"./publisher-state.js\";\n/**\n * A publisher publishes a publication (outgoing PUBLISH).\n * @public\n */\n\nexport class Publisher {\n  /**\n   * Constructs a new instance of the `Publisher` class.\n   *\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param targetURI - Request URI identifying the target of the message.\n   * @param eventType - The event type identifying the published document.\n   * @param options - Options bucket. See {@link PublisherOptions} for details.\n   */\n  constructor(userAgent, targetURI, eventType) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.disposed = false;\n    /** The publication state. */\n\n    this._state = PublisherState.Initial; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl();\n    this.userAgent = userAgent;\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.contentType = options.contentType || \"text/plain\";\n\n    if (typeof options.expires !== \"number\" || options.expires % 1 !== 0) {\n      options.expires = 3600;\n    } else {\n      options.expires = Number(options.expires);\n    }\n\n    if (typeof options.unpublishOnClose !== \"boolean\") {\n      options.unpublishOnClose = true;\n    }\n\n    this.target = targetURI;\n    this.event = eventType;\n    this.options = options;\n    this.pubRequestExpires = options.expires;\n    this.logger = userAgent.getLogger(\"sip.Publisher\");\n    const params = options.params || {};\n    const fromURI = params.fromUri ? params.fromUri : userAgent.userAgentCore.configuration.aor;\n    const toURI = params.toUri ? params.toUri : targetURI;\n    let body;\n\n    if (options.body && options.contentType) {\n      const contentDisposition = \"render\";\n      const contentType = options.contentType;\n      const content = options.body;\n      body = {\n        contentDisposition,\n        contentType,\n        content\n      };\n    }\n\n    const extraHeaders = (options.extraHeaders || []).slice(); // Build the request\n\n    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.PUBLISH, targetURI, fromURI, toURI, params, extraHeaders, body); // Identifier\n\n    this.id = this.target.toString() + \":\" + this.event; // Add to the user agent's publisher collection.\n\n    this.userAgent._publishers[this.id] = this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true;\n    this.logger.log(`Publisher ${this.id} in state ${this.state} is being disposed`); // Remove from the user agent's publisher collection\n\n    delete this.userAgent._publishers[this.id]; // Send unpublish, if requested\n\n    if (this.options.unpublishOnClose && this.state === PublisherState.Published) {\n      return this.unpublish();\n    }\n\n    if (this.publishRefreshTimer) {\n      clearTimeout(this.publishRefreshTimer);\n      this.publishRefreshTimer = undefined;\n    }\n\n    this.pubRequestBody = undefined;\n    this.pubRequestExpires = 0;\n    this.pubRequestEtag = undefined;\n    return Promise.resolve();\n  }\n  /** The publication state. */\n\n\n  get state() {\n    return this._state;\n  }\n  /** Emits when the publisher state changes. */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * Publish.\n   * @param content - Body to publish\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  publish(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // Clean up before the run\n    if (this.publishRefreshTimer) {\n      clearTimeout(this.publishRefreshTimer);\n      this.publishRefreshTimer = undefined;\n    } // is Initial or Modify request\n\n\n    this.options.body = content;\n    this.pubRequestBody = this.options.body;\n\n    if (this.pubRequestExpires === 0) {\n      // This is Initial request after unpublish\n      if (this.options.expires === undefined) {\n        throw new Error(\"Expires undefined.\");\n      }\n\n      this.pubRequestExpires = this.options.expires;\n      this.pubRequestEtag = undefined;\n    }\n\n    this.sendPublishRequest();\n    return Promise.resolve();\n  }\n  /**\n   * Unpublish.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  unpublish() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Clean up before the run\n    if (this.publishRefreshTimer) {\n      clearTimeout(this.publishRefreshTimer);\n      this.publishRefreshTimer = undefined;\n    }\n\n    this.pubRequestBody = undefined;\n    this.pubRequestExpires = 0;\n\n    if (this.pubRequestEtag !== undefined) {\n      this.sendPublishRequest();\n    }\n\n    return Promise.resolve();\n  }\n  /** @internal */\n\n\n  receiveResponse(response) {\n    const statusCode = response.statusCode || 0;\n\n    switch (true) {\n      case /^1[0-9]{2}$/.test(statusCode.toString()):\n        break;\n\n      case /^2[0-9]{2}$/.test(statusCode.toString()):\n        // Set SIP-Etag\n        if (response.hasHeader(\"SIP-ETag\")) {\n          this.pubRequestEtag = response.getHeader(\"SIP-ETag\");\n        } else {\n          this.logger.warn(\"SIP-ETag header missing in a 200-class response to PUBLISH\");\n        } // Update Expire\n\n\n        if (response.hasHeader(\"Expires\")) {\n          const expires = Number(response.getHeader(\"Expires\"));\n\n          if (typeof expires === \"number\" && expires >= 0 && expires <= this.pubRequestExpires) {\n            this.pubRequestExpires = expires;\n          } else {\n            this.logger.warn(\"Bad Expires header in a 200-class response to PUBLISH\");\n          }\n        } else {\n          this.logger.warn(\"Expires header missing in a 200-class response to PUBLISH\");\n        }\n\n        if (this.pubRequestExpires !== 0) {\n          // Schedule refresh\n          this.publishRefreshTimer = setTimeout(() => this.refreshRequest(), this.pubRequestExpires * 900);\n\n          if (this._state !== PublisherState.Published) {\n            this.stateTransition(PublisherState.Published);\n          }\n        } else {\n          this.stateTransition(PublisherState.Unpublished);\n        }\n\n        break;\n\n      case /^412$/.test(statusCode.toString()):\n        // 412 code means no matching ETag - possibly the PUBLISH expired\n        // Resubmit as new request, if the current request is not a \"remove\"\n        if (this.pubRequestEtag !== undefined && this.pubRequestExpires !== 0) {\n          this.logger.warn(\"412 response to PUBLISH, recovering\");\n          this.pubRequestEtag = undefined;\n\n          if (this.options.body === undefined) {\n            throw new Error(\"Body undefined.\");\n          }\n\n          this.publish(this.options.body);\n        } else {\n          this.logger.warn(\"412 response to PUBLISH, recovery failed\");\n          this.pubRequestExpires = 0;\n          this.stateTransition(PublisherState.Unpublished);\n          this.stateTransition(PublisherState.Terminated);\n        }\n\n        break;\n\n      case /^423$/.test(statusCode.toString()):\n        // 423 code means we need to adjust the Expires interval up\n        if (this.pubRequestExpires !== 0 && response.hasHeader(\"Min-Expires\")) {\n          const minExpires = Number(response.getHeader(\"Min-Expires\"));\n\n          if (typeof minExpires === \"number\" || minExpires > this.pubRequestExpires) {\n            this.logger.warn(\"423 code in response to PUBLISH, adjusting the Expires value and trying to recover\");\n            this.pubRequestExpires = minExpires;\n\n            if (this.options.body === undefined) {\n              throw new Error(\"Body undefined.\");\n            }\n\n            this.publish(this.options.body);\n          } else {\n            this.logger.warn(\"Bad 423 response Min-Expires header received for PUBLISH\");\n            this.pubRequestExpires = 0;\n            this.stateTransition(PublisherState.Unpublished);\n            this.stateTransition(PublisherState.Terminated);\n          }\n        } else {\n          this.logger.warn(\"423 response to PUBLISH, recovery failed\");\n          this.pubRequestExpires = 0;\n          this.stateTransition(PublisherState.Unpublished);\n          this.stateTransition(PublisherState.Terminated);\n        }\n\n        break;\n\n      default:\n        this.pubRequestExpires = 0;\n        this.stateTransition(PublisherState.Unpublished);\n        this.stateTransition(PublisherState.Terminated);\n        break;\n    } // Do the cleanup\n\n\n    if (this.pubRequestExpires === 0) {\n      if (this.publishRefreshTimer) {\n        clearTimeout(this.publishRefreshTimer);\n        this.publishRefreshTimer = undefined;\n      }\n\n      this.pubRequestBody = undefined;\n      this.pubRequestEtag = undefined;\n    }\n  }\n  /** @internal */\n\n\n  send() {\n    return this.userAgent.userAgentCore.publish(this.request, {\n      onAccept: response => this.receiveResponse(response.message),\n      onProgress: response => this.receiveResponse(response.message),\n      onRedirect: response => this.receiveResponse(response.message),\n      onReject: response => this.receiveResponse(response.message),\n      onTrying: response => this.receiveResponse(response.message)\n    });\n  }\n\n  refreshRequest() {\n    // Clean up before the run\n    if (this.publishRefreshTimer) {\n      clearTimeout(this.publishRefreshTimer);\n      this.publishRefreshTimer = undefined;\n    } // This is Refresh request\n\n\n    this.pubRequestBody = undefined;\n\n    if (this.pubRequestEtag === undefined) {\n      throw new Error(\"Etag undefined\");\n    }\n\n    if (this.pubRequestExpires === 0) {\n      throw new Error(\"Expires zero\");\n    }\n\n    this.sendPublishRequest();\n  }\n\n  sendPublishRequest() {\n    const reqOptions = Object.assign({}, this.options);\n    reqOptions.extraHeaders = (this.options.extraHeaders || []).slice();\n    reqOptions.extraHeaders.push(\"Event: \" + this.event);\n    reqOptions.extraHeaders.push(\"Expires: \" + this.pubRequestExpires);\n\n    if (this.pubRequestEtag !== undefined) {\n      reqOptions.extraHeaders.push(\"SIP-If-Match: \" + this.pubRequestEtag);\n    }\n\n    const ruri = this.target;\n    const params = this.options.params || {};\n    let bodyAndContentType;\n\n    if (this.pubRequestBody !== undefined) {\n      if (this.options.contentType === undefined) {\n        throw new Error(\"Content type undefined.\");\n      }\n\n      bodyAndContentType = {\n        body: this.pubRequestBody,\n        contentType: this.options.contentType\n      };\n    }\n\n    let body;\n\n    if (bodyAndContentType) {\n      body = fromBodyLegacy(bodyAndContentType);\n    }\n\n    this.request = this.userAgent.userAgentCore.makeOutgoingRequestMessage(C.PUBLISH, ruri, params.fromUri ? params.fromUri : this.userAgent.userAgentCore.configuration.aor, params.toUri ? params.toUri : this.target, params, reqOptions.extraHeaders, body);\n    return this.send();\n  }\n  /**\n   * Transition publication state.\n   */\n\n\n  stateTransition(newState) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate transition\n\n\n    switch (this._state) {\n      case PublisherState.Initial:\n        if (newState !== PublisherState.Published && newState !== PublisherState.Unpublished && newState !== PublisherState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case PublisherState.Published:\n        if (newState !== PublisherState.Unpublished && newState !== PublisherState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case PublisherState.Unpublished:\n        if (newState !== PublisherState.Published && newState !== PublisherState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case PublisherState.Terminated:\n        invalidTransition();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    } // Transition\n\n\n    this._state = newState;\n    this.logger.log(`Publication transitioned to state ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); // Dispose\n\n\n    if (newState === PublisherState.Terminated) {\n      this.dispose();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}