{"ast":null,"code":"import { TransportError } from \"../exceptions/transport-error.js\";\n/**\n * Transaction.\n * @remarks\n * SIP is a transactional protocol: interactions between components take\n * place in a series of independent message exchanges.  Specifically, a\n * SIP transaction consists of a single request and any responses to\n * that request, which include zero or more provisional responses and\n * one or more final responses.  In the case of a transaction where the\n * request was an INVITE (known as an INVITE transaction), the\n * transaction also includes the ACK only if the final response was not\n * a 2xx response.  If the response was a 2xx, the ACK is not considered\n * part of the transaction.\n * https://tools.ietf.org/html/rfc3261#section-17\n * @public\n */\n\nexport class Transaction {\n  constructor(_transport, _user, _id, _state, loggerCategory) {\n    this._transport = _transport;\n    this._user = _user;\n    this._id = _id;\n    this._state = _state;\n    this.listeners = new Array();\n    this.logger = _user.loggerFactory.getLogger(loggerCategory, _id);\n    this.logger.debug(`Constructing ${this.typeToString()} with id ${this.id}.`);\n  }\n  /**\n   * Destructor.\n   * Once the transaction is in the \"terminated\" state, it is destroyed\n   * immediately and there is no need to call `dispose`. However, if a\n   * transaction needs to be ended prematurely, the transaction user may\n   * do so by calling this method (for example, perhaps the UA is shutting down).\n   * No state transition will occur upon calling this method, all outstanding\n   * transmission timers will be cancelled, and use of the transaction after\n   * calling `dispose` is undefined.\n   */\n\n\n  dispose() {\n    this.logger.debug(`Destroyed ${this.typeToString()} with id ${this.id}.`);\n  }\n  /** Transaction id. */\n\n\n  get id() {\n    return this._id;\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    throw new Error(\"Invalid kind.\");\n  }\n  /** Transaction state. */\n\n\n  get state() {\n    return this._state;\n  }\n  /** Transaction transport. */\n\n\n  get transport() {\n    return this._transport;\n  }\n  /**\n   * Sets up a function that will be called whenever the transaction state changes.\n   * @param listener - Callback function.\n   * @param options - An options object that specifies characteristics about the listener.\n   *                  If once true, indicates that the listener should be invoked at most once after being added.\n   *                  If once true, the listener would be automatically removed when invoked.\n   */\n\n\n  addStateChangeListener(listener, options) {\n    const onceWrapper = () => {\n      this.removeStateChangeListener(onceWrapper);\n      listener();\n    };\n\n    (options === null || options === void 0 ? void 0 : options.once) === true ? this.listeners.push(onceWrapper) : this.listeners.push(listener);\n  }\n  /**\n   * This is currently public so tests may spy on it.\n   * @internal\n   */\n\n\n  notifyStateChangeListeners() {\n    this.listeners.slice().forEach(listener => listener());\n  }\n  /**\n   * Removes a listener previously registered with addStateListener.\n   * @param listener - Callback function.\n   */\n\n\n  removeStateChangeListener(listener) {\n    this.listeners = this.listeners.filter(l => l !== listener);\n  }\n\n  logTransportError(error, message) {\n    this.logger.error(error.message);\n    this.logger.error(`Transport error occurred in ${this.typeToString()} with id ${this.id}.`);\n    this.logger.error(message);\n  }\n  /**\n   * Pass message to transport for transmission. If transport fails,\n   * the transaction user is notified by callback to onTransportError().\n   * @returns\n   * Rejects with `TransportError` if transport fails.\n   */\n\n\n  send(message) {\n    return this.transport.send(message).catch(error => {\n      // If the transport rejects, it SHOULD reject with a TransportError.\n      // But the transport may be external code, so we are careful\n      // make sure we convert it to a TransportError if need be.\n      if (error instanceof TransportError) {\n        this.onTransportError(error);\n        throw error;\n      }\n\n      let transportError;\n\n      if (error && typeof error.message === \"string\") {\n        transportError = new TransportError(error.message);\n      } else {\n        transportError = new TransportError();\n      }\n\n      this.onTransportError(transportError);\n      throw transportError;\n    });\n  }\n\n  setState(state) {\n    this.logger.debug(`State change to \"${state}\" on ${this.typeToString()} with id ${this.id}.`);\n    this._state = state;\n\n    if (this._user.onStateChange) {\n      this._user.onStateChange(state);\n    }\n\n    this.notifyStateChangeListeners();\n  }\n\n  typeToString() {\n    return \"UnknownType\";\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}