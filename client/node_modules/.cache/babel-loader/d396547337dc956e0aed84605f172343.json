{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\n\nvar events_1 = require(\"events\");\n\nvar audiohelper_1 = require(\"./audiohelper\");\n\nvar connection_1 = require(\"./connection\");\n\nvar dialtonePlayer_1 = require(\"./dialtonePlayer\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar preflight_1 = require(\"./preflight/preflight\");\n\nvar regions_1 = require(\"./regions\");\n\nvar util_1 = require(\"./util\");\n\nvar C = require('./constants');\n\nvar Publisher = require('./eventpublisher');\n\nvar PStream = require('./pstream');\n\nvar rtc = require('./rtc');\n\nvar getUserMedia = require('./rtc/getusermedia');\n\nvar Sound = require('./sound');\n\nvar REGISTRATION_INTERVAL = 30000;\nvar RINGTONE_PLAY_TIMEOUT = 2000;\nvar hasBeenWarnedHandlers = false;\nvar hasBeenWarnedSounds = false;\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\n\nvar Device =\n/** @class */\nfunction (_super) {\n  __extends(Device, _super);\n\n  function Device(token, options) {\n    var _a;\n\n    var _this = _super.call(this) || this;\n    /**\n     * The AudioHelper instance associated with this {@link Device}.\n     */\n\n\n    _this.audio = null;\n    /**\n     * An array of {@link Connection}s. Though only one can be active, multiple may exist when there\n     * are multiple incoming, unanswered {@link Connection}s.\n     */\n\n    _this.connections = [];\n    /**\n     * Whether or not {@link Device.setup} has been called.\n     */\n\n    _this.isInitialized = false;\n    /**\n     * Methods to enable/disable each sound. Empty if the {@link Device} has not\n     * yet been set up.\n     */\n\n    _this.sounds = {};\n    /**\n     * The JWT string currently being used to authenticate this {@link Device}.\n     */\n\n    _this.token = null;\n    /**\n     * The currently active {@link Connection}, if there is one.\n     */\n\n    _this._activeConnection = null;\n    /**\n     * The list of chunder URIs that will be passed to PStream\n     */\n\n    _this._chunderURIs = [];\n    /**\n     * An audio input MediaStream to pass to new {@link Connection} instances.\n     */\n\n    _this._connectionInputStream = null;\n    /**\n     * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n     * new {@link Connection} instances.\n     */\n\n    _this._connectionSinkIds = ['default'];\n    /**\n     * The name of the edge the {@link Device} is connected to.\n     */\n\n    _this._edge = null;\n    /**\n     * Whether each sound is enabled.\n     */\n\n    _this._enabledSounds = (_a = {}, _a[Device.SoundName.Disconnect] = true, _a[Device.SoundName.Incoming] = true, _a[Device.SoundName.Outgoing] = true, _a);\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * An Insights Event Publisher.\n     */\n\n    _this._publisher = null;\n    /**\n     * The region the {@link Device} is connected to.\n     */\n\n    _this._region = null;\n    /**\n     * The current status of the {@link Device}.\n     */\n\n    _this._status = Device.Status.Offline;\n    /**\n     * Value of 'audio' determines whether we should be registered for incoming calls.\n     */\n\n    _this.mediaPresence = {\n      audio: true\n    };\n    /**\n     * The options passed to {@link Device} constructor or Device.setup.\n     */\n\n    _this.options = {\n      allowIncomingWhileBusy: false,\n      audioConstraints: true,\n      closeProtection: false,\n      codecPreferences: [connection_1.default.Codec.PCMU, connection_1.default.Codec.Opus],\n      connectionFactory: connection_1.default,\n      debug: false,\n      dscp: true,\n      enableIceRestart: false,\n      eventgw: 'eventgw.twilio.com',\n      forceAggressiveIceNomination: false,\n      iceServers: [],\n      noRegister: false,\n      pStreamFactory: PStream,\n      preflight: false,\n      rtcConstraints: {},\n      soundFactory: Sound,\n      sounds: {},\n      warnings: true\n    };\n    /**\n     * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n     */\n\n    _this.regTimer = null;\n    /**\n     * A Map of Sounds to play.\n     */\n\n    _this.soundcache = new Map();\n    /**\n     * The Signaling stream.\n     */\n\n    _this.stream = null;\n    /**\n     * Destroy the {@link Device}, freeing references to be garbage collected.\n     */\n\n    _this.destroy = function () {\n      _this._disconnectAll();\n\n      _this._stopRegistrationTimer();\n\n      if (_this.audio) {\n        _this.audio._unbind();\n      }\n\n      if (_this.stream) {\n        _this.stream.destroy();\n\n        _this.stream = null;\n      }\n\n      if (_this._networkInformation && typeof _this._networkInformation.removeEventListener === 'function') {\n        _this._networkInformation.removeEventListener('change', _this._publishNetworkChange);\n      }\n\n      if (typeof window !== 'undefined' && window.removeEventListener) {\n        window.removeEventListener('beforeunload', _this._confirmClose);\n        window.removeEventListener('unload', _this.destroy);\n        window.removeEventListener('pagehide', _this.destroy);\n      }\n    };\n    /**\n     * Called on window's beforeunload event if closeProtection is enabled,\n     * preventing users from accidentally navigating away from an active call.\n     * @param event\n     */\n\n\n    _this._confirmClose = function (event) {\n      if (!_this._activeConnection) {\n        return '';\n      }\n\n      var closeProtection = _this.options.closeProtection || false;\n      var confirmationMsg = typeof closeProtection !== 'string' ? 'A call is currently in-progress. Leaving or reloading this page will end the call.' : closeProtection;\n      (event || window.event).returnValue = confirmationMsg;\n      return confirmationMsg;\n    };\n    /**\n     * Create the default Insights payload\n     * @param [connection]\n     */\n\n\n    _this._createDefaultPayload = function (connection) {\n      var payload = {\n        aggressive_nomination: _this.options.forceAggressiveIceNomination,\n        browser_extension: _this._isBrowserExtension,\n        dscp: !!_this.options.dscp,\n        ice_restart_enabled: _this.options.enableIceRestart,\n        platform: rtc.getMediaEngine(),\n        sdk_version: C.RELEASE_VERSION\n      };\n\n      function setIfDefined(propertyName, value) {\n        if (value) {\n          payload[propertyName] = value;\n        }\n      }\n\n      if (connection) {\n        var callSid = connection.parameters.CallSid;\n        setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n        setIfDefined('temp_call_sid', connection.outboundConnectionId);\n        setIfDefined('audio_codec', connection.codec);\n        payload.direction = connection.direction;\n      }\n\n      setIfDefined('gateway', _this.stream && _this.stream.gateway);\n      setIfDefined('selected_region', _this.options.region);\n      setIfDefined('region', _this.stream && _this.stream.region);\n      return payload;\n    };\n    /**\n     * Disconnect all {@link Connection}s.\n     */\n\n\n    _this._disconnectAll = function () {\n      var connections = _this.connections.splice(0);\n\n      connections.forEach(function (conn) {\n        return conn.disconnect();\n      });\n\n      if (_this._activeConnection) {\n        _this._activeConnection.disconnect();\n      }\n    };\n    /**\n     * Called when a 'close' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingClose = function () {\n      _this.stream = null;\n    };\n    /**\n     * Called when a 'connected' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingConnected = function (payload) {\n      var region = regions_1.getRegionShortcode(payload.region);\n      _this._edge = regions_1.regionToEdge[region] || payload.region;\n      _this._region = region || payload.region;\n\n      _this._sendPresence();\n    };\n    /**\n     * Called when an 'error' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingError = function (payload) {\n      if (!payload.error) {\n        return;\n      }\n\n      var error = __assign({}, payload.error);\n\n      var sid = payload.callsid;\n\n      if (sid) {\n        error.connection = _this._findConnection(sid);\n      }\n\n      if (error.code === 31201) {\n        error.twilioError = new errors_1.AuthorizationErrors.AuthenticationFailed();\n      } else if (error.code === 31204) {\n        error.twilioError = new errors_1.AuthorizationErrors.AccessTokenInvalid();\n      } else if (error.code === 31205) {\n        // Stop trying to register presence after token expires\n        _this._stopRegistrationTimer();\n\n        error.twilioError = new errors_1.AuthorizationErrors.AccessTokenExpired();\n      } else if (!error.twilioError) {\n        error.twilioError = new errors_1.GeneralErrors.UnknownError();\n      }\n\n      _this._log.info('Received error: ', error);\n\n      _this.emit('error', error);\n    };\n    /**\n     * Called when an 'invite' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingInvite = function (payload) {\n      var wasBusy = !!_this._activeConnection;\n\n      if (wasBusy && !_this.options.allowIncomingWhileBusy) {\n        _this._log.info('Device busy; ignoring incoming invite');\n\n        return;\n      }\n\n      if (!payload.callsid || !payload.sdp) {\n        _this.emit('error', {\n          message: 'Malformed invite from gateway',\n          twilioError: new errors_1.ClientErrors.BadRequest()\n        });\n\n        return;\n      }\n\n      var callParameters = payload.parameters || {};\n      callParameters.CallSid = callParameters.CallSid || payload.callsid;\n      var customParameters = Object.assign({}, util_1.queryToJson(callParameters.Params));\n\n      var connection = _this._makeConnection(customParameters, {\n        callParameters: callParameters,\n        offerSdp: payload.sdp\n      });\n\n      _this.connections.push(connection);\n\n      connection.once('accept', function () {\n        _this.soundcache.get(Device.SoundName.Incoming).stop();\n\n        _this._publishNetworkChange();\n      });\n      var play = _this._enabledSounds.incoming && !wasBusy ? function () {\n        return _this.soundcache.get(Device.SoundName.Incoming).play();\n      } : function () {\n        return Promise.resolve();\n      };\n\n      _this._showIncomingConnection(connection, play);\n    };\n    /**\n     * Called when an 'offline' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingOffline = function () {\n      _this._log.info('Stream is offline');\n\n      _this._status = Device.Status.Offline;\n      _this._edge = null;\n      _this._region = null;\n\n      _this.emit('offline', _this);\n    };\n    /**\n     * Called when a 'ready' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingReady = function () {\n      _this._log.info('Stream is ready');\n\n      _this._status = Device.Status.Ready;\n\n      _this.emit('ready', _this);\n    };\n    /**\n     * Publish a NetworkInformation#change event to Insights if there's an active {@link Connection}.\n     */\n\n\n    _this._publishNetworkChange = function () {\n      if (!_this._activeConnection) {\n        return;\n      }\n\n      if (_this._networkInformation) {\n        _this._publisher.info('network-information', 'network-change', {\n          connection_type: _this._networkInformation.type,\n          downlink: _this._networkInformation.downlink,\n          downlinkMax: _this._networkInformation.downlinkMax,\n          effective_type: _this._networkInformation.effectiveType,\n          rtt: _this._networkInformation.rtt\n        }, _this._activeConnection);\n      }\n    };\n    /**\n     * Update the input stream being used for calls so that any current call and all future calls\n     * will use the new input stream.\n     * @param inputStream\n     */\n\n\n    _this._updateInputStream = function (inputStream) {\n      var connection = _this._activeConnection;\n\n      if (connection && !inputStream) {\n        return Promise.reject(new errors_1.InvalidStateError('Cannot unset input device while a call is in progress.'));\n      }\n\n      _this._connectionInputStream = inputStream;\n      return connection ? connection._setInputTracksFromStream(inputStream) : Promise.resolve();\n    };\n    /**\n     * Update the device IDs of output devices being used to play sounds through.\n     * @param type - Whether to update ringtone or speaker sounds\n     * @param sinkIds - An array of device IDs\n     */\n\n\n    _this._updateSinkIds = function (type, sinkIds) {\n      var promise = type === 'ringtone' ? _this._updateRingtoneSinkIds(sinkIds) : _this._updateSpeakerSinkIds(sinkIds);\n      return promise.then(function () {\n        _this._publisher.info('audio', type + \"-devices-set\", {\n          audio_device_ids: sinkIds\n        }, _this._activeConnection);\n      }, function (error) {\n        _this._publisher.error('audio', type + \"-devices-set-failed\", {\n          audio_device_ids: sinkIds,\n          message: error.message\n        }, _this._activeConnection);\n\n        throw error;\n      });\n    };\n\n    if (window) {\n      var root = window;\n      var browser = root.msBrowser || root.browser || root.chrome;\n      _this._isBrowserExtension = !!browser && !!browser.runtime && !!browser.runtime.id || !!root.safari && !!root.safari.extension;\n    }\n\n    if (_this._isBrowserExtension) {\n      _this._log.info('Running as browser extension.');\n    }\n\n    if (navigator) {\n      var n = navigator;\n      _this._networkInformation = n.connection || n.mozConnection || n.webkitConnection;\n    }\n\n    if (token) {\n      _this.setup(token, options);\n    } else if (options) {\n      throw new errors_1.InvalidArgumentError('Cannot construct a Device with options but without a token');\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(Device, \"audioContext\", {\n    /**\n     * The AudioContext to be used by {@link Device} instances.\n     * @private\n     */\n    get: function () {\n      return Device._audioContext;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"extension\", {\n    /**\n     * Which sound file extension is supported.\n     * @private\n     */\n    get: function () {\n      // NOTE(mroberts): Node workaround.\n      var a = typeof document !== 'undefined' ? document.createElement('audio') : {\n        canPlayType: false\n      };\n      var canPlayMp3;\n\n      try {\n        canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n      } catch (e) {\n        canPlayMp3 = false;\n      }\n\n      var canPlayVorbis;\n\n      try {\n        canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n      } catch (e) {\n        canPlayVorbis = false;\n      }\n\n      return canPlayVorbis && !canPlayMp3 ? 'ogg' : 'mp3';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"isSupported\", {\n    /**\n     * Whether or not this SDK is supported by the current browser.\n     */\n    get: function () {\n      return rtc.enabled();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"packageName\", {\n    /**\n     * Package name of the SDK.\n     */\n    get: function () {\n      return C.PACKAGE_NAME;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n\n  Device.runPreflight = function (token, options) {\n    return new preflight_1.PreflightTest(token, __assign({\n      audioContext: Device._getOrCreateAudioContext()\n    }, options));\n  };\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n\n\n  Device.toString = function () {\n    return '[Twilio.Device class]';\n  };\n\n  Object.defineProperty(Device, \"version\", {\n    /**\n     * Current SDK version.\n     */\n    get: function () {\n      return C.RELEASE_VERSION;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes the AudioContext instance shared across the Client SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n\n  Device._getOrCreateAudioContext = function () {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n\n    return Device._audioContext;\n  };\n  /**\n   * Return the active {@link Connection}. Null or undefined for backward compatibility.\n   */\n\n\n  Device.prototype.activeConnection = function () {\n    if (!this.isInitialized) {\n      return null;\n    } // @rrowland This should only return activeConnection, but customers have built around this\n    // broken behavior and in order to not break their apps we are including this until\n    // the next big release.\n\n\n    return this._activeConnection || this.connections[0];\n  };\n  /**\n   * @deprecated Set a handler for the cancel event.\n   * @param handler\n   */\n\n\n  Device.prototype.cancel = function (handler) {\n    return this._addHandler(Device.EventName.Cancel, handler);\n  };\n\n  Device.prototype.connect = function (paramsOrHandler, audioConstraints, rtcConfiguration) {\n    if (typeof paramsOrHandler === 'function') {\n      this._addHandler(Device.EventName.Connect, paramsOrHandler);\n\n      return null;\n    }\n\n    this._throwUnlessSetup('connect');\n\n    if (this._activeConnection) {\n      throw new errors_1.InvalidStateError('A Connection is already active');\n    }\n\n    var params = paramsOrHandler || {};\n    audioConstraints = audioConstraints || this.options && this.options.audioConstraints || {};\n    rtcConfiguration = rtcConfiguration || this.options.rtcConfiguration;\n\n    var connection = this._activeConnection = this._makeConnection(params, {\n      rtcConfiguration: rtcConfiguration\n    }); // Make sure any incoming connections are ignored\n\n\n    this.connections.splice(0).forEach(function (conn) {\n      return conn.ignore();\n    }); // Stop the incoming sound if it's playing\n\n    this.soundcache.get(Device.SoundName.Incoming).stop();\n    connection.accept(audioConstraints);\n\n    this._publishNetworkChange();\n\n    return connection;\n  };\n  /**\n   * Set a handler for the disconnect event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n\n\n  Device.prototype.disconnect = function (handler) {\n    return this._addHandler(Device.EventName.Disconnect, handler);\n  };\n  /**\n   * Disconnect all {@link Connection}s.\n   */\n\n\n  Device.prototype.disconnectAll = function () {\n    this._throwUnlessSetup('disconnectAll');\n\n    this._disconnectAll();\n  };\n\n  Object.defineProperty(Device.prototype, \"edge\", {\n    /**\n     * Returns the {@link Edge} value the {@link Device} is currently connected\n     * to. The value will be `null` when the {@link Device} is offline.\n     */\n    get: function () {\n      return this._edge;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Set a handler for the error event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n\n  Device.prototype.error = function (handler) {\n    return this._addHandler(Device.EventName.Error, handler);\n  };\n  /**\n   * Set a handler for the incoming event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n\n\n  Device.prototype.incoming = function (handler) {\n    return this._addHandler(Device.EventName.Incoming, handler);\n  };\n  /**\n   * Set a handler for the offline event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n\n\n  Device.prototype.offline = function (handler) {\n    return this._addHandler(Device.EventName.Offline, handler);\n  };\n  /**\n   * Set a handler for the ready event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n\n\n  Device.prototype.ready = function (handler) {\n    return this._addHandler(Device.EventName.Ready, handler);\n  };\n  /**\n   * Get the {@link Region} string the {@link Device} is currently connected to, or 'offline'\n   * if not connected.\n   */\n\n\n  Device.prototype.region = function () {\n    this._log.warn('`Device.region` is deprecated and will be removed in the next major ' + 'release. Please use `Device.edge` instead.');\n\n    this._throwUnlessSetup('region');\n\n    return typeof this._region === 'string' ? this._region : 'offline';\n  };\n  /**\n   * Register to receive incoming calls. Does not need to be called unless {@link Device.unregisterPresence}\n   * has been called directly.\n   */\n\n\n  Device.prototype.registerPresence = function () {\n    this._throwUnlessSetup('registerPresence');\n\n    this.mediaPresence.audio = true;\n\n    this._sendPresence();\n\n    return this;\n  };\n  /**\n   * Remove an event listener\n   * @param event - The event name to stop listening for\n   * @param listener - The callback to remove\n   */\n\n\n  Device.prototype.removeListener = function (event, listener) {\n    events_1.EventEmitter.prototype.removeListener.call(this, event, listener);\n    return this;\n  };\n  /**\n   * Initialize the {@link Device}.\n   * @param token - A Twilio JWT token string granting this {@link Device} access.\n   * @param [options]\n   */\n\n\n  Device.prototype.setup = function (token, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (util_1.isLegacyEdge()) {\n      throw new errors_1.NotSupportedError('Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' + 'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' + 'Please see this documentation for a list of supported browsers ' + 'https://www.twilio.com/docs/voice/client/javascript#supported-browsers');\n    }\n\n    if (!Device.isSupported && !options.ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new errors_1.NotSupportedError(\"twilio.js wasn't able to find WebRTC browser support.           This is most likely because this page is served over http rather than https,           which does not support WebRTC in many browsers. Please load this page over https and           try again.\");\n      }\n\n      throw new errors_1.NotSupportedError(\"twilio.js 1.3+ SDKs require WebRTC browser support.         For more information, see <https://www.twilio.com/docs/api/client/twilio-js>.         If you have any questions about this announcement, please contact         Twilio Support at <help@twilio.com>.\");\n    }\n\n    if (!token) {\n      throw new errors_1.InvalidArgumentError('Token is required for Device.setup()');\n    }\n\n    Object.assign(this.options, options);\n\n    this._log.setDefaultLevel(this.options.debug ? log_1.default.levels.DEBUG : this.options.warnings ? log_1.default.levels.WARN : log_1.default.levels.SILENT);\n\n    this._chunderURIs = this.options.chunderw ? [\"wss://\" + this.options.chunderw + \"/signal\"] : regions_1.getChunderURIs(this.options.edge, this.options.region, this._log.warn.bind(this._log)).map(function (uri) {\n      return \"wss://\" + uri + \"/signal\";\n    });\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined' && typeof RTCPeerConnection !== 'undefined' && typeof RTCRtpTransceiver !== 'undefined' ? util_1.isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver) : false;\n    }\n\n    Device._getOrCreateAudioContext();\n\n    if (Device._audioContext && options.fakeLocalDTMF) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new dialtonePlayer_1.default(Device._audioContext);\n      }\n    } else if (Device._dialtonePlayer) {\n      Device._dialtonePlayer.cleanup();\n\n      delete Device._dialtonePlayer;\n    }\n\n    if (this.isInitialized) {\n      this._log.info('Found existing Device; using new token but ignoring options');\n\n      this.updateToken(token);\n      return this;\n    }\n\n    this.isInitialized = true;\n\n    if (this.options.dscp) {\n      this.options.rtcConstraints.optional = [{\n        googDscp: true\n      }];\n    }\n\n    var getOrSetSound = function (key, value) {\n      if (!hasBeenWarnedSounds) {\n        _this._log.warn('Device.sounds is deprecated and will be removed in the next breaking ' + 'release. Please use the new functionality available on Device.audio.');\n\n        hasBeenWarnedSounds = true;\n      }\n\n      if (typeof value !== 'undefined') {\n        _this._enabledSounds[key] = value;\n      }\n\n      return _this._enabledSounds[key];\n    };\n\n    [Device.SoundName.Disconnect, Device.SoundName.Incoming, Device.SoundName.Outgoing].forEach(function (eventName) {\n      _this.sounds[eventName] = getOrSetSound.bind(null, eventName);\n    });\n    var defaultSounds = {\n      disconnect: {\n        filename: 'disconnect',\n        maxDuration: 3000\n      },\n      dtmf0: {\n        filename: 'dtmf-0',\n        maxDuration: 1000\n      },\n      dtmf1: {\n        filename: 'dtmf-1',\n        maxDuration: 1000\n      },\n      dtmf2: {\n        filename: 'dtmf-2',\n        maxDuration: 1000\n      },\n      dtmf3: {\n        filename: 'dtmf-3',\n        maxDuration: 1000\n      },\n      dtmf4: {\n        filename: 'dtmf-4',\n        maxDuration: 1000\n      },\n      dtmf5: {\n        filename: 'dtmf-5',\n        maxDuration: 1000\n      },\n      dtmf6: {\n        filename: 'dtmf-6',\n        maxDuration: 1000\n      },\n      dtmf7: {\n        filename: 'dtmf-7',\n        maxDuration: 1000\n      },\n      dtmf8: {\n        filename: 'dtmf-8',\n        maxDuration: 1000\n      },\n      dtmf9: {\n        filename: 'dtmf-9',\n        maxDuration: 1000\n      },\n      dtmfh: {\n        filename: 'dtmf-hash',\n        maxDuration: 1000\n      },\n      dtmfs: {\n        filename: 'dtmf-star',\n        maxDuration: 1000\n      },\n      incoming: {\n        filename: 'incoming',\n        shouldLoop: true\n      },\n      outgoing: {\n        filename: 'outgoing',\n        maxDuration: 3000\n      }\n    };\n\n    for (var _i = 0, _a = Object.keys(defaultSounds); _i < _a.length; _i++) {\n      var name_1 = _a[_i];\n      var soundDef = defaultSounds[name_1];\n      var defaultUrl = C.SOUNDS_BASE_URL + \"/\" + soundDef.filename + \".\" + Device.extension + (\"?cache=\" + C.RELEASE_VERSION);\n      var soundUrl = this.options.sounds && this.options.sounds[name_1] || defaultUrl;\n      var sound = new this.options.soundFactory(name_1, soundUrl, {\n        audioContext: this.options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop\n      });\n      this.soundcache.set(name_1, sound);\n    }\n\n    this._publisher = (this.options.Publisher || Publisher)('twilio-js-sdk', token, {\n      defaultPayload: this._createDefaultPayload,\n      host: this.options.eventgw,\n      metadata: {\n        app_name: this.options.appName,\n        app_version: this.options.appVersion\n      }\n    });\n\n    if (this.options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', function (error) {\n        _this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n\n    if (this._networkInformation && typeof this._networkInformation.addEventListener === 'function') {\n      this._networkInformation.addEventListener('change', this._publishNetworkChange);\n    }\n\n    this.audio = new (this.options.AudioHelper || audiohelper_1.default)(this._updateSinkIds, this._updateInputStream, getUserMedia, {\n      audioContext: Device.audioContext,\n      enabledSounds: this._enabledSounds\n    });\n    this.audio.on('deviceChange', function (lostActiveDevices) {\n      var activeConnection = _this._activeConnection;\n      var deviceIds = lostActiveDevices.map(function (device) {\n        return device.deviceId;\n      });\n\n      _this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds\n      }, activeConnection);\n\n      if (activeConnection) {\n        activeConnection.mediaStream._onInputDevicesChanged();\n      }\n    });\n    this.mediaPresence.audio = !this.options.noRegister;\n    this.updateToken(token); // Setup close protection and make sure we clean up ongoing calls on unload.\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this.destroy);\n      window.addEventListener('pagehide', this.destroy);\n\n      if (this.options.closeProtection) {\n        window.addEventListener('beforeunload', this._confirmClose);\n      }\n    } // (rrowland) This maintains backward compatibility, but we should look at\n    // removing this next breaking change. Any error should be caught by the\n    // customer, and anything that's not a fatal error should not be emitted\n    // via error event.\n\n\n    this.on(Device.EventName.Error, function () {\n      if (_this.listenerCount('error') > 1) {\n        return;\n      }\n\n      _this._log.info('Uncaught error event suppressed.');\n    });\n    return this;\n  };\n  /**\n   * Get the status of this {@link Device} instance\n   */\n\n\n  Device.prototype.status = function () {\n    this._throwUnlessSetup('status');\n\n    return this._activeConnection ? Device.Status.Busy : this._status;\n  };\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n\n\n  Device.prototype.toString = function () {\n    return '[Twilio.Device instance]';\n  };\n  /**\n   * Unregister to receiving incoming calls.\n   */\n\n\n  Device.prototype.unregisterPresence = function () {\n    this._throwUnlessSetup('unregisterPresence');\n\n    this.mediaPresence.audio = false;\n\n    this._sendPresence();\n\n    return this;\n  };\n  /**\n   * Update the token and re-register.\n   * @param token - The new token JWT string to register with.\n   */\n\n\n  Device.prototype.updateToken = function (token) {\n    this._throwUnlessSetup('updateToken');\n\n    this.token = token;\n    this.register(token);\n  };\n  /**\n   * Add a handler for an EventEmitter and emit a deprecation warning on first call.\n   * @param eventName - Name of the event\n   * @param handler - A handler to call when the event is emitted\n   */\n\n\n  Device.prototype._addHandler = function (eventName, handler) {\n    if (!hasBeenWarnedHandlers) {\n      this._log.warn(\"Device callback handlers (connect, error, offline, incoming, cancel, ready, disconnect)         have been deprecated and will be removed in the next breaking release. Instead, the EventEmitter         interface can be used to set event listeners. Example: device.on('\" + eventName + \"', handler)\");\n\n      hasBeenWarnedHandlers = true;\n    }\n\n    this.addListener(eventName, handler);\n    return this;\n  };\n  /**\n   * Calls the emit API such that it is asynchronous.\n   * Only use this internal API if you don't want to break the execution after raising an event.\n   * This prevents the issue where events are not dispatched to all handlers when one of the handlers throws an error.\n   * For example, our connection:accept is not triggered if the handler for device:connect handler throws an error.\n   * As a side effect, we are not able to perform our internal routines such as stopping incoming sounds.\n   * See connection:accept inside _makeConnection where we call emit('connect'). This can throw an error.\n   * See connection:accept inside _onSignalingInvite. This handler won't get called if the error above is thrown.\n   * @private\n   */\n\n\n  Device.prototype._asyncEmit = function (event) {\n    var _this = this;\n\n    var args = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      args[_i - 1] = arguments[_i];\n    }\n\n    setTimeout(function () {\n      return _this.emit.apply(_this, __spreadArrays([event], args));\n    });\n  };\n  /**\n   * Find a {@link Connection} by its CallSid.\n   * @param callSid\n   */\n\n\n  Device.prototype._findConnection = function (callSid) {\n    return this.connections.find(function (conn) {\n      return conn.parameters.CallSid === callSid || conn.outboundConnectionId === callSid;\n    }) || null;\n  };\n  /**\n   * Create a new {@link Connection}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param [options] - Options to be used to instantiate the {@link Connection}.\n   */\n\n\n  Device.prototype._makeConnection = function (twimlParams, options) {\n    var _this = this;\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      throw new errors_1.InvalidStateError('Device has not been initialized.');\n    }\n\n    var config = {\n      audioHelper: this.audio,\n      getUserMedia: getUserMedia,\n      isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n      pstream: this.stream,\n      publisher: this._publisher,\n      soundcache: this.soundcache\n    };\n    options = Object.assign({\n      MediaStream: this.options.MediaStream || this.options.mediaStreamFactory || rtc.PeerConnection,\n      audioConstraints: this.options.audioConstraints,\n      beforeAccept: function (conn) {\n        if (!_this._activeConnection || _this._activeConnection === conn) {\n          return;\n        }\n\n        _this._activeConnection.disconnect();\n\n        _this._removeConnection(_this._activeConnection);\n      },\n      codecPreferences: this.options.codecPreferences,\n      dialtonePlayer: Device._dialtonePlayer,\n      dscp: this.options.dscp,\n      enableIceRestart: this.options.enableIceRestart,\n      enableRingingState: this.options.enableRingingState,\n      forceAggressiveIceNomination: this.options.forceAggressiveIceNomination,\n      getInputStream: function () {\n        return _this.options.fileInputStream || _this._connectionInputStream;\n      },\n      getSinkIds: function () {\n        return _this._connectionSinkIds;\n      },\n      maxAverageBitrate: this.options.maxAverageBitrate,\n      preflight: this.options.preflight,\n      rtcConfiguration: this.options.rtcConfiguration || {\n        iceServers: this.options.iceServers\n      },\n      rtcConstraints: this.options.rtcConstraints,\n      shouldPlayDisconnect: function () {\n        return _this._enabledSounds.disconnect;\n      },\n      twimlParams: twimlParams\n    }, options);\n    var connection = new this.options.connectionFactory(config, options);\n    connection.once('accept', function () {\n      _this._removeConnection(connection);\n\n      _this._activeConnection = connection;\n\n      if (_this.audio) {\n        _this.audio._maybeStartPollingVolume();\n      }\n\n      if (connection.direction === connection_1.default.CallDirection.Outgoing && _this._enabledSounds.outgoing) {\n        _this.soundcache.get(Device.SoundName.Outgoing).play();\n      }\n\n      var data = {\n        edge: _this._edge || _this._region\n      };\n      var selectedEdge = _this.options.edge;\n\n      if (selectedEdge) {\n        data['selected_edge'] = Array.isArray(selectedEdge) ? selectedEdge : [selectedEdge];\n      }\n\n      _this._publisher.info('settings', 'edge', data, connection);\n\n      _this._asyncEmit('connect', connection);\n    });\n    connection.addListener('error', function (error) {\n      if (connection.status() === 'closed') {\n        _this._removeConnection(connection);\n      }\n\n      if (_this.audio) {\n        _this.audio._maybeStopPollingVolume();\n      }\n\n      _this._maybeStopIncomingSound();\n\n      _this._asyncEmit('error', error);\n    });\n    connection.once('cancel', function () {\n      _this._log.info(\"Canceled: \" + connection.parameters.CallSid);\n\n      _this._removeConnection(connection);\n\n      if (_this.audio) {\n        _this.audio._maybeStopPollingVolume();\n      }\n\n      _this._maybeStopIncomingSound();\n\n      _this._asyncEmit('cancel', connection);\n    });\n    connection.once('disconnect', function () {\n      if (_this.audio) {\n        _this.audio._maybeStopPollingVolume();\n      }\n\n      _this._removeConnection(connection);\n\n      _this._asyncEmit('disconnect', connection);\n    });\n    connection.once('reject', function () {\n      _this._log.info(\"Rejected: \" + connection.parameters.CallSid);\n\n      if (_this.audio) {\n        _this.audio._maybeStopPollingVolume();\n      }\n\n      _this._removeConnection(connection);\n\n      _this._maybeStopIncomingSound();\n    });\n    connection.once('transportClose', function () {\n      if (connection.status() !== connection_1.default.State.Pending) {\n        return;\n      }\n\n      if (_this.audio) {\n        _this.audio._maybeStopPollingVolume();\n      }\n\n      _this._removeConnection(connection);\n\n      _this._maybeStopIncomingSound();\n    });\n    return connection;\n  };\n  /**\n   * Stop the incoming sound if no {@link Connection}s remain.\n   */\n\n\n  Device.prototype._maybeStopIncomingSound = function () {\n    if (!this.connections.length) {\n      this.soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  };\n  /**\n   * Remove a {@link Connection} from device.connections by reference\n   * @param connection\n   */\n\n\n  Device.prototype._removeConnection = function (connection) {\n    if (this._activeConnection === connection) {\n      this._activeConnection = null;\n    }\n\n    for (var i = this.connections.length - 1; i >= 0; i--) {\n      if (connection === this.connections[i]) {\n        this.connections.splice(i, 1);\n      }\n    }\n  };\n  /**\n   * Register with the signaling server.\n   */\n\n\n  Device.prototype._sendPresence = function () {\n    if (!this.stream) {\n      return;\n    }\n\n    this.stream.register({\n      audio: this.mediaPresence.audio\n    });\n\n    if (this.mediaPresence.audio) {\n      this._startRegistrationTimer();\n    } else {\n      this._stopRegistrationTimer();\n    }\n  };\n  /**\n   * Set up the connection to the signaling server.\n   * @param token\n   */\n\n\n  Device.prototype._setupStream = function (token) {\n    this._log.info('Setting up VSP');\n\n    this.stream = this.options.pStreamFactory(token, this._chunderURIs, {\n      backoffMaxMs: this.options.backoffMaxMs\n    });\n    this.stream.addListener('close', this._onSignalingClose);\n    this.stream.addListener('connected', this._onSignalingConnected);\n    this.stream.addListener('error', this._onSignalingError);\n    this.stream.addListener('invite', this._onSignalingInvite);\n    this.stream.addListener('offline', this._onSignalingOffline);\n    this.stream.addListener('ready', this._onSignalingReady);\n  };\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param connection\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n\n\n  Device.prototype._showIncomingConnection = function (connection, play) {\n    var _this = this;\n\n    var timeout;\n    return Promise.race([play(), new Promise(function (resolve, reject) {\n      timeout = setTimeout(function () {\n        var msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n        reject(new Error(msg));\n      }, RINGTONE_PLAY_TIMEOUT);\n    })]).catch(function (reason) {\n      _this._log.info(reason.message);\n    }).then(function () {\n      clearTimeout(timeout);\n\n      _this.emit('incoming', connection);\n    });\n  };\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n\n\n  Device.prototype._startRegistrationTimer = function () {\n    var _this = this;\n\n    this._stopRegistrationTimer();\n\n    this.regTimer = setTimeout(function () {\n      _this._sendPresence();\n    }, REGISTRATION_INTERVAL);\n  };\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n\n\n  Device.prototype._stopRegistrationTimer = function () {\n    if (this.regTimer) {\n      clearTimeout(this.regTimer);\n    }\n  };\n  /**\n   * Throw an Error if Device.setup has not been called for this instance.\n   * @param methodName - The name of the method being called before setup()\n   */\n\n\n  Device.prototype._throwUnlessSetup = function (methodName) {\n    if (!this.isInitialized) {\n      throw new errors_1.InvalidStateError(\"Call Device.setup() before \" + methodName);\n    }\n  };\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n\n\n  Device.prototype._updateRingtoneSinkIds = function (sinkIds) {\n    return Promise.resolve(this.soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  };\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n\n\n  Device.prototype._updateSpeakerSinkIds = function (sinkIds) {\n    Array.from(this.soundcache.entries()).filter(function (entry) {\n      return entry[0] !== Device.SoundName.Incoming;\n    }).forEach(function (entry) {\n      return entry[1].setSinkIds(sinkIds);\n    });\n    this._connectionSinkIds = sinkIds;\n    var connection = this._activeConnection;\n    return connection ? connection._setSinkIds(sinkIds) : Promise.resolve();\n  };\n  /**\n   * Register the {@link Device}\n   * @param token\n   */\n\n\n  Device.prototype.register = function (token) {\n    if (this.stream) {\n      this.stream.setToken(token);\n\n      this._publisher.setToken(token);\n    } else {\n      this._setupStream(token);\n    }\n  };\n\n  return Device;\n}(events_1.EventEmitter);\n\n(function (Device) {\n  /**\n   * All valid {@link Device} event names.\n   */\n  var EventName;\n\n  (function (EventName) {\n    EventName[\"Cancel\"] = \"cancel\";\n    EventName[\"Connect\"] = \"connect\";\n    EventName[\"Disconnect\"] = \"disconnect\";\n    EventName[\"Error\"] = \"error\";\n    EventName[\"Incoming\"] = \"incoming\";\n    EventName[\"Offline\"] = \"offline\";\n    EventName[\"Ready\"] = \"ready\";\n  })(EventName = Device.EventName || (Device.EventName = {}));\n  /**\n   * All possible {@link Device} statuses.\n   */\n\n\n  var Status;\n\n  (function (Status) {\n    Status[\"Busy\"] = \"busy\";\n    Status[\"Offline\"] = \"offline\";\n    Status[\"Ready\"] = \"ready\";\n  })(Status = Device.Status || (Device.Status = {}));\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n\n\n  var SoundName;\n\n  (function (SoundName) {\n    SoundName[\"Incoming\"] = \"incoming\";\n    SoundName[\"Outgoing\"] = \"outgoing\";\n    SoundName[\"Disconnect\"] = \"disconnect\";\n    SoundName[\"Dtmf0\"] = \"dtmf0\";\n    SoundName[\"Dtmf1\"] = \"dtmf1\";\n    SoundName[\"Dtmf2\"] = \"dtmf2\";\n    SoundName[\"Dtmf3\"] = \"dtmf3\";\n    SoundName[\"Dtmf4\"] = \"dtmf4\";\n    SoundName[\"Dtmf5\"] = \"dtmf5\";\n    SoundName[\"Dtmf6\"] = \"dtmf6\";\n    SoundName[\"Dtmf7\"] = \"dtmf7\";\n    SoundName[\"Dtmf8\"] = \"dtmf8\";\n    SoundName[\"Dtmf9\"] = \"dtmf9\";\n    SoundName[\"DtmfS\"] = \"dtmfs\";\n    SoundName[\"DtmfH\"] = \"dtmfh\";\n  })(SoundName = Device.SoundName || (Device.SoundName = {}));\n})(Device || (Device = {}));\n\nexports.default = Device;","map":{"version":3,"mappings":"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","names":["C","require","Publisher","PStream","rtc","getUserMedia","Sound","REGISTRATION_INTERVAL","RINGTONE_PLAY_TIMEOUT","hasBeenWarnedHandlers","hasBeenWarnedSounds","__extends","token","options","_super","_this","_a","Device","SoundName","Disconnect","Incoming","Outgoing","log_1","getInstance","Status","Offline","audio","allowIncomingWhileBusy","audioConstraints","closeProtection","codecPreferences","connection_1","Codec","PCMU","Opus","connectionFactory","debug","dscp","enableIceRestart","eventgw","forceAggressiveIceNomination","iceServers","noRegister","pStreamFactory","preflight","rtcConstraints","soundFactory","sounds","warnings","Map","_disconnectAll","_stopRegistrationTimer","_unbind","stream","destroy","_networkInformation","removeEventListener","_publishNetworkChange","window","_confirmClose","event","_activeConnection","confirmationMsg","returnValue","connection","payload","aggressive_nomination","browser_extension","_isBrowserExtension","ice_restart_enabled","platform","getMediaEngine","sdk_version","RELEASE_VERSION","setIfDefined","propertyName","value","callSid","parameters","CallSid","test","undefined","outboundConnectionId","codec","direction","gateway","region","connections","splice","forEach","conn","disconnect","regions_1","_edge","_region","_sendPresence","error","sid","callsid","_findConnection","code","twilioError","errors_1","AuthenticationFailed","AccessTokenInvalid","AccessTokenExpired","UnknownError","_log","info","emit","wasBusy","sdp","message","BadRequest","callParameters","customParameters","Object","assign","util_1","Params","_makeConnection","offerSdp","push","once","soundcache","get","stop","play","_enabledSounds","incoming","resolve","_showIncomingConnection","_status","Ready","_publisher","connection_type","type","downlink","downlinkMax","effective_type","effectiveType","rtt","inputStream","Promise","reject","_connectionInputStream","_setInputTracksFromStream","sinkIds","promise","_updateRingtoneSinkIds","_updateSpeakerSinkIds","then","audio_device_ids","root","browser","msBrowser","chrome","runtime","id","safari","extension","navigator","n","mozConnection","webkitConnection","setup","_audioContext","a","document","createElement","canPlayType","canPlayMp3","replace","e","canPlayVorbis","enabled","PACKAGE_NAME","preflight_1","__assign","audioContext","_getOrCreateAudioContext","AudioContext","webkitAudioContext","isInitialized","handler","_addHandler","EventName","Cancel","paramsOrHandler","rtcConfiguration","Connect","_throwUnlessSetup","params","ignore","accept","Error","warn","mediaPresence","listener","events_1","prototype","removeListener","call","isSupported","ignoreBrowserSupport","location","protocol","setDefaultLevel","levels","DEBUG","WARN","SILENT","_chunderURIs","chunderw","edge","bind","map","uri","_isUnifiedPlanDefault","RTCPeerConnection","RTCRtpTransceiver","fakeLocalDTMF","_dialtonePlayer","dialtonePlayer_1","cleanup","updateToken","optional","googDscp","getOrSetSound","key","eventName","defaultSounds","filename","maxDuration","dtmf0","dtmf1","dtmf2","dtmf3","dtmf4","dtmf5","dtmf6","dtmf7","dtmf8","dtmf9","dtmfh","dtmfs","shouldLoop","outgoing","keys","_i","name_1","soundDef","defaultUrl","SOUNDS_BASE_URL","soundUrl","sound","disableAudioContextSounds","set","defaultPayload","_createDefaultPayload","host","metadata","app_name","appName","app_version","appVersion","publishEvents","disable","on","addEventListener","AudioHelper","audiohelper_1","_updateSinkIds","_updateInputStream","enabledSounds","lostActiveDevices","activeConnection","deviceIds","device","deviceId","lost_active_device_ids","mediaStream","_onInputDevicesChanged","listenerCount","Busy","register","addListener","args","setTimeout","apply","__spreadArrays","find","twimlParams","config","audioHelper","isUnifiedPlanDefault","pstream","publisher","MediaStream","mediaStreamFactory","PeerConnection","beforeAccept","_removeConnection","dialtonePlayer","enableRingingState","getInputStream","fileInputStream","getSinkIds","_connectionSinkIds","maxAverageBitrate","shouldPlayDisconnect","_maybeStartPollingVolume","CallDirection","data","selectedEdge","Array","isArray","_asyncEmit","status","_maybeStopPollingVolume","_maybeStopIncomingSound","State","Pending","length","i","_startRegistrationTimer","backoffMaxMs","_onSignalingClose","_onSignalingConnected","_onSignalingError","_onSignalingInvite","_onSignalingOffline","_onSignalingReady","timeout","race","msg","catch","reason","clearTimeout","regTimer","methodName","setSinkIds","from","entries","filter","_setSinkIds","setToken","_setupStream","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/twilio-client/lib/twilio/device.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nimport { EventEmitter } from 'events';\nimport AudioHelper from './audiohelper';\nimport Connection from './connection';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  AuthorizationErrors,\n  ClientErrors,\n  GeneralErrors,\n  InvalidArgumentError,\n  InvalidStateError,\n  NotSupportedError,\n  SignalingErrors,\n  TwilioError,\n} from './errors';\nimport Log from './log';\nimport { PreflightTest } from './preflight/preflight';\nimport {\n  getChunderURIs,\n  getRegionShortcode,\n  Region,\n  regionToEdge,\n} from './regions';\nimport {\n  isLegacyEdge,\n  isUnifiedPlanDefault,\n  queryToJson,\n} from './util';\n\nconst C = require('./constants');\nconst Publisher = require('./eventpublisher');\nconst PStream = require('./pstream');\nconst rtc = require('./rtc');\nconst getUserMedia = require('./rtc/getusermedia');\nconst Sound = require('./sound');\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst REGISTRATION_INTERVAL = 30000;\nconst RINGTONE_PLAY_TIMEOUT = 2000;\n\ndeclare const RTCRtpTransceiver: any;\ndeclare const webkitAudioContext: typeof AudioContext;\n\nlet hasBeenWarnedHandlers: boolean = false;\nlet hasBeenWarnedSounds: boolean = false;\n\n/**\n * Options that may be passed to the {@link Device} constructor for internal testing.\n * @private\n */\nexport interface IExtendedDeviceOptions extends Device.Options {\n  /**\n   * Custom {@link AudioHelper} constructor\n   */\n  AudioHelper?: any;\n\n  /**\n   * Hostname of the signaling gateway to connect to.\n   */\n  chunderw?: string;\n\n  /**\n   * Custom {@link Connection} constructor\n   */\n  connectionFactory?: Connection;\n\n  /**\n   * Hostname of the event gateway to connect to.\n   */\n  eventgw?: string;\n\n  /**\n   * File input stream to use instead of reading from mic\n   */\n  fileInputStream?: MediaStream;\n\n  /**\n   * A list of specific ICE servers to use. Overridden by {@link Device.Options.rtcConfiguration}.\n   * @deprecated\n   */\n  iceServers?: Object[];\n\n  /**\n   * Ignore browser support, disabling the exception that is thrown when neither WebRTC nor\n   * ORTC are supported.\n   */\n  ignoreBrowserSupport?: boolean;\n\n  /**\n   * Whether to disable audio flag in MediaPresence (rrowland: Do we need this?)\n   */\n  noRegister?: boolean;\n\n  /**\n   * Whether this is a preflight call or not\n   */\n  preflight?: boolean;\n\n  /**\n   * Custom PStream constructor\n   */\n  pStreamFactory?: IPStream;\n\n  /**\n   * Custom Publisher constructor\n   */\n  Publisher?: IPublisher;\n\n  /**\n   * Whether Insights events should be published\n   */\n  publishEvents?: boolean;\n\n  /**\n   * RTC Constraints to pass to getUserMedia when making or accepting a Call.\n   * The format of this object depends on browser.\n   */\n  rtcConstraints?: Object;\n\n  /**\n   * Custom Sound constructor\n   */\n  soundFactory?: ISound;\n}\n\n/**\n * A sound definition used to initialize a Sound file.\n * @private\n */\nexport interface ISoundDefinition {\n  /**\n   * Name of the sound file.\n   */\n  filename: string;\n\n  /**\n   * The amount of time this sound file should play before being stopped automatically.\n   */\n  maxDuration?: number;\n\n  /**\n   * Whether or not this sound should loop after playthrough finishes.\n   */\n  shouldLoop?: boolean;\n}\n\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\nclass Device extends EventEmitter {\n  /**\n   * The AudioContext to be used by {@link Device} instances.\n   * @private\n   */\n  static get audioContext(): AudioContext | undefined {\n    return Device._audioContext;\n  }\n\n  /**\n   * Which sound file extension is supported.\n   * @private\n   */\n  static get extension(): 'mp3' | 'ogg' {\n    // NOTE(mroberts): Node workaround.\n    const a: any = typeof document !== 'undefined'\n      ? document.createElement('audio') : { canPlayType: false };\n\n    let canPlayMp3;\n    try {\n      canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n    } catch (e) {\n      canPlayMp3 = false;\n    }\n\n    let canPlayVorbis;\n    try {\n      canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n    } catch (e) {\n      canPlayVorbis = false;\n    }\n\n    return (canPlayVorbis && !canPlayMp3) ? 'ogg' : 'mp3';\n  }\n\n  /**\n   * Whether or not this SDK is supported by the current browser.\n   */\n  static get isSupported(): boolean { return rtc.enabled(); }\n\n  /**\n   * Package name of the SDK.\n   */\n  static get packageName(): string { return C.PACKAGE_NAME; }\n\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n  static runPreflight(token: string, options?: PreflightTest.Options): PreflightTest {\n    return new PreflightTest(token, { audioContext: Device._getOrCreateAudioContext(), ...options });\n  }\n\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n  static toString(): string {\n    return '[Twilio.Device class]';\n  }\n\n  /**\n   * Current SDK version.\n   */\n  static get version(): string { return C.RELEASE_VERSION; }\n\n  /**\n   * An AudioContext to share between {@link Device}s.\n   */\n  private static _audioContext?: AudioContext;\n\n  /**\n   * A DialtonePlayer to play mock DTMF sounds through.\n   */\n  private static _dialtonePlayer?: DialtonePlayer;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private static _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * Initializes the AudioContext instance shared across the Client SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n  private static _getOrCreateAudioContext(): AudioContext | undefined {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n    return Device._audioContext;\n  }\n\n  /**\n   * The AudioHelper instance associated with this {@link Device}.\n   */\n  audio: AudioHelper | null = null;\n\n  /**\n   * An array of {@link Connection}s. Though only one can be active, multiple may exist when there\n   * are multiple incoming, unanswered {@link Connection}s.\n   */\n  connections: Connection[] = [];\n\n  /**\n   * Whether or not {@link Device.setup} has been called.\n   */\n  isInitialized: boolean = false;\n\n  /**\n   * Methods to enable/disable each sound. Empty if the {@link Device} has not\n   * yet been set up.\n   */\n  readonly sounds: Partial<Record<Device.SoundName, (value?: boolean) => void>> = { };\n\n  /**\n   * The JWT string currently being used to authenticate this {@link Device}.\n   */\n  token: string | null = null;\n\n  /**\n   * The currently active {@link Connection}, if there is one.\n   */\n  private _activeConnection: Connection | null = null;\n\n  /**\n   * The list of chunder URIs that will be passed to PStream\n   */\n  private _chunderURIs: string[] = [];\n\n  /**\n   * An audio input MediaStream to pass to new {@link Connection} instances.\n   */\n  private _connectionInputStream: MediaStream | null = null;\n\n  /**\n   * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n   * new {@link Connection} instances.\n   */\n  private _connectionSinkIds: string[] = ['default'];\n\n  /**\n   * The name of the edge the {@link Device} is connected to.\n   */\n  private _edge: string | null = null;\n\n  /**\n   * Whether each sound is enabled.\n   */\n  private _enabledSounds: Record<Device.ToggleableSound, boolean> = {\n    [Device.SoundName.Disconnect]: true,\n    [Device.SoundName.Incoming]: true,\n    [Device.SoundName.Outgoing]: true,\n  };\n\n  /**\n   * Whether SDK is run as a browser extension\n   */\n  private _isBrowserExtension: boolean;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Network related information\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API\n   */\n  private _networkInformation: any;\n\n  /**\n   * An Insights Event Publisher.\n   */\n  private _publisher: IPublisher | null = null;\n\n  /**\n   * The region the {@link Device} is connected to.\n   */\n  private _region: string | null = null;\n\n  /**\n   * The current status of the {@link Device}.\n   */\n  private _status: Device.Status = Device.Status.Offline;\n\n  /**\n   * Value of 'audio' determines whether we should be registered for incoming calls.\n   */\n  private mediaPresence: { audio: boolean } = { audio: true };\n\n  /**\n   * The options passed to {@link Device} constructor or Device.setup.\n   */\n  private options: Device.Options = {\n    allowIncomingWhileBusy: false,\n    audioConstraints: true,\n    closeProtection: false,\n    codecPreferences: [Connection.Codec.PCMU, Connection.Codec.Opus],\n    connectionFactory: Connection,\n    debug: false,\n    dscp: true,\n    enableIceRestart: false,\n    eventgw: 'eventgw.twilio.com',\n    forceAggressiveIceNomination: false,\n    iceServers: [],\n    noRegister: false,\n    pStreamFactory: PStream,\n    preflight: false,\n    rtcConstraints: { },\n    soundFactory: Sound,\n    sounds: { },\n    warnings: true,\n  };\n\n  /**\n   * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n   */\n  private regTimer: NodeJS.Timer | null = null;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * The Signaling stream.\n   */\n  private stream: IPStream | null = null;\n\n  /**\n   * Construct a {@link Device} instance, without setting up up. {@link Device.setup} must\n   * be called later to initialize the {@link Device}.\n   * @constructor\n   * @param [token] - A Twilio JWT token string granting this {@link Device} access.\n   * @param [options]\n   */\n  constructor();\n  /**\n   * Construct a {@link Device} instance, and set it up as part of the construction.\n   * @constructor\n   * @param [token] - A Twilio JWT token string granting this {@link Device} access.\n   * @param [options]\n   */\n  constructor(token: string, options?: Device.Options);\n  constructor(token?: string, options?: Device.Options) {\n    super();\n\n    if (window) {\n      const root: any = window as any;\n      const browser: any = root.msBrowser || root.browser || root.chrome;\n\n      this._isBrowserExtension = (!!browser && !!browser.runtime && !!browser.runtime.id)\n        || (!!root.safari && !!root.safari.extension);\n    }\n\n    if (this._isBrowserExtension) {\n      this._log.info('Running as browser extension.');\n    }\n\n    if (navigator) {\n      const n = navigator as any;\n      this._networkInformation = n.connection\n        || n.mozConnection\n        || n.webkitConnection;\n    }\n\n    if (token) {\n      this.setup(token, options);\n    } else if (options) {\n      throw new InvalidArgumentError('Cannot construct a Device with options but without a token');\n    }\n  }\n\n  /**\n   * Return the active {@link Connection}. Null or undefined for backward compatibility.\n   */\n  activeConnection(): Connection | null | undefined {\n    if (!this.isInitialized) {\n      return null;\n    }\n    // @rrowland This should only return activeConnection, but customers have built around this\n    // broken behavior and in order to not break their apps we are including this until\n    // the next big release.\n    return this._activeConnection || this.connections[0];\n  }\n\n  /**\n   * @deprecated Set a handler for the cancel event.\n   * @param handler\n   */\n  cancel(handler: (connection: Connection) => any): this {\n    return this._addHandler(Device.EventName.Cancel, handler);\n  }\n\n  /**\n   * Make an outgoing Call.\n   * @param [params] - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param [audioConstraints]\n   * @param [rtcConfiguration] - An RTCConfiguration to override the one set in `Device.setup`.\n   */\n  connect(params?: Record<string, string>,\n          audioConstraints?: MediaTrackConstraints | boolean,\n          rtcConfiguration?: RTCConfiguration): Connection;\n  /**\n   * Add a listener for the connect event.\n   * @param handler - A handler to set on the connect event.\n   */\n  connect(handler: (connection: Connection) => any): null;\n  connect(paramsOrHandler?: Record<string, string> | ((connection: Connection) => any),\n          audioConstraints?: MediaTrackConstraints | boolean,\n          rtcConfiguration?: RTCConfiguration): Connection | null {\n    if (typeof paramsOrHandler === 'function') {\n      this._addHandler(Device.EventName.Connect, paramsOrHandler);\n      return null;\n    }\n\n    this._throwUnlessSetup('connect');\n\n    if (this._activeConnection) {\n      throw new InvalidStateError('A Connection is already active');\n    }\n\n    const params: Record<string, string> = paramsOrHandler || { };\n    audioConstraints = audioConstraints || this.options && this.options.audioConstraints || { };\n    rtcConfiguration = rtcConfiguration || this.options.rtcConfiguration;\n\n    const connection = this._activeConnection = this._makeConnection(params, { rtcConfiguration });\n\n    // Make sure any incoming connections are ignored\n    this.connections.splice(0).forEach(conn => conn.ignore());\n\n    // Stop the incoming sound if it's playing\n    this.soundcache.get(Device.SoundName.Incoming).stop();\n\n    connection.accept(audioConstraints);\n    this._publishNetworkChange();\n    return connection;\n  }\n\n  /**\n   * Destroy the {@link Device}, freeing references to be garbage collected.\n   */\n  destroy = (): void => {\n    this._disconnectAll();\n    this._stopRegistrationTimer();\n\n    if (this.audio) {\n      this.audio._unbind();\n    }\n\n    if (this.stream) {\n      this.stream.destroy();\n      this.stream = null;\n    }\n\n    if (this._networkInformation && typeof this._networkInformation.removeEventListener === 'function') {\n      this._networkInformation.removeEventListener('change', this._publishNetworkChange);\n    }\n\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('beforeunload', this._confirmClose);\n      window.removeEventListener('unload', this.destroy);\n      window.removeEventListener('pagehide', this.destroy);\n    }\n  }\n\n  /**\n   * Set a handler for the disconnect event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n  disconnect(handler: (connection: Connection) => any): this {\n    return this._addHandler(Device.EventName.Disconnect, handler);\n  }\n\n  /**\n   * Disconnect all {@link Connection}s.\n   */\n  disconnectAll(): void {\n    this._throwUnlessSetup('disconnectAll');\n    this._disconnectAll();\n  }\n\n  /**\n   * Returns the {@link Edge} value the {@link Device} is currently connected\n   * to. The value will be `null` when the {@link Device} is offline.\n   */\n  get edge(): string | null {\n    return this._edge;\n  }\n\n  /**\n   * Set a handler for the error event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n  error(handler: (error: Connection) => any): this {\n    return this._addHandler(Device.EventName.Error, handler);\n  }\n\n  /**\n   * Set a handler for the incoming event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n  incoming(handler: (connection: Connection) => any): this {\n    return this._addHandler(Device.EventName.Incoming, handler);\n  }\n\n  /**\n   * Set a handler for the offline event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n  offline(handler: (device: Device) => any): this {\n    return this._addHandler(Device.EventName.Offline, handler);\n  }\n\n  /**\n   * Set a handler for the ready event.\n   * @deprecated Use {@link Device.on}.\n   * @param handler\n   */\n  ready(handler: (device: Device) => any): this {\n    return this._addHandler(Device.EventName.Ready, handler);\n  }\n\n  /**\n   * Get the {@link Region} string the {@link Device} is currently connected to, or 'offline'\n   * if not connected.\n   */\n  region(): string {\n    this._log.warn(\n      '`Device.region` is deprecated and will be removed in the next major ' +\n      'release. Please use `Device.edge` instead.',\n    );\n    this._throwUnlessSetup('region');\n    return typeof this._region === 'string' ? this._region : 'offline';\n  }\n\n  /**\n   * Register to receive incoming calls. Does not need to be called unless {@link Device.unregisterPresence}\n   * has been called directly.\n   */\n  registerPresence(): this {\n    this._throwUnlessSetup('registerPresence');\n    this.mediaPresence.audio = true;\n    this._sendPresence();\n    return this;\n  }\n\n  /**\n   * Remove an event listener\n   * @param event - The event name to stop listening for\n   * @param listener - The callback to remove\n   */\n  removeListener(event: Device.EventName, listener: (...args: any[]) => void): this {\n    EventEmitter.prototype.removeListener.call(this, event, listener);\n    return this;\n  }\n\n  /**\n   * Initialize the {@link Device}.\n   * @param token - A Twilio JWT token string granting this {@link Device} access.\n   * @param [options]\n   */\n  setup(token: string, options: Device.Options = { }): this {\n    if (isLegacyEdge()) {\n      throw new NotSupportedError(\n        'Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' +\n        'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' +\n        'Please see this documentation for a list of supported browsers ' +\n        'https://www.twilio.com/docs/voice/client/javascript#supported-browsers',\n      );\n    }\n    if (!Device.isSupported && !options.ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new NotSupportedError(`twilio.js wasn't able to find WebRTC browser support. \\\n          This is most likely because this page is served over http rather than https, \\\n          which does not support WebRTC in many browsers. Please load this page over https and \\\n          try again.`);\n      }\n\n      throw new NotSupportedError(`twilio.js 1.3+ SDKs require WebRTC browser support. \\\n        For more information, see <https://www.twilio.com/docs/api/client/twilio-js>. \\\n        If you have any questions about this announcement, please contact \\\n        Twilio Support at <help@twilio.com>.`);\n    }\n\n    if (!token) {\n      throw new InvalidArgumentError('Token is required for Device.setup()');\n    }\n\n    Object.assign(this.options, options);\n\n    this._log.setDefaultLevel(\n      this.options.debug\n        ? Log.levels.DEBUG\n        : this.options.warnings\n          ? Log.levels.WARN\n          : Log.levels.SILENT,\n    );\n\n    this._chunderURIs = this.options.chunderw\n      ? [`wss://${this.options.chunderw}/signal`]\n      : getChunderURIs(\n          this.options.edge,\n          this.options.region,\n          this._log.warn.bind(this._log),\n        ).map((uri: string) => `wss://${uri}/signal`);\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined'\n        && typeof RTCPeerConnection !== 'undefined'\n        && typeof RTCRtpTransceiver !== 'undefined'\n      ? isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver)\n      : false;\n    }\n\n    Device._getOrCreateAudioContext();\n\n    if (Device._audioContext && options.fakeLocalDTMF) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new DialtonePlayer(Device._audioContext);\n      }\n    } else if (Device._dialtonePlayer) {\n      Device._dialtonePlayer.cleanup();\n      delete Device._dialtonePlayer;\n    }\n\n    if (this.isInitialized) {\n      this._log.info('Found existing Device; using new token but ignoring options');\n      this.updateToken(token);\n      return this;\n    }\n\n    this.isInitialized = true;\n\n    if (this.options.dscp) {\n      (this.options.rtcConstraints as any).optional = [{ googDscp: true }];\n    }\n\n    const getOrSetSound = (key: Device.ToggleableSound, value?: boolean) => {\n      if (!hasBeenWarnedSounds) {\n        this._log.warn('Device.sounds is deprecated and will be removed in the next breaking ' +\n          'release. Please use the new functionality available on Device.audio.');\n        hasBeenWarnedSounds = true;\n      }\n\n      if (typeof value !== 'undefined') {\n        this._enabledSounds[key] = value;\n      }\n\n      return this._enabledSounds[key];\n    };\n\n    [Device.SoundName.Disconnect, Device.SoundName.Incoming, Device.SoundName.Outgoing]\n        .forEach((eventName: Device.SoundName) => {\n      this.sounds[eventName] = getOrSetSound.bind(null, eventName);\n    });\n\n    const defaultSounds: Record<string, ISoundDefinition> = {\n      disconnect: { filename: 'disconnect', maxDuration: 3000 },\n      dtmf0: { filename: 'dtmf-0', maxDuration: 1000 },\n      dtmf1: { filename: 'dtmf-1', maxDuration: 1000 },\n      dtmf2: { filename: 'dtmf-2', maxDuration: 1000 },\n      dtmf3: { filename: 'dtmf-3', maxDuration: 1000 },\n      dtmf4: { filename: 'dtmf-4', maxDuration: 1000 },\n      dtmf5: { filename: 'dtmf-5', maxDuration: 1000 },\n      dtmf6: { filename: 'dtmf-6', maxDuration: 1000 },\n      dtmf7: { filename: 'dtmf-7', maxDuration: 1000 },\n      dtmf8: { filename: 'dtmf-8', maxDuration: 1000 },\n      dtmf9: { filename: 'dtmf-9', maxDuration: 1000 },\n      dtmfh: { filename: 'dtmf-hash', maxDuration: 1000 },\n      dtmfs: { filename: 'dtmf-star', maxDuration: 1000 },\n      incoming: { filename: 'incoming', shouldLoop: true },\n      outgoing: { filename: 'outgoing', maxDuration: 3000 },\n    };\n\n    for (const name of Object.keys(defaultSounds)) {\n      const soundDef: ISoundDefinition = defaultSounds[name];\n\n      const defaultUrl: string = `${C.SOUNDS_BASE_URL}/${soundDef.filename}.${Device.extension}`\n        + `?cache=${C.RELEASE_VERSION}`;\n\n      const soundUrl: string = this.options.sounds && this.options.sounds[name as Device.SoundName] || defaultUrl;\n      const sound: any = new this.options.soundFactory(name, soundUrl, {\n        audioContext: this.options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop,\n      });\n\n      this.soundcache.set(name as Device.SoundName, sound);\n    }\n\n    this._publisher = (this.options.Publisher || Publisher)('twilio-js-sdk', token, {\n      defaultPayload: this._createDefaultPayload,\n      host: this.options.eventgw,\n      metadata: {\n        app_name: this.options.appName,\n        app_version: this.options.appVersion,\n      },\n    } as any);\n\n    if (this.options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', (error: Error) => {\n        this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n\n    if (this._networkInformation && typeof this._networkInformation.addEventListener === 'function') {\n      this._networkInformation.addEventListener('change', this._publishNetworkChange);\n    }\n\n    this.audio = new (this.options.AudioHelper || AudioHelper)\n        (this._updateSinkIds, this._updateInputStream, getUserMedia, {\n      audioContext: Device.audioContext,\n      enabledSounds: this._enabledSounds,\n    }) as AudioHelper;\n\n    this.audio.on('deviceChange', (lostActiveDevices: MediaDeviceInfo[]) => {\n      const activeConnection: Connection | null = this._activeConnection;\n      const deviceIds: string[] = lostActiveDevices.map((device: MediaDeviceInfo) => device.deviceId);\n\n      this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds,\n      }, activeConnection);\n\n      if (activeConnection) {\n        activeConnection.mediaStream._onInputDevicesChanged();\n      }\n    });\n\n    this.mediaPresence.audio = !this.options.noRegister;\n    this.updateToken(token);\n\n    // Setup close protection and make sure we clean up ongoing calls on unload.\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this.destroy);\n      window.addEventListener('pagehide', this.destroy);\n      if (this.options.closeProtection) {\n        window.addEventListener('beforeunload', this._confirmClose);\n      }\n    }\n\n    // (rrowland) This maintains backward compatibility, but we should look at\n    // removing this next breaking change. Any error should be caught by the\n    // customer, and anything that's not a fatal error should not be emitted\n    // via error event.\n    this.on(Device.EventName.Error, () => {\n      if (this.listenerCount('error') > 1) { return; }\n      this._log.info('Uncaught error event suppressed.');\n    });\n\n    return this;\n  }\n\n  /**\n   * Get the status of this {@link Device} instance\n   */\n  status(): Device.Status {\n    this._throwUnlessSetup('status');\n    return this._activeConnection ? Device.Status.Busy : this._status;\n  }\n\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n  toString() {\n    return '[Twilio.Device instance]';\n  }\n\n  /**\n   * Unregister to receiving incoming calls.\n   */\n  unregisterPresence(): this {\n    this._throwUnlessSetup('unregisterPresence');\n\n    this.mediaPresence.audio = false;\n    this._sendPresence();\n    return this;\n  }\n\n  /**\n   * Update the token and re-register.\n   * @param token - The new token JWT string to register with.\n   */\n  updateToken(token: string): void {\n    this._throwUnlessSetup('updateToken');\n    this.token = token;\n    this.register(token);\n  }\n\n  /**\n   * Add a handler for an EventEmitter and emit a deprecation warning on first call.\n   * @param eventName - Name of the event\n   * @param handler - A handler to call when the event is emitted\n   */\n  private _addHandler(eventName: Device.EventName, handler: (...args: any[]) => any): this {\n    if (!hasBeenWarnedHandlers) {\n      this._log.warn(`Device callback handlers (connect, error, offline, incoming, cancel, ready, disconnect) \\\n        have been deprecated and will be removed in the next breaking release. Instead, the EventEmitter \\\n        interface can be used to set event listeners. Example: device.on('${eventName}', handler)`);\n      hasBeenWarnedHandlers = true;\n    }\n\n    this.addListener(eventName, handler);\n    return this;\n  }\n\n  /**\n   * Calls the emit API such that it is asynchronous.\n   * Only use this internal API if you don't want to break the execution after raising an event.\n   * This prevents the issue where events are not dispatched to all handlers when one of the handlers throws an error.\n   * For example, our connection:accept is not triggered if the handler for device:connect handler throws an error.\n   * As a side effect, we are not able to perform our internal routines such as stopping incoming sounds.\n   * See connection:accept inside _makeConnection where we call emit('connect'). This can throw an error.\n   * See connection:accept inside _onSignalingInvite. This handler won't get called if the error above is thrown.\n   * @private\n   */\n  private _asyncEmit(event: string | symbol, ...args: any[]): void {\n    setTimeout(() => this.emit(event, ...args));\n  }\n\n  /**\n   * Called on window's beforeunload event if closeProtection is enabled,\n   * preventing users from accidentally navigating away from an active call.\n   * @param event\n   */\n  private _confirmClose = (event: any): string => {\n    if (!this._activeConnection) { return ''; }\n\n    const closeProtection: boolean | string = this.options.closeProtection || false;\n    const confirmationMsg: string = typeof closeProtection !== 'string'\n      ? 'A call is currently in-progress. Leaving or reloading this page will end the call.'\n      : closeProtection;\n\n    (event || window.event).returnValue = confirmationMsg;\n    return confirmationMsg;\n  }\n\n  /**\n   * Create the default Insights payload\n   * @param [connection]\n   */\n  private _createDefaultPayload = (connection?: Connection): Record<string, any> => {\n    const payload: Record<string, any> = {\n      aggressive_nomination: this.options.forceAggressiveIceNomination,\n      browser_extension: this._isBrowserExtension,\n      dscp: !!this.options.dscp,\n      ice_restart_enabled: this.options.enableIceRestart,\n      platform: rtc.getMediaEngine(),\n      sdk_version: C.RELEASE_VERSION,\n    };\n\n    function setIfDefined(propertyName: string, value: string | undefined | null) {\n      if (value) { payload[propertyName] = value; }\n    }\n\n    if (connection) {\n      const callSid = connection.parameters.CallSid;\n      setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n      setIfDefined('temp_call_sid', connection.outboundConnectionId);\n      setIfDefined('audio_codec', connection.codec);\n      payload.direction = connection.direction;\n    }\n\n    setIfDefined('gateway', this.stream && this.stream.gateway);\n    setIfDefined('selected_region', this.options.region);\n    setIfDefined('region', this.stream && this.stream.region);\n\n    return payload;\n  }\n\n  /**\n   * Disconnect all {@link Connection}s.\n   */\n  private _disconnectAll = (): void => {\n    const connections = this.connections.splice(0);\n    connections.forEach((conn: Connection) => conn.disconnect());\n\n    if (this._activeConnection) {\n      this._activeConnection.disconnect();\n    }\n  }\n\n  /**\n   * Find a {@link Connection} by its CallSid.\n   * @param callSid\n   */\n  private _findConnection(callSid: string): Connection | null {\n    return this.connections.find(conn => conn.parameters.CallSid === callSid\n      || conn.outboundConnectionId === callSid) || null;\n  }\n\n  /**\n   * Create a new {@link Connection}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param [options] - Options to be used to instantiate the {@link Connection}.\n   */\n  private _makeConnection(twimlParams: Record<string, string>, options?: Connection.Options): Connection {\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      throw new InvalidStateError('Device has not been initialized.');\n    }\n\n    const config: Connection.Config = {\n      audioHelper: this.audio,\n      getUserMedia,\n      isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n      pstream: this.stream,\n      publisher: this._publisher,\n      soundcache: this.soundcache,\n    };\n\n    options = Object.assign({\n      MediaStream: this.options.MediaStream\n        || this.options.mediaStreamFactory\n        || rtc.PeerConnection,\n      audioConstraints: this.options.audioConstraints,\n      beforeAccept: (conn: Connection) => {\n        if (!this._activeConnection || this._activeConnection === conn) {\n          return;\n        }\n\n        this._activeConnection.disconnect();\n        this._removeConnection(this._activeConnection);\n      },\n      codecPreferences: this.options.codecPreferences,\n      dialtonePlayer: Device._dialtonePlayer,\n      dscp: this.options.dscp,\n      enableIceRestart: this.options.enableIceRestart,\n      enableRingingState: this.options.enableRingingState,\n      forceAggressiveIceNomination: this.options.forceAggressiveIceNomination,\n      getInputStream: (): MediaStream | null => this.options.fileInputStream || this._connectionInputStream,\n      getSinkIds: (): string[] => this._connectionSinkIds,\n      maxAverageBitrate: this.options.maxAverageBitrate,\n      preflight: this.options.preflight,\n      rtcConfiguration: this.options.rtcConfiguration || { iceServers: this.options.iceServers },\n      rtcConstraints: this.options.rtcConstraints,\n      shouldPlayDisconnect: () => this._enabledSounds.disconnect,\n      twimlParams,\n    }, options);\n\n    const connection = new this.options.connectionFactory(config, options);\n\n    connection.once('accept', () => {\n      this._removeConnection(connection);\n      this._activeConnection = connection;\n      if (this.audio) {\n        this.audio._maybeStartPollingVolume();\n      }\n\n      if (connection.direction === Connection.CallDirection.Outgoing && this._enabledSounds.outgoing) {\n        this.soundcache.get(Device.SoundName.Outgoing).play();\n      }\n\n      const data: any = { edge: this._edge || this._region };\n      const selectedEdge = this.options.edge;\n      if (selectedEdge) {\n        data['selected_edge'] = Array.isArray(selectedEdge) ? selectedEdge : [selectedEdge];\n      }\n\n      this._publisher.info('settings', 'edge', data, connection);\n      this._asyncEmit('connect', connection);\n    });\n\n    connection.addListener('error', (error: Connection.Error) => {\n      if (connection.status() === 'closed') {\n        this._removeConnection(connection);\n      }\n      if (this.audio) {\n        this.audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n      this._asyncEmit('error', error);\n    });\n\n    connection.once('cancel', () => {\n      this._log.info(`Canceled: ${connection.parameters.CallSid}`);\n      this._removeConnection(connection);\n      if (this.audio) {\n        this.audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n      this._asyncEmit('cancel', connection);\n    });\n\n    connection.once('disconnect', () => {\n      if (this.audio) {\n        this.audio._maybeStopPollingVolume();\n      }\n      this._removeConnection(connection);\n      this._asyncEmit('disconnect', connection);\n    });\n\n    connection.once('reject', () => {\n      this._log.info(`Rejected: ${connection.parameters.CallSid}`);\n      if (this.audio) {\n        this.audio._maybeStopPollingVolume();\n      }\n      this._removeConnection(connection);\n      this._maybeStopIncomingSound();\n    });\n\n    connection.once('transportClose', () => {\n      if (connection.status() !== Connection.State.Pending) {\n        return;\n      }\n      if (this.audio) {\n        this.audio._maybeStopPollingVolume();\n      }\n      this._removeConnection(connection);\n      this._maybeStopIncomingSound();\n    });\n\n    return connection;\n  }\n\n  /**\n   * Stop the incoming sound if no {@link Connection}s remain.\n   */\n  private _maybeStopIncomingSound(): void {\n    if (!this.connections.length) {\n      this.soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  }\n\n  /**\n   * Called when a 'close' event is received from the signaling stream.\n   */\n  private _onSignalingClose = () => {\n    this.stream = null;\n  }\n\n  /**\n   * Called when a 'connected' event is received from the signaling stream.\n   */\n  private _onSignalingConnected = (payload: Record<string, any>) => {\n    const region = getRegionShortcode(payload.region);\n    this._edge = regionToEdge[region as Region] || payload.region;\n    this._region = region || payload.region;\n    this._sendPresence();\n  }\n\n  /**\n   * Called when an 'error' event is received from the signaling stream.\n   */\n  private _onSignalingError = (payload: Record<string, any>) => {\n    if (!payload.error) { return; }\n\n    const error = { ...payload.error };\n    const sid = payload.callsid;\n    if (sid) {\n      error.connection = this._findConnection(sid);\n    }\n\n    if (error.code === 31201) {\n      error.twilioError = new AuthorizationErrors.AuthenticationFailed();\n    } else if (error.code === 31204) {\n      error.twilioError = new AuthorizationErrors.AccessTokenInvalid();\n    } else if (error.code === 31205) {\n      // Stop trying to register presence after token expires\n      this._stopRegistrationTimer();\n      error.twilioError = new AuthorizationErrors.AccessTokenExpired();\n    } else if (!error.twilioError) {\n      error.twilioError = new GeneralErrors.UnknownError();\n    }\n\n    this._log.info('Received error: ', error);\n    this.emit('error', error);\n  }\n\n  /**\n   * Called when an 'invite' event is received from the signaling stream.\n   */\n  private _onSignalingInvite = (payload: Record<string, any>) => {\n    const wasBusy = !!this._activeConnection;\n    if (wasBusy && !this.options.allowIncomingWhileBusy) {\n      this._log.info('Device busy; ignoring incoming invite');\n      return;\n    }\n\n    if (!payload.callsid || !payload.sdp) {\n      this.emit('error', { message: 'Malformed invite from gateway', twilioError: new ClientErrors.BadRequest() });\n      return;\n    }\n\n    const callParameters = payload.parameters || { };\n    callParameters.CallSid = callParameters.CallSid || payload.callsid;\n\n    const customParameters = Object.assign({ }, queryToJson(callParameters.Params));\n    const connection = this._makeConnection(customParameters, {\n      callParameters,\n      offerSdp: payload.sdp,\n    });\n\n    this.connections.push(connection);\n\n    connection.once('accept', () => {\n      this.soundcache.get(Device.SoundName.Incoming).stop();\n      this._publishNetworkChange();\n    });\n\n    const play = (this._enabledSounds.incoming && !wasBusy)\n      ? () => this.soundcache.get(Device.SoundName.Incoming).play()\n      : () => Promise.resolve();\n\n    this._showIncomingConnection(connection, play);\n  }\n\n  /**\n   * Called when an 'offline' event is received from the signaling stream.\n   */\n  private _onSignalingOffline = () => {\n    this._log.info('Stream is offline');\n    this._status = Device.Status.Offline;\n    this._edge = null;\n    this._region = null;\n    this.emit('offline', this);\n  }\n\n  /**\n   * Called when a 'ready' event is received from the signaling stream.\n   */\n  private _onSignalingReady = () => {\n    this._log.info('Stream is ready');\n    this._status = Device.Status.Ready;\n    this.emit('ready', this);\n  }\n\n  /**\n   * Publish a NetworkInformation#change event to Insights if there's an active {@link Connection}.\n   */\n  private _publishNetworkChange = () => {\n    if (!this._activeConnection) {\n      return;\n    }\n\n    if (this._networkInformation) {\n      this._publisher.info('network-information', 'network-change', {\n        connection_type: this._networkInformation.type,\n        downlink: this._networkInformation.downlink,\n        downlinkMax: this._networkInformation.downlinkMax,\n        effective_type: this._networkInformation.effectiveType,\n        rtt: this._networkInformation.rtt,\n      }, this._activeConnection);\n    }\n  }\n\n  /**\n   * Remove a {@link Connection} from device.connections by reference\n   * @param connection\n   */\n  private _removeConnection(connection: Connection): void {\n    if (this._activeConnection === connection) {\n      this._activeConnection = null;\n    }\n\n    for (let i = this.connections.length - 1; i >= 0; i--) {\n      if (connection === this.connections[i]) {\n        this.connections.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Register with the signaling server.\n   */\n  private _sendPresence(): void {\n    if (!this.stream) { return; }\n\n    this.stream.register({ audio: this.mediaPresence.audio });\n    if (this.mediaPresence.audio) {\n      this._startRegistrationTimer();\n    } else {\n      this._stopRegistrationTimer();\n    }\n  }\n\n  /**\n   * Set up the connection to the signaling server.\n   * @param token\n   */\n  private _setupStream(token: string) {\n    this._log.info('Setting up VSP');\n    this.stream = this.options.pStreamFactory(token, this._chunderURIs, {\n      backoffMaxMs: this.options.backoffMaxMs,\n    });\n\n    this.stream.addListener('close', this._onSignalingClose);\n    this.stream.addListener('connected', this._onSignalingConnected);\n    this.stream.addListener('error', this._onSignalingError);\n    this.stream.addListener('invite', this._onSignalingInvite);\n    this.stream.addListener('offline', this._onSignalingOffline);\n    this.stream.addListener('ready', this._onSignalingReady);\n  }\n\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param connection\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n  private _showIncomingConnection(connection: Connection, play: Function): Promise<void> {\n    let timeout: NodeJS.Timer;\n    return Promise.race([\n      play(),\n      new Promise((resolve, reject) => {\n        timeout = setTimeout(() => {\n          const msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n          reject(new Error(msg));\n        }, RINGTONE_PLAY_TIMEOUT);\n      }),\n    ]).catch(reason => {\n      this._log.info(reason.message);\n    }).then(() => {\n      clearTimeout(timeout);\n      this.emit('incoming', connection);\n    });\n  }\n\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n  private _startRegistrationTimer(): void {\n    this._stopRegistrationTimer();\n    this.regTimer = setTimeout(() => {\n      this._sendPresence();\n    }, REGISTRATION_INTERVAL);\n  }\n\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n  private _stopRegistrationTimer(): void {\n    if (this.regTimer) {\n      clearTimeout(this.regTimer);\n    }\n  }\n\n  /**\n   * Throw an Error if Device.setup has not been called for this instance.\n   * @param methodName - The name of the method being called before setup()\n   */\n  private _throwUnlessSetup(methodName: string) {\n    if (!this.isInitialized) { throw new InvalidStateError(`Call Device.setup() before ${methodName}`); }\n  }\n\n  /**\n   * Update the input stream being used for calls so that any current call and all future calls\n   * will use the new input stream.\n   * @param inputStream\n   */\n  private _updateInputStream = (inputStream: MediaStream | null): Promise<void> => {\n    const connection: Connection | null = this._activeConnection;\n\n    if (connection && !inputStream) {\n      return Promise.reject(new InvalidStateError('Cannot unset input device while a call is in progress.'));\n    }\n\n    this._connectionInputStream = inputStream;\n    return connection\n      ? connection._setInputTracksFromStream(inputStream)\n      : Promise.resolve();\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateRingtoneSinkIds(sinkIds: string[]): Promise<void> {\n    return Promise.resolve(this.soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play sounds through.\n   * @param type - Whether to update ringtone or speaker sounds\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSinkIds = (type: 'ringtone' | 'speaker', sinkIds: string[]): Promise<void> => {\n    const promise: Promise<void> = type === 'ringtone'\n      ? this._updateRingtoneSinkIds(sinkIds)\n      : this._updateSpeakerSinkIds(sinkIds);\n\n    return promise.then(() => {\n      this._publisher.info('audio', `${type}-devices-set`, {\n        audio_device_ids: sinkIds,\n      }, this._activeConnection);\n    }, error => {\n      this._publisher.error('audio', `${type}-devices-set-failed`, {\n        audio_device_ids: sinkIds,\n        message: error.message,\n      }, this._activeConnection);\n\n      throw error;\n    });\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSpeakerSinkIds(sinkIds: string[]): Promise<void> {\n    Array.from(this.soundcache.entries())\n      .filter(entry => entry[0] !== Device.SoundName.Incoming)\n      .forEach(entry => entry[1].setSinkIds(sinkIds));\n\n    this._connectionSinkIds = sinkIds;\n    const connection = this._activeConnection;\n    return connection\n      ? connection._setSinkIds(sinkIds)\n      : Promise.resolve();\n  }\n\n  /**\n   * Register the {@link Device}\n   * @param token\n   */\n  private register(token: string): void {\n    if (this.stream) {\n      this.stream.setToken(token);\n      this._publisher.setToken(token);\n    } else {\n      this._setupStream(token);\n    }\n  }\n}\n\nnamespace Device {\n  /**\n   * Emitted when an incoming {@link Connection} is canceled.\n   * @param connection - The canceled {@link Connection}.\n   * @example `device.on('cancel', connection => { })`\n   * @event\n   */\n  declare function cancelEvent(connection: Connection): void;\n\n  /**\n   * Emitted when a {@link Connection} has been opened.\n   * @param connection - The {@link Connection} that was opened.\n   * @example `device.on('connect', connection => { })`\n   * @event\n   */\n  declare function connectEvent(connection: Connection): void;\n\n  /**\n   * Emitted when a {@link Connection} has been disconnected.\n   * @param connection - The {@link Connection} that was disconnected.\n   * @example `device.on('disconnect', connection => { })`\n   * @event\n   */\n  declare function disconnectEvent(connection: Connection): void;\n\n  /**\n   * Emitted when the {@link Device} receives an error.\n   * @param error\n   * @example `device.on('error', connection => { })`\n   * @event\n   */\n  declare function errorEvent(error: Connection): void;\n\n  /**\n   * Emitted when an incoming {@link Connection} is received.\n   * @param connection - The incoming {@link Connection}.\n   * @example `device.on('incoming', connection => { })`\n   * @event\n   */\n  declare function incomingEvent(connection: Connection): void;\n\n  /**\n   * Emitted when the {@link Device} goes offline.\n   * @param device\n   * @example `device.on('offline', device => { })`\n   * @event\n   */\n  declare function offlineEvent(device: Device): void;\n\n  /**\n   * Emitted when the {@link Device} is connected to signaling and ready.\n   * @param device\n   * @example `device.on('ready', device => { })`\n   * @event\n   */\n  declare function readyEvent(device: Device): void;\n\n  /**\n   * All valid {@link Device} event names.\n   */\n  export enum EventName {\n    Cancel = 'cancel',\n    Connect = 'connect',\n    Disconnect = 'disconnect',\n    Error = 'error',\n    Incoming = 'incoming',\n    Offline = 'offline',\n    Ready = 'ready',\n  }\n\n  /**\n   * All possible {@link Device} statuses.\n   */\n  export enum Status {\n    Busy = 'busy',\n    Offline = 'offline',\n    Ready = 'ready',\n  }\n\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n  export enum SoundName {\n    Incoming = 'incoming',\n    Outgoing = 'outgoing',\n    Disconnect = 'disconnect',\n    Dtmf0 = 'dtmf0',\n    Dtmf1 = 'dtmf1',\n    Dtmf2 = 'dtmf2',\n    Dtmf3 = 'dtmf3',\n    Dtmf4 = 'dtmf4',\n    Dtmf5 = 'dtmf5',\n    Dtmf6 = 'dtmf6',\n    Dtmf7 = 'dtmf7',\n    Dtmf8 = 'dtmf8',\n    Dtmf9 = 'dtmf9',\n    DtmfS = 'dtmfs',\n    DtmfH = 'dtmfh',\n  }\n\n  /**\n   * Names of all togglable sounds.\n   */\n  export type ToggleableSound = Device.SoundName.Incoming | Device.SoundName.Outgoing | Device.SoundName.Disconnect;\n\n  /**\n   * The error format used by errors emitted from {@link Device}.\n   */\n  export interface Error {\n    /**\n     * Error code\n     */\n    code: number;\n\n    /**\n     * Reference to the {@link Connection}\n     * This is usually available if the error is coming from {@link Connection}\n     */\n    connection?: Connection;\n\n    /**\n     * The info object from rtc/peerconnection or eventpublisher. May contain code and message (duplicated here).\n     */\n    info?: { code?: number, message?: string };\n\n    /**\n     * Error message\n     */\n    message: string;\n\n    /**\n     * Twilio Voice related error\n     */\n    twilioError?: TwilioError;\n  }\n\n  /**\n   * Options that may be passed to the {@link Device} constructor, or Device.setup via public API\n   */\n  export interface Options {\n    [key: string]: any;\n\n    /**\n     * Whether the Device should raise the {@link incomingEvent} event when a new call invite is\n     * received while already on an active call. Default behavior is false.\n     */\n    allowIncomingWhileBusy?: boolean;\n\n    /**\n     * A name for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific application, particularly in the case where\n     * one account may be connected to by multiple applications.\n     */\n    appName?: string;\n\n    /**\n     * A version for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific version of the given application. This can help\n     * track down when application-level bugs were introduced.\n     */\n    appVersion?: string;\n\n    /**\n     * Audio Constraints to pass to getUserMedia when making or accepting a Call.\n     * This is placed directly under `audio` of the MediaStreamConstraints object.\n     */\n    audioConstraints?: MediaTrackConstraints | boolean;\n\n    /**\n     * Whether to enable close protection, to prevent users from accidentally\n     * navigating away from the page during a call. If string, the value will\n     * be used as a custom message.\n     */\n    closeProtection?: boolean | string;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Connection.Codec[];\n\n    /**\n     * Whether to enable debug logging.\n     */\n    debug?: boolean;\n\n    /**\n     * Whether AudioContext sounds should be disabled. Useful for trouble shooting sound issues\n     * that may be caused by AudioContext-specific sounds. If set to true, will fall back to\n     * HTMLAudioElement sounds.\n     */\n    disableAudioContextSounds?: boolean;\n\n    /**\n     * Whether to use googDscp in RTC constraints.\n     */\n    dscp?: boolean;\n\n    /**\n     * The edge value corresponds to the geographic location that the client\n     * will use to connect to Twilio infrastructure. The default value is\n     * \"roaming\" which automatically selects an edge based on the latency of the\n     * client relative to available edges. You may not specify both `edge` and\n     * `region` in the Device options. Specifying both `edge` and `region` will\n     * result in an `InvalidArgumentException`.\n     */\n    edge?: string[] | string;\n\n    /**\n     * Whether to automatically restart ICE when media connection fails\n     */\n    enableIceRestart?: boolean;\n\n    /**\n     * Whether the ringing state should be enabled on {@link Connection} objects. This is required\n     * to enable answerOnBridge functionality.\n     */\n    enableRingingState?: boolean;\n\n    /**\n     * Whether or not to override the local DTMF sounds with fake dialtones. This won't affect\n     * the DTMF tone sent over the connection, but will prevent double-send issues caused by\n     * using real DTMF tones for user interface. In 2.0, this will be enabled by default.\n     */\n    fakeLocalDTMF?: boolean;\n\n    /**\n     * Experimental feature.\n     * Whether to use ICE Aggressive nomination.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * The region code of the region to connect to.\n     *\n     * @deprecated\n     *\n     * CLIENT-7519 This parameter is deprecated in favor of the `edge`\n     * parameter. You may not specify both `edge` and `region` in the Device\n     * options.\n     *\n     * This parameter will be removed in the next major version release.\n     *\n     * The following table lists the new edge names to region name mappings.\n     * Instead of passing the `region` value in `options.region`, please pass the\n     * following `edge` value in `options.edge`.\n     *\n     * | Region Value | Edge Value   |\n     * |:-------------|:-------------|\n     * | au1          | sydney       |\n     * | br1          | sao-paulo    |\n     * | ie1          | dublin       |\n     * | de1          | frankfurt    |\n     * | jp1          | tokyo        |\n     * | sg1          | singapore    |\n     * | us1          | ashburn      |\n     * | us2          | umatilla     |\n     * | gll          | roaming      |\n     * | us1-ix       | ashburn-ix   |\n     * | us2-ix       | san-jose-ix  |\n     * | ie1-ix       | london-ix    |\n     * | de1-ix       | frankfurt-ix |\n     * | sg1-ix       | singapore-ix |\n     */\n    region?: string;\n\n    /**\n     * An RTCConfiguration to pass to the RTCPeerConnection constructor.\n     */\n    rtcConfiguration?: RTCConfiguration;\n\n    /**\n     * A mapping of custom sound URLs by sound name.\n     */\n    sounds?: Partial<Record<Device.SoundName, string>>;\n\n    /**\n     * Whether to enable warn logging.\n     */\n    warnings?: boolean;\n  }\n}\n\nexport default Device;\n"]},"metadata":{},"sourceType":"script"}