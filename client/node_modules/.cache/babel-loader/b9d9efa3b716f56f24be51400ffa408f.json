{"ast":null,"code":"import { getReasonPhrase, newTag, utf8Length } from \"./utils.js\";\n/**\n * When a UAS wishes to construct a response to a request, it follows\n * the general procedures detailed in the following subsections.\n * Additional behaviors specific to the response code in question, which\n * are not detailed in this section, may also be required.\n * https://tools.ietf.org/html/rfc3261#section-8.2.6\n * @internal\n */\n\nexport function constructOutgoingResponse(message, options) {\n  const CRLF = \"\\r\\n\";\n\n  if (options.statusCode < 100 || options.statusCode > 699) {\n    throw new TypeError(\"Invalid statusCode: \" + options.statusCode);\n  }\n\n  const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(options.statusCode); // SIP responses are distinguished from requests by having a Status-Line\n  // as their start-line.  A Status-Line consists of the protocol version\n  // followed by a numeric Status-Code and its associated textual phrase,\n  // with each element separated by a single SP character.\n  // https://tools.ietf.org/html/rfc3261#section-7.2\n\n  let response = \"SIP/2.0 \" + options.statusCode + \" \" + reasonPhrase + CRLF; // One largely non-method-specific guideline for the generation of\n  // responses is that UASs SHOULD NOT issue a provisional response for a\n  // non-INVITE request.  Rather, UASs SHOULD generate a final response to\n  // a non-INVITE request as soon as possible.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n\n  if (options.statusCode >= 100 && options.statusCode < 200) {// TODO\n  } // When a 100 (Trying) response is generated, any Timestamp header field\n  // present in the request MUST be copied into this 100 (Trying)\n  // response.  If there is a delay in generating the response, the UAS\n  // SHOULD add a delay value into the Timestamp value in the response.\n  // This value MUST contain the difference between the time of sending of\n  // the response and receipt of the request, measured in seconds.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.1\n\n\n  if (options.statusCode === 100) {// TODO\n  } // The From field of the response MUST equal the From header field of\n  // the request.  The Call-ID header field of the response MUST equal the\n  // Call-ID header field of the request.  The CSeq header field of the\n  // response MUST equal the CSeq field of the request.  The Via header\n  // field values in the response MUST equal the Via header field values\n  // in the request and MUST maintain the same ordering.\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n\n\n  const fromHeader = \"From: \" + message.getHeader(\"From\") + CRLF;\n  const callIdHeader = \"Call-ID: \" + message.callId + CRLF;\n  const cSeqHeader = \"CSeq: \" + message.cseq + \" \" + message.method + CRLF;\n  const viaHeaders = message.getHeaders(\"via\").reduce((previous, current) => {\n    return previous + \"Via: \" + current + CRLF;\n  }, \"\"); // If a request contained a To tag in the request, the To header field\n  // in the response MUST equal that of the request.  However, if the To\n  // header field in the request did not contain a tag, the URI in the To\n  // header field in the response MUST equal the URI in the To header\n  // field; additionally, the UAS MUST add a tag to the To header field in\n  // the response (with the exception of the 100 (Trying) response, in\n  // which a tag MAY be present).  This serves to identify the UAS that is\n  // responding, possibly resulting in a component of a dialog ID.  The\n  // same tag MUST be used for all responses to that request, both final\n  // and provisional (again excepting the 100 (Trying)).\n  // https://tools.ietf.org/html/rfc3261#section-8.2.6.2\n\n  let toHeader = \"To: \" + message.getHeader(\"to\");\n\n  if (options.statusCode > 100 && !message.parseHeader(\"to\").hasParam(\"tag\")) {\n    let toTag = options.toTag;\n\n    if (!toTag) {\n      // Stateless UAS Behavior...\n      // o  To header tags MUST be generated for responses in a stateless\n      //    manner - in a manner that will generate the same tag for the\n      //    same request consistently.  For information on tag construction\n      //    see Section 19.3.\n      // https://tools.ietf.org/html/rfc3261#section-8.2.7\n      toTag = newTag(); // FIXME: newTag() currently generates random tags\n    }\n\n    toHeader += \";tag=\" + toTag;\n  }\n\n  toHeader += CRLF; // FIXME: TODO: needs review... moved to InviteUserAgentServer (as it is specific to that)\n  // let recordRouteHeaders = \"\";\n  // if (request.method === C.INVITE && statusCode > 100 && statusCode <= 200) {\n  //   recordRouteHeaders = request.getHeaders(\"record-route\").reduce((previous, current) => {\n  //     return previous + \"Record-Route: \" + current + CRLF;\n  //   }, \"\");\n  // }\n  // FIXME: TODO: needs review...\n\n  let supportedHeader = \"\";\n\n  if (options.supported) {\n    supportedHeader = \"Supported: \" + options.supported.join(\", \") + CRLF;\n  } // FIXME: TODO: needs review...\n\n\n  let userAgentHeader = \"\";\n\n  if (options.userAgent) {\n    userAgentHeader = \"User-Agent: \" + options.userAgent + CRLF;\n  }\n\n  let extensionHeaders = \"\";\n\n  if (options.extraHeaders) {\n    extensionHeaders = options.extraHeaders.reduce((previous, current) => {\n      return previous + current.trim() + CRLF;\n    }, \"\");\n  } // The relative order of header fields with different field names is not\n  // significant.  However, it is RECOMMENDED that header fields which are\n  // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n  // Max-Forwards, and Proxy-Authorization, for example) appear towards\n  // the top of the message to facilitate rapid parsing.\n  // https://tools.ietf.org/html/rfc3261#section-7.3.1\n  // response += recordRouteHeaders;\n\n\n  response += viaHeaders;\n  response += fromHeader;\n  response += toHeader;\n  response += cSeqHeader;\n  response += callIdHeader;\n  response += supportedHeader;\n  response += userAgentHeader;\n  response += extensionHeaders;\n\n  if (options.body) {\n    response += \"Content-Type: \" + options.body.contentType + CRLF;\n    response += \"Content-Length: \" + utf8Length(options.body.content) + CRLF + CRLF;\n    response += options.body.content;\n  } else {\n    response += \"Content-Length: \" + 0 + CRLF + CRLF;\n  }\n\n  return {\n    message: response\n  };\n}","map":null,"metadata":{},"sourceType":"module"}