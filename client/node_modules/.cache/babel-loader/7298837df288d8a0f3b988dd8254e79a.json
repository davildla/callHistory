{"ast":null,"code":"/**\n * A base class implementing a WebRTC session description handler for sip.js.\n * @remarks\n * It is expected/intended to be extended by specific WebRTC based applications.\n * @privateRemarks\n * So do not put application specific implementation in here.\n * @public\n */\nexport class SessionDescriptionHandler {\n  /**\n   * Constructor\n   * @param logger - A logger\n   * @param mediaStreamFactory - A factory to provide a MediaStream\n   * @param options - Options passed from the SessionDescriptionHandleFactory\n   */\n  constructor(logger, mediaStreamFactory, sessionDescriptionHandlerConfiguration) {\n    logger.debug(\"SessionDescriptionHandler.constructor\");\n    this.logger = logger;\n    this.mediaStreamFactory = mediaStreamFactory;\n    this.sessionDescriptionHandlerConfiguration = sessionDescriptionHandlerConfiguration;\n    this._localMediaStream = new MediaStream();\n    this._remoteMediaStream = new MediaStream();\n    this._peerConnection = new RTCPeerConnection(sessionDescriptionHandlerConfiguration === null || sessionDescriptionHandlerConfiguration === void 0 ? void 0 : sessionDescriptionHandlerConfiguration.peerConnectionConfiguration);\n    this.initPeerConnectionEventHandlers();\n  }\n  /**\n   * The local media stream currently being sent.\n   *\n   * @remarks\n   * The local media stream initially has no tracks, so the presence of tracks\n   * should not be assumed. Furthermore, tracks may be added or removed if the\n   * local media changes - for example, on upgrade from audio only to a video session.\n   * At any given time there will be at most one audio track and one video track\n   * (it's possible that this restriction may not apply to sub-classes).\n   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n   * to detect when a new track becomes available:\n   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n   */\n\n\n  get localMediaStream() {\n    return this._localMediaStream;\n  }\n  /**\n   * The remote media stream currently being received.\n   *\n   * @remarks\n   * The remote media stream initially has no tracks, so the presence of tracks\n   * should not be assumed. Furthermore, tracks may be added or removed if the\n   * remote media changes - for example, on upgrade from audio only to a video session.\n   * At any given time there will be at most one audio track and one video track\n   * (it's possible that this restriction may not apply to sub-classes).\n   * Use `MediaStream.onaddtrack` or add a listener for the `addtrack` event\n   * to detect when a new track becomes available:\n   * https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n   */\n\n\n  get remoteMediaStream() {\n    return this._remoteMediaStream;\n  }\n  /**\n   * The data channel. Undefined before it is created.\n   */\n\n\n  get dataChannel() {\n    return this._dataChannel;\n  }\n  /**\n   * The peer connection. Undefined if peer connection has closed.\n   *\n   * @remarks\n   * Use the peerConnectionDelegate to get access to the events associated\n   * with the RTCPeerConnection. For example...\n   *\n   * Do NOT do this...\n   * ```ts\n   * peerConnection.onicecandidate = (event) => {\n   *   // do something\n   * };\n   * ```\n   * Instead, do this...\n   * ```ts\n   * peerConnection.peerConnectionDelegate = {\n   *   onicecandidate: (event) => {\n   *     // do something\n   *   }\n   * };\n   * ```\n   * While access to the underlying `RTCPeerConnection` is provided, note that\n   * using methods which modify it may break the operation of this class.\n   * In particular, this class depends on exclusive access to the\n   * event handler properties. If you need access to the peer connection\n   * events, either register for events using `addEventListener()` on\n   * the `RTCPeerConnection` or set the `peerConnectionDelegate` on\n   * this `SessionDescriptionHandler`.\n   */\n\n\n  get peerConnection() {\n    return this._peerConnection;\n  }\n  /**\n   * A delegate which provides access to the peer connection event handlers.\n   *\n   * @remarks\n   * Use the peerConnectionDelegate to get access to the events associated\n   * with the RTCPeerConnection. For example...\n   *\n   * Do NOT do this...\n   * ```ts\n   * peerConnection.onicecandidate = (event) => {\n   *   // do something\n   * };\n   * ```\n   * Instead, do this...\n   * ```\n   * peerConnection.peerConnectionDelegate = {\n   *   onicecandidate: (event) => {\n   *     // do something\n   *   }\n   * };\n   * ```\n   * Setting the peer connection event handlers directly is not supported\n   * and may break this class. As this class depends on exclusive access\n   * to them. This delegate is intended to provide access to the\n   * RTCPeerConnection events in a fashion which is supported.\n   */\n\n\n  get peerConnectionDelegate() {\n    return this._peerConnectionDelegate;\n  }\n\n  set peerConnectionDelegate(delegate) {\n    this._peerConnectionDelegate = delegate;\n  } // The addtrack event does not get fired when JavaScript code explicitly adds tracks to the stream (by calling addTrack()).\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onaddtrack\n\n\n  static dispatchAddTrackEvent(stream, track) {\n    stream.dispatchEvent(new MediaStreamTrackEvent(\"addtrack\", {\n      track\n    }));\n  } // The removetrack event does not get fired when JavaScript code explicitly removes tracks from the stream (by calling removeTrack()).\n  // https://developer.mozilla.org/en-US/docs/Web/API/MediaStream/onremovetrack\n\n\n  static dispatchRemoveTrackEvent(stream, track) {\n    stream.dispatchEvent(new MediaStreamTrackEvent(\"removetrack\", {\n      track\n    }));\n  }\n  /**\n   * Stop tracks and close peer connection.\n   */\n\n\n  close() {\n    this.logger.debug(\"SessionDescriptionHandler.close\");\n\n    if (this._peerConnection === undefined) {\n      return;\n    }\n\n    this._peerConnection.getReceivers().forEach(receiver => {\n      receiver.track && receiver.track.stop();\n    });\n\n    this._peerConnection.getSenders().forEach(sender => {\n      sender.track && sender.track.stop();\n    });\n\n    if (this._dataChannel) {\n      this._dataChannel.close();\n    }\n\n    this._peerConnection.close();\n\n    this._peerConnection = undefined;\n  }\n  /**\n   * Helper function to enable/disable media tracks.\n   * @param enable - If true enable tracks, otherwise disable tracks.\n   */\n\n\n  enableReceiverTracks(enable) {\n    const peerConnection = this.peerConnection;\n\n    if (!peerConnection) {\n      throw new Error(\"Peer connection closed.\");\n    }\n\n    peerConnection.getReceivers().forEach(receiver => {\n      if (receiver.track) {\n        receiver.track.enabled = enable;\n      }\n    });\n  }\n  /**\n   * Helper function to enable/disable media tracks.\n   * @param enable - If true enable tracks, otherwise disable tracks.\n   */\n\n\n  enableSenderTracks(enable) {\n    const peerConnection = this.peerConnection;\n\n    if (!peerConnection) {\n      throw new Error(\"Peer connection closed.\");\n    }\n\n    peerConnection.getSenders().forEach(sender => {\n      if (sender.track) {\n        sender.track.enabled = enable;\n      }\n    });\n  }\n  /**\n   * Creates an offer or answer.\n   * @param options - Options bucket.\n   * @param modifiers - Modifiers.\n   */\n\n\n  getDescription(options, modifiers) {\n    var _a, _b;\n\n    this.logger.debug(\"SessionDescriptionHandler.getDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // Callback on data channel creation\n\n\n    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // ICE will restart upon applying an offer created with the iceRestart option\n\n    const iceRestart = (_a = options === null || options === void 0 ? void 0 : options.offerOptions) === null || _a === void 0 ? void 0 : _a.iceRestart; // ICE gathering timeout may be set on a per call basis, otherwise the configured default is used\n\n    const iceTimeout = (options === null || options === void 0 ? void 0 : options.iceGatheringTimeout) === undefined ? (_b = this.sessionDescriptionHandlerConfiguration) === null || _b === void 0 ? void 0 : _b.iceGatheringTimeout : options === null || options === void 0 ? void 0 : options.iceGatheringTimeout;\n    return this.getLocalMediaStream(options).then(() => this.updateDirection(options)).then(() => this.createDataChannel(options)).then(() => this.createLocalOfferOrAnswer(options)).then(sessionDescription => this.applyModifiers(sessionDescription, modifiers)).then(sessionDescription => this.setLocalSessionDescription(sessionDescription)).then(() => this.waitForIceGatheringComplete(iceRestart, iceTimeout)).then(() => this.getLocalSessionDescription()).then(sessionDescription => {\n      return {\n        body: sessionDescription.sdp,\n        contentType: \"application/sdp\"\n      };\n    }).catch(error => {\n      this.logger.error(\"SessionDescriptionHandler.getDescription failed - \" + error);\n      throw error;\n    });\n  }\n  /**\n   * Returns true if the SessionDescriptionHandler can handle the Content-Type described by a SIP message.\n   * @param contentType - The content type that is in the SIP Message.\n   */\n\n\n  hasDescription(contentType) {\n    this.logger.debug(\"SessionDescriptionHandler.hasDescription\");\n    return contentType === \"application/sdp\";\n  }\n  /**\n   * Called when ICE gathering completes and resolves any waiting promise.\n   * @remarks\n   * May be called prior to ICE gathering actually completing to allow the\n   * session descirption handler proceed with whatever candidates have been\n   * gathered up to this point in time. Use this to stop waiting on ICE to\n   * complete if you are implementing your own ICE gathering completion strategy.\n   */\n\n\n  iceGatheringComplete() {\n    this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete\"); // clear timer if need be\n\n    if (this.iceGatheringCompleteTimeoutId !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - clearing timeout\");\n      clearTimeout(this.iceGatheringCompleteTimeoutId);\n      this.iceGatheringCompleteTimeoutId = undefined;\n    } // resolve and cleanup promise if need be\n\n\n    if (this.iceGatheringCompletePromise !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.iceGatheringComplete - resolving promise\");\n      this.iceGatheringCompleteResolve && this.iceGatheringCompleteResolve();\n      this.iceGatheringCompletePromise = undefined;\n      this.iceGatheringCompleteResolve = undefined;\n      this.iceGatheringCompleteReject = undefined;\n    }\n  }\n  /**\n   * Send DTMF via RTP (RFC 4733).\n   * Returns true if DTMF send is successful, false otherwise.\n   * @param tones - A string containing DTMF digits.\n   * @param options - Options object to be used by sendDtmf.\n   */\n\n\n  sendDtmf(tones, options) {\n    this.logger.debug(\"SessionDescriptionHandler.sendDtmf\");\n\n    if (this._peerConnection === undefined) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - peer connection closed\");\n      return false;\n    }\n\n    const senders = this._peerConnection.getSenders();\n\n    if (senders.length === 0) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no senders\");\n      return false;\n    }\n\n    const dtmfSender = senders[0].dtmf;\n\n    if (!dtmfSender) {\n      this.logger.error(\"SessionDescriptionHandler.sendDtmf failed - no DTMF sender\");\n      return false;\n    }\n\n    const duration = options === null || options === void 0 ? void 0 : options.duration;\n    const interToneGap = options === null || options === void 0 ? void 0 : options.interToneGap;\n\n    try {\n      dtmfSender.insertDTMF(tones, duration, interToneGap);\n    } catch (e) {\n      this.logger.error(e.toString());\n      return false;\n    }\n\n    this.logger.log(\"SessionDescriptionHandler.sendDtmf sent via RTP: \" + tones.toString());\n    return true;\n  }\n  /**\n   * Sets an offer or answer.\n   * @param sdp - The session description.\n   * @param options - Options bucket.\n   * @param modifiers - Modifiers.\n   */\n\n\n  setDescription(sdp, options, modifiers) {\n    this.logger.debug(\"SessionDescriptionHandler.setDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // Callback on data channel creation\n\n\n    this.onDataChannel = options === null || options === void 0 ? void 0 : options.onDataChannel; // SDP type\n\n    const type = this._peerConnection.signalingState === \"have-local-offer\" ? \"answer\" : \"offer\";\n    return this.getLocalMediaStream(options).then(() => this.applyModifiers({\n      sdp,\n      type\n    }, modifiers)).then(sessionDescription => this.setRemoteSessionDescription(sessionDescription)).catch(error => {\n      this.logger.error(\"SessionDescriptionHandler.setDescription failed - \" + error);\n      throw error;\n    });\n  }\n  /**\n   * Applies modifiers to SDP prior to setting the local or remote description.\n   * @param sdp - SDP to modify.\n   * @param modifiers - Modifiers to apply.\n   */\n\n\n  applyModifiers(sdp, modifiers) {\n    this.logger.debug(\"SessionDescriptionHandler.applyModifiers\");\n\n    if (!modifiers || modifiers.length === 0) {\n      return Promise.resolve(sdp);\n    }\n\n    return modifiers.reduce((cur, next) => cur.then(next), Promise.resolve(sdp)).then(modified => {\n      this.logger.debug(\"SessionDescriptionHandler.applyModifiers - modified sdp\");\n\n      if (!modified.sdp || !modified.type) {\n        throw new Error(\"Invalid SDP.\");\n      }\n\n      return {\n        sdp: modified.sdp,\n        type: modified.type\n      };\n    });\n  }\n  /**\n   * Create a data channel.\n   * @remarks\n   * Only creates a data channel if SessionDescriptionHandlerOptions.dataChannel is true.\n   * Only creates a data channel if creating a local offer.\n   * Only if one does not already exist.\n   * @param options - Session description handler options.\n   */\n\n\n  createDataChannel(options) {\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // only create a data channel if requested\n\n\n    if ((options === null || options === void 0 ? void 0 : options.dataChannel) !== true) {\n      return Promise.resolve();\n    } // do not create a data channel if we already have one\n\n\n    if (this._dataChannel) {\n      return Promise.resolve();\n    }\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable, assume we are creating a local offer so create a data channel\n        this.logger.debug(\"SessionDescriptionHandler.createDataChannel - creating data channel\");\n\n        try {\n          this._dataChannel = this._peerConnection.createDataChannel((options === null || options === void 0 ? void 0 : options.dataChannelLabel) || \"\", options === null || options === void 0 ? void 0 : options.dataChannelOptions);\n\n          if (this.onDataChannel) {\n            this.onDataChannel(this._dataChannel);\n          }\n\n          return Promise.resolve();\n        } catch (error) {\n          return Promise.reject(error);\n        }\n\n      case \"have-remote-offer\":\n        return Promise.resolve();\n\n      case \"have-local-offer\":\n      case \"have-local-pranswer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n  }\n  /**\n   * Depending on current signaling state, create a local offer or answer.\n   * @param options - Session description handler options.\n   */\n\n\n  createLocalOfferOrAnswer(options) {\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable, assume we are creating a local offer\n        this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP offer\");\n        return this._peerConnection.createOffer(options === null || options === void 0 ? void 0 : options.offerOptions);\n\n      case \"have-remote-offer\":\n        // if we have a remote offer, assume we are creating a local answer\n        this.logger.debug(\"SessionDescriptionHandler.createLocalOfferOrAnswer - creating SDP answer\");\n        return this._peerConnection.createAnswer(options === null || options === void 0 ? void 0 : options.answerOptions);\n\n      case \"have-local-offer\":\n      case \"have-local-pranswer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n  }\n  /**\n   * Get a media stream from the media stream factory and set the local media stream.\n   * @param options - Session description handler options.\n   */\n\n\n  getLocalMediaStream(options) {\n    this.logger.debug(\"SessionDescriptionHandler.getLocalMediaStream\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    let constraints = Object.assign({}, options === null || options === void 0 ? void 0 : options.constraints); // if we already have a local media stream...\n\n    if (this.localMediaStreamConstraints) {\n      // ignore constraint \"downgrades\"\n      constraints.audio = constraints.audio || this.localMediaStreamConstraints.audio;\n      constraints.video = constraints.video || this.localMediaStreamConstraints.video; // if constraints have not changed, do not get a new media stream\n\n      if (JSON.stringify(this.localMediaStreamConstraints.audio) === JSON.stringify(constraints.audio) && JSON.stringify(this.localMediaStreamConstraints.video) === JSON.stringify(constraints.video)) {\n        return Promise.resolve();\n      }\n    } else {\n      // if no constraints have been specified, default to audio for initial media stream\n      if (constraints.audio === undefined && constraints.video === undefined) {\n        constraints = {\n          audio: true\n        };\n      }\n    }\n\n    this.localMediaStreamConstraints = constraints;\n    return this.mediaStreamFactory(constraints, this, options).then(mediaStream => this.setLocalMediaStream(mediaStream));\n  }\n  /**\n   * Sets the peer connection's sender tracks and local media stream tracks.\n   *\n   * @remarks\n   * Only the first audio and video tracks of the provided MediaStream are utilized.\n   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n   *\n   * @param stream - Media stream containing tracks to be utilized.\n   */\n\n\n  setLocalMediaStream(stream) {\n    this.logger.debug(\"SessionDescriptionHandler.setLocalMediaStream\");\n\n    if (!this._peerConnection) {\n      throw new Error(\"Peer connection undefined.\");\n    }\n\n    const pc = this._peerConnection;\n    const localStream = this._localMediaStream;\n    const trackUpdates = [];\n\n    const updateTrack = newTrack => {\n      const kind = newTrack.kind;\n\n      if (kind !== \"audio\" && kind !== \"video\") {\n        throw new Error(`Unknown new track kind ${kind}.`);\n      }\n\n      const sender = pc.getSenders().find(sender => sender.track && sender.track.kind === kind);\n\n      if (sender) {\n        trackUpdates.push(new Promise(resolve => {\n          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - replacing sender ${kind} track`);\n          resolve();\n        }).then(() => sender.replaceTrack(newTrack).then(() => {\n          const oldTrack = localStream.getTracks().find(localTrack => localTrack.kind === kind);\n\n          if (oldTrack) {\n            oldTrack.stop();\n            localStream.removeTrack(oldTrack);\n            SessionDescriptionHandler.dispatchRemoveTrackEvent(localStream, oldTrack);\n          }\n\n          localStream.addTrack(newTrack);\n          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n        }).catch(error => {\n          this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to replace sender ${kind} track`);\n          throw error;\n        })));\n      } else {\n        trackUpdates.push(new Promise(resolve => {\n          this.logger.debug(`SessionDescriptionHandler.setLocalMediaStream - adding sender ${kind} track`);\n          resolve();\n        }).then(() => {\n          // Review: could make streamless tracks a configurable option?\n          // https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/addTrack#Usage_notes\n          try {\n            pc.addTrack(newTrack, localStream);\n          } catch (error) {\n            this.logger.error(`SessionDescriptionHandler.setLocalMediaStream - failed to add sender ${kind} track`);\n            throw error;\n          }\n\n          localStream.addTrack(newTrack);\n          SessionDescriptionHandler.dispatchAddTrackEvent(localStream, newTrack);\n        }));\n      }\n    }; // update peer connection audio tracks\n\n\n    const audioTracks = stream.getAudioTracks();\n\n    if (audioTracks.length) {\n      updateTrack(audioTracks[0]);\n    } // update peer connection video tracks\n\n\n    const videoTracks = stream.getVideoTracks();\n\n    if (videoTracks.length) {\n      updateTrack(videoTracks[0]);\n    }\n\n    return trackUpdates.reduce((p, x) => p.then(() => x), Promise.resolve());\n  }\n  /**\n   * Gets the peer connection's local session description.\n   */\n\n\n  getLocalSessionDescription() {\n    this.logger.debug(\"SessionDescriptionHandler.getLocalSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    const sdp = this._peerConnection.localDescription;\n\n    if (!sdp) {\n      return Promise.reject(new Error(\"Failed to get local session description\"));\n    }\n\n    return Promise.resolve(sdp);\n  }\n  /**\n   * Sets the peer connection's local session description.\n   * @param sessionDescription - sessionDescription The session description.\n   */\n\n\n  setLocalSessionDescription(sessionDescription) {\n    this.logger.debug(\"SessionDescriptionHandler.setLocalSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    return this._peerConnection.setLocalDescription(sessionDescription);\n  }\n  /**\n   * Sets the peer connection's remote session description.\n   * @param sessionDescription - The session description.\n   */\n\n\n  setRemoteSessionDescription(sessionDescription) {\n    this.logger.debug(\"SessionDescriptionHandler.setRemoteSessionDescription\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    }\n\n    const sdp = sessionDescription.sdp;\n    let type;\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable assume this is a remote offer\n        type = \"offer\";\n        break;\n\n      case \"have-local-offer\":\n        // if we made an offer, assume this is a remote answer\n        type = \"answer\";\n        break;\n\n      case \"have-local-pranswer\":\n      case \"have-remote-offer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n\n    if (!sdp) {\n      this.logger.error(\"SessionDescriptionHandler.setRemoteSessionDescription failed - cannot set null sdp\");\n      return Promise.reject(new Error(\"SDP is undefined\"));\n    }\n\n    return this._peerConnection.setRemoteDescription({\n      sdp,\n      type\n    });\n  }\n  /**\n   * Sets a remote media stream track.\n   *\n   * @remarks\n   * Adds tracks if audio and/or video tracks are not already present, otherwise replaces tracks.\n   *\n   * @param track - Media stream track to be utilized.\n   */\n\n\n  setRemoteTrack(track) {\n    this.logger.debug(\"SessionDescriptionHandler.setRemoteTrack\");\n    const remoteStream = this._remoteMediaStream;\n\n    if (remoteStream.getTrackById(track.id)) {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - have remote ${track.kind} track`);\n    } else if (track.kind === \"audio\") {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n      remoteStream.getAudioTracks().forEach(track => {\n        track.stop();\n        remoteStream.removeTrack(track);\n        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n      });\n      remoteStream.addTrack(track);\n      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n    } else if (track.kind === \"video\") {\n      this.logger.debug(`SessionDescriptionHandler.setRemoteTrack - adding remote ${track.kind} track`);\n      remoteStream.getVideoTracks().forEach(track => {\n        track.stop();\n        remoteStream.removeTrack(track);\n        SessionDescriptionHandler.dispatchRemoveTrackEvent(remoteStream, track);\n      });\n      remoteStream.addTrack(track);\n      SessionDescriptionHandler.dispatchAddTrackEvent(remoteStream, track);\n    }\n  }\n  /**\n   * Depending on the current signaling state and the session hold state, update transceiver direction.\n   * @param options - Session description handler options.\n   */\n\n\n  updateDirection(options) {\n    if (this._peerConnection === undefined) {\n      return Promise.reject(new Error(\"Peer connection closed.\"));\n    } // 4.2.3.  setDirection\n    //\n    //    The setDirection method sets the direction of a transceiver, which\n    //    affects the direction property of the associated \"m=\" section on\n    //    future calls to createOffer and createAnswer.  The permitted values\n    //    for direction are \"recvonly\", \"sendrecv\", \"sendonly\", and \"inactive\",\n    //    mirroring the identically named direction attributes defined in\n    //    [RFC4566], Section 6.\n    //\n    //    When creating offers, the transceiver direction is directly reflected\n    //    in the output, even for re-offers.  When creating answers, the\n    //    transceiver direction is intersected with the offered direction, as\n    //    explained in Section 5.3 below.\n    //\n    //    Note that while setDirection sets the direction property of the\n    //    transceiver immediately (Section 4.2.4), this property does not\n    //    immediately affect whether the transceiver's RtpSender will send or\n    //    its RtpReceiver will receive.  The direction in effect is represented\n    //    by the currentDirection property, which is only updated when an\n    //    answer is applied.\n    //\n    // 4.2.4.  direction\n    //\n    //    The direction property indicates the last value passed into\n    //    setDirection.  If setDirection has never been called, it is set to\n    //    the direction the transceiver was initialized with.\n    //\n    // 4.2.5.  currentDirection\n    //\n    //    The currentDirection property indicates the last negotiated direction\n    //    for the transceiver's associated \"m=\" section.  More specifically, it\n    //    indicates the direction attribute [RFC3264] of the associated \"m=\"\n    //    section in the last applied answer (including provisional answers),\n    //    with \"send\" and \"recv\" directions reversed if it was a remote answer.\n    //    For example, if the direction attribute for the associated \"m=\"\n    //    section in a remote answer is \"recvonly\", currentDirection is set to\n    //    \"sendonly\".\n    //\n    //    If an answer that references this transceiver has not yet been\n    //    applied or if the transceiver is stopped, currentDirection is set to\n    //    \"null\".\n    //  https://tools.ietf.org/html/rfc8829#section-4.2.3\n    //\n    // *  A direction attribute, determined by applying the rules regarding\n    //    the offered direction specified in [RFC3264], Section 6.1, and\n    //    then intersecting with the direction of the associated\n    //    RtpTransceiver.  For example, in the case where an \"m=\" section is\n    //    offered as \"sendonly\" and the local transceiver is set to\n    //    \"sendrecv\", the result in the answer is a \"recvonly\" direction.\n    // https://tools.ietf.org/html/rfc8829#section-5.3.1\n    //\n    // If a stream is offered as sendonly, the corresponding stream MUST be\n    // marked as recvonly or inactive in the answer.  If a media stream is\n    // listed as recvonly in the offer, the answer MUST be marked as\n    // sendonly or inactive in the answer.  If an offered media stream is\n    // listed as sendrecv (or if there is no direction attribute at the\n    // media or session level, in which case the stream is sendrecv by\n    // default), the corresponding stream in the answer MAY be marked as\n    // sendonly, recvonly, sendrecv, or inactive.  If an offered media\n    // stream is listed as inactive, it MUST be marked as inactive in the\n    // answer.\n    // https://tools.ietf.org/html/rfc3264#section-6.1\n\n\n    switch (this._peerConnection.signalingState) {\n      case \"stable\":\n        // if we are stable, assume we are creating a local offer\n        this.logger.debug(\"SessionDescriptionHandler.updateDirection - setting offer direction\");\n        {\n          // determine the direction to offer given the current direction and hold state\n          const directionToOffer = currentDirection => {\n            switch (currentDirection) {\n              case \"inactive\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"inactive\" : \"recvonly\";\n\n              case \"recvonly\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"inactive\" : \"recvonly\";\n\n              case \"sendonly\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"sendonly\" : \"sendrecv\";\n\n              case \"sendrecv\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"sendonly\" : \"sendrecv\";\n\n              case \"stopped\":\n                return \"stopped\";\n\n              default:\n                throw new Error(\"Should never happen\");\n            }\n          }; // set the transceiver direction to the offer direction\n\n\n          this._peerConnection.getTransceivers().forEach(transceiver => {\n            if (transceiver.direction\n            /* guarding, but should always be true */\n            ) {\n              const offerDirection = directionToOffer(transceiver.direction);\n\n              if (transceiver.direction !== offerDirection) {\n                transceiver.direction = offerDirection;\n              }\n            }\n          });\n        }\n        break;\n\n      case \"have-remote-offer\":\n        // if we have a remote offer, assume we are creating a local answer\n        this.logger.debug(\"SessionDescriptionHandler.updateDirection - setting answer direction\"); // FIXME: This is not the correct way to determine the answer direction as it is only\n        // considering first match in the offered SDP and using that to determine the answer direction.\n        // While that may be fine for our current use cases, it is not a generally correct approach.\n\n        {\n          // determine the offered direction\n          const offeredDirection = (() => {\n            const description = this._peerConnection.remoteDescription;\n\n            if (!description) {\n              throw new Error(\"Failed to read remote offer\");\n            }\n\n            const searchResult = /a=sendrecv\\r\\n|a=sendonly\\r\\n|a=recvonly\\r\\n|a=inactive\\r\\n/.exec(description.sdp);\n\n            if (searchResult) {\n              switch (searchResult[0]) {\n                case \"a=inactive\\r\\n\":\n                  return \"inactive\";\n\n                case \"a=recvonly\\r\\n\":\n                  return \"recvonly\";\n\n                case \"a=sendonly\\r\\n\":\n                  return \"sendonly\";\n\n                case \"a=sendrecv\\r\\n\":\n                  return \"sendrecv\";\n\n                default:\n                  throw new Error(\"Should never happen\");\n              }\n            }\n\n            return \"sendrecv\";\n          })(); // determine the answer direction based on the offered direction and our hold state\n\n\n          const answerDirection = (() => {\n            switch (offeredDirection) {\n              case \"inactive\":\n                return \"inactive\";\n\n              case \"recvonly\":\n                return \"sendonly\";\n\n              case \"sendonly\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"inactive\" : \"recvonly\";\n\n              case \"sendrecv\":\n                return (options === null || options === void 0 ? void 0 : options.hold) ? \"sendonly\" : \"sendrecv\";\n\n              default:\n                throw new Error(\"Should never happen\");\n            }\n          })(); // set the transceiver direction to the answer direction\n\n\n          this._peerConnection.getTransceivers().forEach(transceiver => {\n            if (transceiver.direction\n            /* guarding, but should always be true */\n            ) {\n              if (transceiver.direction !== \"stopped\" && transceiver.direction !== answerDirection) {\n                transceiver.direction = answerDirection;\n              }\n            }\n          });\n        }\n        break;\n\n      case \"have-local-offer\":\n      case \"have-local-pranswer\":\n      case \"have-remote-pranswer\":\n      case \"closed\":\n      default:\n        return Promise.reject(new Error(\"Invalid signaling state \" + this._peerConnection.signalingState));\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * Wait for ICE gathering to complete.\n   * @param restart - If true, waits if current state is \"complete\" (waits for transition to \"complete\").\n   * @param timeout - Milliseconds after which waiting times out. No timeout if 0.\n   */\n\n\n  waitForIceGatheringComplete() {\n    let restart = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete\");\n\n    if (this._peerConnection === undefined) {\n      return Promise.reject(\"Peer connection closed.\");\n    } // guard already complete\n\n\n    if (!restart && this._peerConnection.iceGatheringState === \"complete\") {\n      this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - already complete\");\n      return Promise.resolve();\n    } // only one may be waiting, reject any prior\n\n\n    if (this.iceGatheringCompletePromise !== undefined) {\n      this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - rejecting prior waiting promise\");\n      this.iceGatheringCompleteReject && this.iceGatheringCompleteReject(new Error(\"Promise superseded.\"));\n      this.iceGatheringCompletePromise = undefined;\n      this.iceGatheringCompleteResolve = undefined;\n      this.iceGatheringCompleteReject = undefined;\n    }\n\n    this.iceGatheringCompletePromise = new Promise((resolve, reject) => {\n      this.iceGatheringCompleteResolve = resolve;\n      this.iceGatheringCompleteReject = reject;\n\n      if (timeout > 0) {\n        this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout in \" + timeout);\n        this.iceGatheringCompleteTimeoutId = setTimeout(() => {\n          this.logger.debug(\"SessionDescriptionHandler.waitForIceGatheringToComplete - timeout\");\n          this.iceGatheringComplete();\n        }, timeout);\n      }\n    });\n    return this.iceGatheringCompletePromise;\n  }\n  /**\n   * Initializes the peer connection event handlers\n   */\n\n\n  initPeerConnectionEventHandlers() {\n    this.logger.debug(\"SessionDescriptionHandler.initPeerConnectionEventHandlers\");\n    if (!this._peerConnection) throw new Error(\"Peer connection undefined.\");\n    const peerConnection = this._peerConnection;\n\n    peerConnection.onconnectionstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.connectionState;\n      this.logger.debug(`SessionDescriptionHandler.onconnectionstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onconnectionstatechange) {\n        this._peerConnectionDelegate.onconnectionstatechange(event);\n      }\n    };\n\n    peerConnection.ondatachannel = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.ondatachannel`);\n      this._dataChannel = event.channel;\n\n      if (this.onDataChannel) {\n        this.onDataChannel(this._dataChannel);\n      }\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ondatachannel) {\n        this._peerConnectionDelegate.ondatachannel(event);\n      }\n    };\n\n    peerConnection.onicecandidate = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onicecandidate`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidate) {\n        this._peerConnectionDelegate.onicecandidate(event);\n      }\n    };\n\n    peerConnection.onicecandidateerror = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onicecandidateerror`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicecandidateerror) {\n        this._peerConnectionDelegate.onicecandidateerror(event);\n      }\n    };\n\n    peerConnection.oniceconnectionstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.iceConnectionState;\n      this.logger.debug(`SessionDescriptionHandler.oniceconnectionstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.oniceconnectionstatechange) {\n        this._peerConnectionDelegate.oniceconnectionstatechange(event);\n      }\n    };\n\n    peerConnection.onicegatheringstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.iceGatheringState;\n      this.logger.debug(`SessionDescriptionHandler.onicegatheringstatechange ${newState}`);\n\n      if (newState === \"complete\") {\n        this.iceGatheringComplete(); // complete waiting for ICE gathering to complete\n      }\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onicegatheringstatechange) {\n        this._peerConnectionDelegate.onicegatheringstatechange(event);\n      }\n    };\n\n    peerConnection.onnegotiationneeded = event => {\n      var _a;\n\n      this.logger.debug(`SessionDescriptionHandler.onnegotiationneeded`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onnegotiationneeded) {\n        this._peerConnectionDelegate.onnegotiationneeded(event);\n      }\n    };\n\n    peerConnection.onsignalingstatechange = event => {\n      var _a;\n\n      const newState = peerConnection.signalingState;\n      this.logger.debug(`SessionDescriptionHandler.onsignalingstatechange ${newState}`);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.onsignalingstatechange) {\n        this._peerConnectionDelegate.onsignalingstatechange(event);\n      }\n    };\n\n    peerConnection.ontrack = event => {\n      var _a;\n\n      const kind = event.track.kind;\n      const enabled = event.track.enabled ? \"enabled\" : \"disabled\";\n      this.logger.debug(`SessionDescriptionHandler.ontrack ${kind} ${enabled}`);\n      this.setRemoteTrack(event.track);\n\n      if ((_a = this._peerConnectionDelegate) === null || _a === void 0 ? void 0 : _a.ontrack) {\n        this._peerConnectionDelegate.ontrack(event);\n      }\n    };\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}