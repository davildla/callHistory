{"ast":null,"code":"import { NameAddrHeader } from \"../../grammar/name-addr-header.js\";\nimport { C } from \"../messages/methods/constants.js\";\nimport { SubscriptionState } from \"../subscription/subscription.js\";\nimport { Timers } from \"../timers.js\";\nimport { AllowedMethods } from \"../user-agent-core/allowed-methods.js\";\nimport { NotifyUserAgentServer } from \"../user-agents/notify-user-agent-server.js\";\nimport { ReSubscribeUserAgentClient } from \"../user-agents/re-subscribe-user-agent-client.js\";\nimport { Dialog } from \"./dialog.js\";\n/**\n * Subscription Dialog.\n * @remarks\n * SIP-Specific Event Notification\n *\n * Abstract\n *\n *    This document describes an extension to the Session Initiation\n *    Protocol (SIP) defined by RFC 3261.  The purpose of this extension is\n *    to provide an extensible framework by which SIP nodes can request\n *    notification from remote nodes indicating that certain events have\n *    occurred.\n *\n *    Note that the event notification mechanisms defined herein are NOT\n *    intended to be a general-purpose infrastructure for all classes of\n *    event subscription and notification.\n *\n *    This document represents a backwards-compatible improvement on the\n *    original mechanism described by RFC 3265, taking into account several\n *    years of implementation experience.  Accordingly, this document\n *    obsoletes RFC 3265.  This document also updates RFC 4660 slightly to\n *    accommodate some small changes to the mechanism that were discussed\n *    in that document.\n *\n *  https://tools.ietf.org/html/rfc6665\n * @public\n */\n\nexport class SubscriptionDialog extends Dialog {\n  constructor(subscriptionEvent, subscriptionExpires, subscriptionState, core, state, delegate) {\n    super(core, state);\n    this.delegate = delegate;\n    this._autoRefresh = false;\n    this._subscriptionEvent = subscriptionEvent;\n    this._subscriptionExpires = subscriptionExpires;\n    this._subscriptionExpiresInitial = subscriptionExpires;\n    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n    this._subscriptionRefresh = undefined;\n    this._subscriptionRefreshLastSet = undefined;\n    this._subscriptionState = subscriptionState;\n    this.logger = core.loggerFactory.getLogger(\"sip.subscribe-dialog\");\n    this.logger.log(`SUBSCRIBE dialog ${this.id} constructed`);\n  }\n  /**\n   * When a UAC receives a response that establishes a dialog, it\n   * constructs the state of the dialog.  This state MUST be maintained\n   * for the duration of the dialog.\n   * https://tools.ietf.org/html/rfc3261#section-12.1.2\n   * @param outgoingRequestMessage - Outgoing request message for dialog.\n   * @param incomingResponseMessage - Incoming response message creating dialog.\n   */\n\n\n  static initialDialogStateForSubscription(outgoingSubscribeRequestMessage, incomingNotifyRequestMessage) {\n    // If the request was sent over TLS, and the Request-URI contained a\n    // SIPS URI, the \"secure\" flag is set to TRUE.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n    const secure = false; // FIXME: Currently no support for TLS.\n    // The route set MUST be set to the list of URIs in the Record-Route\n    // header field from the response, taken in reverse order and preserving\n    // all URI parameters.  If no Record-Route header field is present in\n    // the response, the route set MUST be set to the empty set.  This route\n    // set, even if empty, overrides any pre-existing route set for future\n    // requests in this dialog.  The remote target MUST be set to the URI\n    // from the Contact header field of the response.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const routeSet = incomingNotifyRequestMessage.getHeaders(\"record-route\");\n    const contact = incomingNotifyRequestMessage.parseHeader(\"contact\");\n\n    if (!contact) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Contact undefined.\");\n    }\n\n    if (!(contact instanceof NameAddrHeader)) {\n      throw new Error(\"Contact not instance of NameAddrHeader.\");\n    }\n\n    const remoteTarget = contact.uri; // The local sequence number MUST be set to the value of the sequence\n    // number in the CSeq header field of the request.  The remote sequence\n    // number MUST be empty (it is established when the remote UA sends a\n    // request within the dialog).  The call identifier component of the\n    // dialog ID MUST be set to the value of the Call-ID in the request.\n    // The local tag component of the dialog ID MUST be set to the tag in\n    // the From field in the request, and the remote tag component of the\n    // dialog ID MUST be set to the tag in the To field of the response.  A\n    // UAC MUST be prepared to receive a response without a tag in the To\n    // field, in which case the tag is considered to have a value of null.\n    //\n    //    This is to maintain backwards compatibility with RFC 2543, which\n    //    did not mandate To tags.\n    //\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n    const localSequenceNumber = outgoingSubscribeRequestMessage.cseq;\n    const remoteSequenceNumber = undefined;\n    const callId = outgoingSubscribeRequestMessage.callId;\n    const localTag = outgoingSubscribeRequestMessage.fromTag;\n    const remoteTag = incomingNotifyRequestMessage.fromTag;\n\n    if (!callId) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"Call id undefined.\");\n    }\n\n    if (!localTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From tag undefined.\");\n    }\n\n    if (!remoteTag) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To tag undefined.\"); // FIXME: No backwards compatibility with RFC 2543\n    } // The remote URI MUST be set to the URI in the To field, and the local\n    // URI MUST be set to the URI in the From field.\n    // https://tools.ietf.org/html/rfc3261#section-12.1.2\n\n\n    if (!outgoingSubscribeRequestMessage.from) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"From undefined.\");\n    }\n\n    if (!outgoingSubscribeRequestMessage.to) {\n      // TODO: Review to make sure this will never happen\n      throw new Error(\"To undefined.\");\n    }\n\n    const localURI = outgoingSubscribeRequestMessage.from.uri;\n    const remoteURI = outgoingSubscribeRequestMessage.to.uri; // A dialog can also be in the \"early\" state, which occurs when it is\n    // created with a provisional response, and then transition to the\n    // \"confirmed\" state when a 2xx final response arrives.\n    // https://tools.ietf.org/html/rfc3261#section-12\n\n    const early = false;\n    const dialogState = {\n      id: callId + localTag + remoteTag,\n      early,\n      callId,\n      localTag,\n      remoteTag,\n      localSequenceNumber,\n      remoteSequenceNumber,\n      localURI,\n      remoteURI,\n      remoteTarget,\n      routeSet,\n      secure\n    };\n    return dialogState;\n  }\n\n  dispose() {\n    super.dispose();\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    }\n\n    this.refreshTimerClear();\n    this.logger.log(`SUBSCRIBE dialog ${this.id} destroyed`);\n  }\n\n  get autoRefresh() {\n    return this._autoRefresh;\n  }\n\n  set autoRefresh(autoRefresh) {\n    this._autoRefresh = true;\n    this.refreshTimerSet();\n  }\n\n  get subscriptionEvent() {\n    return this._subscriptionEvent;\n  }\n  /** Number of seconds until subscription expires. */\n\n\n  get subscriptionExpires() {\n    const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionExpiresLastSet;\n\n    const secondsUntilExpires = this._subscriptionExpires - secondsSinceLastSet;\n    return Math.max(secondsUntilExpires, 0);\n  }\n\n  set subscriptionExpires(expires) {\n    if (expires < 0) {\n      throw new Error(\"Expires must be greater than or equal to zero.\");\n    }\n\n    this._subscriptionExpires = expires;\n    this._subscriptionExpiresLastSet = Math.floor(Date.now() / 1000);\n\n    if (this.autoRefresh) {\n      const refresh = this.subscriptionRefresh;\n\n      if (refresh === undefined || refresh >= expires) {\n        this.refreshTimerSet();\n      }\n    }\n  }\n\n  get subscriptionExpiresInitial() {\n    return this._subscriptionExpiresInitial;\n  }\n  /** Number of seconds until subscription auto refresh. */\n\n\n  get subscriptionRefresh() {\n    if (this._subscriptionRefresh === undefined || this._subscriptionRefreshLastSet === undefined) {\n      return undefined;\n    }\n\n    const secondsSinceLastSet = Math.floor(Date.now() / 1000) - this._subscriptionRefreshLastSet;\n\n    const secondsUntilExpires = this._subscriptionRefresh - secondsSinceLastSet;\n    return Math.max(secondsUntilExpires, 0);\n  }\n\n  get subscriptionState() {\n    return this._subscriptionState;\n  }\n  /**\n   * Receive in dialog request message from transport.\n   * @param message -  The incoming request message.\n   */\n\n\n  receiveRequest(message) {\n    this.logger.log(`SUBSCRIBE dialog ${this.id} received ${message.method} request`); // Request within a dialog out of sequence guard.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n    if (!this.sequenceGuard(message)) {\n      this.logger.log(`SUBSCRIBE dialog ${this.id} rejected out of order ${message.method} request.`);\n      return;\n    } // Request within a dialog common processing.\n    // https://tools.ietf.org/html/rfc3261#section-12.2.2\n\n\n    super.receiveRequest(message); // Switch on method and then delegate.\n\n    switch (message.method) {\n      case C.NOTIFY:\n        this.onNotify(message);\n        break;\n\n      default:\n        this.logger.log(`SUBSCRIBE dialog ${this.id} received unimplemented ${message.method} request`);\n        this.core.replyStateless(message, {\n          statusCode: 501\n        });\n        break;\n    }\n  }\n  /**\n   * 4.1.2.2.  Refreshing of Subscriptions\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   */\n\n\n  refresh() {\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const options = {};\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n    options.extraHeaders.push(\"Expires: \" + this.subscriptionExpiresInitial);\n    options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    return this.subscribe(undefined, options);\n  }\n  /**\n   * 4.1.2.2.  Refreshing of Subscriptions\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   * @param delegate - Delegate to handle responses.\n   * @param options - Options bucket.\n   */\n\n\n  subscribe(delegate) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var _a;\n\n    if (this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n      // FIXME: This needs to be a proper exception\n      throw new Error(`Invalid state ${this.subscriptionState}. May only re-subscribe while in state \"pending\" or \"active\".`);\n    }\n\n    this.logger.log(`SUBSCRIBE dialog ${this.id} sending SUBSCRIBE request`);\n    const uac = new ReSubscribeUserAgentClient(this, delegate, options); // Abort any outstanding timer (as it would otherwise become guaranteed to terminate us).\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    }\n\n    if (!((_a = options.extraHeaders) === null || _a === void 0 ? void 0 : _a.includes(\"Expires: 0\"))) {\n      // When refreshing a subscription, a subscriber starts Timer N, set to\n      // 64*T1, when it sends the SUBSCRIBE request.\n      // https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n      this.N = setTimeout(() => this.timerN(), Timers.TIMER_N);\n    }\n\n    return uac;\n  }\n  /**\n   * 4.4.1.  Dialog Creation and Termination\n   * A subscription is destroyed after a notifier sends a NOTIFY request\n   * with a \"Subscription-State\" of \"terminated\", or in certain error\n   * situations described elsewhere in this document.\n   * https://tools.ietf.org/html/rfc6665#section-4.4.1\n   */\n\n\n  terminate() {\n    this.stateTransition(SubscriptionState.Terminated);\n    this.onTerminated();\n  }\n  /**\n   * 4.1.2.3.  Unsubscribing\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.3\n   */\n\n\n  unsubscribe() {\n    const allowHeader = \"Allow: \" + AllowedMethods.toString();\n    const options = {};\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(allowHeader);\n    options.extraHeaders.push(\"Event: \" + this.subscriptionEvent);\n    options.extraHeaders.push(\"Expires: 0\");\n    options.extraHeaders.push(\"Contact: \" + this.core.configuration.contact.toString());\n    return this.subscribe(undefined, options);\n  }\n  /**\n   * Handle in dialog NOTIFY requests.\n   * This does not include the first NOTIFY which created the dialog.\n   * @param message - The incoming NOTIFY request message.\n   */\n\n\n  onNotify(message) {\n    // If, for some reason, the event package designated in the \"Event\"\n    // header field of the NOTIFY request is not supported, the subscriber\n    // will respond with a 489 (Bad Event) response.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n    const event = message.parseHeader(\"Event\").event;\n\n    if (!event || event !== this.subscriptionEvent) {\n      this.core.replyStateless(message, {\n        statusCode: 489\n      });\n      return;\n    } // In the state diagram, \"Re-subscription times out\" means that an\n    // attempt to refresh or update the subscription using a new SUBSCRIBE\n    // request does not result in a NOTIFY request before the corresponding\n    // Timer N expires.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.2\n\n\n    if (this.N) {\n      clearTimeout(this.N);\n      this.N = undefined;\n    } // NOTIFY requests MUST contain \"Subscription-State\" header fields that\n    // indicate the status of the subscription.\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    const subscriptionState = message.parseHeader(\"Subscription-State\");\n\n    if (!subscriptionState || !subscriptionState.state) {\n      this.core.replyStateless(message, {\n        statusCode: 489\n      });\n      return;\n    }\n\n    const state = subscriptionState.state;\n    const expires = subscriptionState.expires ? Math.max(subscriptionState.expires, 0) : undefined; // Update our state and expiration.\n\n    switch (state) {\n      case \"pending\":\n        this.stateTransition(SubscriptionState.Pending, expires);\n        break;\n\n      case \"active\":\n        this.stateTransition(SubscriptionState.Active, expires);\n        break;\n\n      case \"terminated\":\n        this.stateTransition(SubscriptionState.Terminated, expires);\n        break;\n\n      default:\n        this.logger.warn(\"Unrecognized subscription state.\");\n        break;\n    } // Delegate remainder of NOTIFY handling.\n\n\n    const uas = new NotifyUserAgentServer(this, message);\n\n    if (this.delegate && this.delegate.onNotify) {\n      this.delegate.onNotify(uas);\n    } else {\n      uas.accept();\n    }\n  }\n\n  onRefresh(request) {\n    if (this.delegate && this.delegate.onRefresh) {\n      this.delegate.onRefresh(request);\n    }\n  }\n\n  onTerminated() {\n    if (this.delegate && this.delegate.onTerminated) {\n      this.delegate.onTerminated();\n    }\n  }\n\n  refreshTimerClear() {\n    if (this.refreshTimer) {\n      clearTimeout(this.refreshTimer);\n      this.refreshTimer = undefined;\n    }\n  }\n\n  refreshTimerSet() {\n    this.refreshTimerClear();\n\n    if (this.autoRefresh && this.subscriptionExpires > 0) {\n      const refresh = this.subscriptionExpires * 900;\n      this._subscriptionRefresh = Math.floor(refresh / 1000);\n      this._subscriptionRefreshLastSet = Math.floor(Date.now() / 1000);\n      this.refreshTimer = setTimeout(() => {\n        this.refreshTimer = undefined;\n        this._subscriptionRefresh = undefined;\n        this._subscriptionRefreshLastSet = undefined;\n        this.onRefresh(this.refresh());\n      }, refresh);\n    }\n  }\n\n  stateTransition(newState, newExpires) {\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      this.logger.warn(`Invalid subscription state transition from ${this.subscriptionState} to ${newState}`);\n    };\n\n    switch (newState) {\n      case SubscriptionState.Initial:\n        invalidStateTransition();\n        return;\n\n      case SubscriptionState.NotifyWait:\n        invalidStateTransition();\n        return;\n\n      case SubscriptionState.Pending:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      case SubscriptionState.Active:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      case SubscriptionState.Terminated:\n        if (this.subscriptionState !== SubscriptionState.NotifyWait && this.subscriptionState !== SubscriptionState.Pending && this.subscriptionState !== SubscriptionState.Active) {\n          invalidStateTransition();\n          return;\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n        return;\n    } // If the \"Subscription-State\" value is \"pending\", the subscription has\n    // been received by the notifier, but there is insufficient policy\n    // information to grant or deny the subscription yet.  If the header\n    // field also contains an \"expires\" parameter, the subscriber SHOULD\n    // take it as the authoritative subscription duration and adjust\n    // accordingly.  No further action is necessary on the part of the\n    // subscriber.  The \"retry-after\" and \"reason\" parameters have no\n    // semantics for \"pending\".\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    if (newState === SubscriptionState.Pending) {\n      if (newExpires) {\n        this.subscriptionExpires = newExpires;\n      }\n    } // If the \"Subscription-State\" header field value is \"active\", it means\n    // that the subscription has been accepted and (in general) has been\n    // authorized.  If the header field also contains an \"expires\"\n    // parameter, the subscriber SHOULD take it as the authoritative\n    // subscription duration and adjust accordingly.  The \"retry-after\" and\n    // \"reason\" parameters have no semantics for \"active\".\n    // https://tools.ietf.org/html/rfc6665#section-4.1.3\n\n\n    if (newState === SubscriptionState.Active) {\n      if (newExpires) {\n        this.subscriptionExpires = newExpires;\n      }\n    } // If the \"Subscription-State\" value is \"terminated\", the subscriber\n    // MUST consider the subscription terminated.  The \"expires\" parameter\n    // has no semantics for \"terminated\" -- notifiers SHOULD NOT include an\n    // \"expires\" parameter on a \"Subscription-State\" header field with a\n    // value of \"terminated\", and subscribers MUST ignore any such\n    // parameter, if present.\n\n\n    if (newState === SubscriptionState.Terminated) {\n      this.dispose();\n    }\n\n    this._subscriptionState = newState;\n  }\n  /**\n   * When refreshing a subscription, a subscriber starts Timer N, set to\n   * 64*T1, when it sends the SUBSCRIBE request.  If this Timer N expires\n   * prior to the receipt of a NOTIFY request, the subscriber considers\n   * the subscription terminated.  If the subscriber receives a success\n   * response to the SUBSCRIBE request that indicates that no NOTIFY\n   * request will be generated -- such as the 204 response defined for use\n   * with the optional extension described in [RFC5839] -- then it MUST\n   * cancel Timer N.\n   * https://tools.ietf.org/html/rfc6665#section-4.1.2.2\n   */\n\n\n  timerN() {\n    this.logger.warn(`Timer N expired for SUBSCRIBE dialog. Timed out waiting for NOTIFY.`);\n\n    if (this.subscriptionState !== SubscriptionState.Terminated) {\n      this.stateTransition(SubscriptionState.Terminated);\n      this.onTerminated();\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}