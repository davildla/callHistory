{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar r0 = 94.768; // Constant used in computing \"rFactor\".\n\n/**\n * Calculate the mos score of a stats object\n * @param {number} rtt\n * @param {number} jitter\n * @param {number} fractionLost - The fraction of packets that have been lost.\n * Calculated by packetsLost / totalPackets\n * @return {number | null} mos - Calculated MOS, `1.0` through roughly `4.5`.\n * Returns `null` when any of the input parameters are not a `non-negative`\n * number.\n */\n\nfunction calculate(rtt, jitter, fractionLost) {\n  if (typeof rtt !== 'number' || typeof jitter !== 'number' || typeof fractionLost !== 'number' || !isNonNegativeNumber(rtt) || !isNonNegativeNumber(jitter) || !isNonNegativeNumber(fractionLost)) {\n    return null;\n  } // Compute the effective latency.\n\n\n  var effectiveLatency = rtt + jitter * 2 + 10; // Compute the initial \"rFactor\" from effective latency.\n\n  var rFactor = 0;\n\n  switch (true) {\n    case effectiveLatency < 160:\n      rFactor = r0 - effectiveLatency / 40;\n      break;\n\n    case effectiveLatency < 1000:\n      rFactor = r0 - (effectiveLatency - 120) / 10;\n      break;\n  } // Adjust \"rFactor\" with the fraction of packets lost.\n\n\n  switch (true) {\n    case fractionLost <= rFactor / 2.5:\n      rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);\n      break;\n\n    default:\n      rFactor = 0;\n      break;\n  } // Compute MOS from \"rFactor\".\n\n\n  var mos = 1 + 0.035 * rFactor + 0.000007 * rFactor * (rFactor - 60) * (100 - rFactor);\n  return mos;\n}\n\nexports.calculate = calculate;\n/**\n * Returns true if and only if the parameter passed is a number, is not `NaN`,\n * is finite, and is greater than or equal to `0`.\n * @param n\n */\n\nfunction isNonNegativeNumber(n) {\n  return typeof n === 'number' && !isNaN(n) && isFinite(n) && n >= 0;\n}\n\nexports.isNonNegativeNumber = isNonNegativeNumber;\nexports.default = {\n  calculate: calculate,\n  isNonNegativeNumber: isNonNegativeNumber\n};","map":{"version":3,"mappings":";;;;;AAAA,IAAMA,EAAE,GAAG,MAAX,C,CAAmB;;AAEnB;;;;;;;;;;;AAUA,SAAgBC,SAAhB,CACEC,GADF,EAEEC,MAFF,EAGEC,YAHF,EAGmB;EAEjB,IACE,OAAOF,GAAP,KAAe,QAAf,IACA,OAAOC,MAAP,KAAkB,QADlB,IAEA,OAAOC,YAAP,KAAwB,QAFxB,IAGA,CAACC,mBAAmB,CAACH,GAAD,CAHpB,IAIA,CAACG,mBAAmB,CAACF,MAAD,CAJpB,IAKA,CAACE,mBAAmB,CAACD,YAAD,CANtB,EAOE;IACA,OAAO,IAAP;EACD,CAXgB,CAajB;;;EACA,IAAME,gBAAgB,GAAWJ,GAAG,GAAIC,MAAM,GAAG,CAAhB,GAAqB,EAAtD,CAdiB,CAgBjB;;EACA,IAAII,OAAO,GAAW,CAAtB;;EACA,QAAQ,IAAR;IACE,KAAKD,gBAAgB,GAAG,GAAxB;MACEC,OAAO,GAAGP,EAAE,GAAIM,gBAAgB,GAAG,EAAnC;MACA;;IACF,KAAKA,gBAAgB,GAAG,IAAxB;MACEC,OAAO,GAAGP,EAAE,GAAI,CAACM,gBAAgB,GAAG,GAApB,IAA2B,EAA3C;MACA;EANJ,CAlBiB,CA2BjB;;;EACA,QAAQ,IAAR;IACE,KAAKF,YAAY,IAAKG,OAAO,GAAG,GAAhC;MACEA,OAAO,GAAGC,IAAI,CAACC,GAAL,CAASF,OAAO,GAAGH,YAAY,GAAG,GAAlC,EAAuC,IAAvC,CAAV;MACA;;IACF;MACEG,OAAO,GAAG,CAAV;MACA;EANJ,CA5BiB,CAqCjB;;;EACA,IAAMG,GAAG,GAAW,IACjB,QAAQH,OADS,GAEjB,WAAWA,OAAZ,IACCA,OAAO,GAAG,EADX,KAEC,MAAMA,OAFP,CAFF;EAMA,OAAOG,GAAP;AACD;;AAhDDC;AAkDA;;;;;;AAKA,SAAgBN,mBAAhB,CAAoCO,CAApC,EAA0C;EACxC,OAAO,OAAOA,CAAP,KAAa,QAAb,IAAyB,CAACC,KAAK,CAACD,CAAD,CAA/B,IAAsCE,QAAQ,CAACF,CAAD,CAA9C,IAAqDA,CAAC,IAAI,CAAjE;AACD;;AAFDD;AAIAA,kBAAe;EACbV,SAAS,WADI;EAEbI,mBAAmB;AAFN,CAAf","names":["r0","calculate","rtt","jitter","fractionLost","isNonNegativeNumber","effectiveLatency","rFactor","Math","max","mos","exports","n","isNaN","isFinite"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/rtc/mos.ts"],"sourcesContent":["const r0 = 94.768; // Constant used in computing \"rFactor\".\n\n/**\n * Calculate the mos score of a stats object\n * @param {number} rtt\n * @param {number} jitter\n * @param {number} fractionLost - The fraction of packets that have been lost.\n * Calculated by packetsLost / totalPackets\n * @return {number | null} mos - Calculated MOS, `1.0` through roughly `4.5`.\n * Returns `null` when any of the input parameters are not a `non-negative`\n * number.\n */\nexport function calculate(\n  rtt: any,\n  jitter: any,\n  fractionLost: any,\n): number | null {\n  if (\n    typeof rtt !== 'number' ||\n    typeof jitter !== 'number' ||\n    typeof fractionLost !== 'number' ||\n    !isNonNegativeNumber(rtt) ||\n    !isNonNegativeNumber(jitter) ||\n    !isNonNegativeNumber(fractionLost)\n  ) {\n    return null;\n  }\n\n  // Compute the effective latency.\n  const effectiveLatency: number = rtt + (jitter * 2) + 10;\n\n  // Compute the initial \"rFactor\" from effective latency.\n  let rFactor: number = 0;\n  switch (true) {\n    case effectiveLatency < 160:\n      rFactor = r0 - (effectiveLatency / 40);\n      break;\n    case effectiveLatency < 1000:\n      rFactor = r0 - ((effectiveLatency - 120) / 10);\n      break;\n  }\n\n  // Adjust \"rFactor\" with the fraction of packets lost.\n  switch (true) {\n    case fractionLost <= (rFactor / 2.5):\n      rFactor = Math.max(rFactor - fractionLost * 2.5, 6.52);\n      break;\n    default:\n      rFactor = 0;\n      break;\n  }\n\n  // Compute MOS from \"rFactor\".\n  const mos: number = 1 +\n    (0.035 * rFactor) +\n    (0.000007 * rFactor) *\n    (rFactor - 60) *\n    (100 - rFactor);\n\n  return mos;\n}\n\n/**\n * Returns true if and only if the parameter passed is a number, is not `NaN`,\n * is finite, and is greater than or equal to `0`.\n * @param n\n */\nexport function isNonNegativeNumber(n: any): boolean {\n  return typeof n === 'number' && !isNaN(n) && isFinite(n) && n >= 0;\n}\n\nexport default {\n  calculate,\n  isNonNegativeNumber,\n};\n"]},"metadata":{},"sourceType":"script"}