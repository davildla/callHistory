{"ast":null,"code":"import { NameAddrHeader } from \"../../grammar/name-addr-header.js\";\nimport { createRandomToken, headerize, newTag, utf8Length } from \"./utils.js\";\n/**\n * Outgoing SIP request message.\n * @public\n */\n\nexport class OutgoingRequestMessage {\n  constructor(method, ruri, fromURI, toURI, options, extraHeaders, body) {\n    this.headers = {};\n    this.extraHeaders = []; // Initialize default options\n\n    this.options = OutgoingRequestMessage.getDefaultOptions(); // Options - merge a deep copy\n\n    if (options) {\n      this.options = Object.assign(Object.assign({}, this.options), options);\n\n      if (this.options.optionTags && this.options.optionTags.length) {\n        this.options.optionTags = this.options.optionTags.slice();\n      }\n\n      if (this.options.routeSet && this.options.routeSet.length) {\n        this.options.routeSet = this.options.routeSet.slice();\n      }\n    } // Extra headers - deep copy\n\n\n    if (extraHeaders && extraHeaders.length) {\n      this.extraHeaders = extraHeaders.slice();\n    } // Body - deep copy\n\n\n    if (body) {\n      // TODO: internal representation should be Body\n      // this.body = { ...body };\n      this.body = {\n        body: body.content,\n        contentType: body.contentType\n      };\n    } // Method\n\n\n    this.method = method; // RURI\n\n    this.ruri = ruri.clone(); // From\n\n    this.fromURI = fromURI.clone();\n    this.fromTag = this.options.fromTag ? this.options.fromTag : newTag();\n    this.from = OutgoingRequestMessage.makeNameAddrHeader(this.fromURI, this.options.fromDisplayName, this.fromTag); // To\n\n    this.toURI = toURI.clone();\n    this.toTag = this.options.toTag;\n    this.to = OutgoingRequestMessage.makeNameAddrHeader(this.toURI, this.options.toDisplayName, this.toTag); // Call-ID\n\n    this.callId = this.options.callId ? this.options.callId : this.options.callIdPrefix + createRandomToken(15); // CSeq\n\n    this.cseq = this.options.cseq; // The relative order of header fields with different field names is not\n    // significant.  However, it is RECOMMENDED that header fields which are\n    // needed for proxy processing (Via, Route, Record-Route, Proxy-Require,\n    // Max-Forwards, and Proxy-Authorization, for example) appear towards\n    // the top of the message to facilitate rapid parsing.\n    // https://tools.ietf.org/html/rfc3261#section-7.3.1\n\n    this.setHeader(\"route\", this.options.routeSet);\n    this.setHeader(\"via\", \"\");\n    this.setHeader(\"to\", this.to.toString());\n    this.setHeader(\"from\", this.from.toString());\n    this.setHeader(\"cseq\", this.cseq + \" \" + this.method);\n    this.setHeader(\"call-id\", this.callId);\n    this.setHeader(\"max-forwards\", \"70\");\n  }\n  /** Get a copy of the default options. */\n\n\n  static getDefaultOptions() {\n    return {\n      callId: \"\",\n      callIdPrefix: \"\",\n      cseq: 1,\n      toDisplayName: \"\",\n      toTag: \"\",\n      fromDisplayName: \"\",\n      fromTag: \"\",\n      forceRport: false,\n      hackViaTcp: false,\n      optionTags: [\"outbound\"],\n      routeSet: [],\n      userAgentString: \"sip.js\",\n      viaHost: \"\"\n    };\n  }\n\n  static makeNameAddrHeader(uri, displayName, tag) {\n    const parameters = {};\n\n    if (tag) {\n      parameters.tag = tag;\n    }\n\n    return new NameAddrHeader(uri, displayName, parameters);\n  }\n  /**\n   * Get the value of the given header name at the given position.\n   * @param name - header name\n   * @returns Returns the specified header, undefined if header doesn't exist.\n   */\n\n\n  getHeader(name) {\n    const header = this.headers[headerize(name)];\n\n    if (header) {\n      if (header[0]) {\n        return header[0];\n      }\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const exHeader of this.extraHeaders) {\n        if (regexp.test(exHeader)) {\n          return exHeader.substring(exHeader.indexOf(\":\") + 1).trim();\n        }\n      }\n    }\n\n    return;\n  }\n  /**\n   * Get the header/s of the given name.\n   * @param name - header name\n   * @returns Array with all the headers of the specified name.\n   */\n\n\n  getHeaders(name) {\n    const result = [];\n    const headerArray = this.headers[headerize(name)];\n\n    if (headerArray) {\n      for (const headerPart of headerArray) {\n        result.push(headerPart);\n      }\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const exHeader of this.extraHeaders) {\n        if (regexp.test(exHeader)) {\n          result.push(exHeader.substring(exHeader.indexOf(\":\") + 1).trim());\n        }\n      }\n    }\n\n    return result;\n  }\n  /**\n   * Verify the existence of the given header.\n   * @param name - header name\n   * @returns true if header with given name exists, false otherwise\n   */\n\n\n  hasHeader(name) {\n    if (this.headers[headerize(name)]) {\n      return true;\n    } else {\n      const regexp = new RegExp(\"^\\\\s*\" + name + \"\\\\s*:\", \"i\");\n\n      for (const extraHeader of this.extraHeaders) {\n        if (regexp.test(extraHeader)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Replace the the given header by the given value.\n   * @param name - header name\n   * @param value - header value\n   */\n\n\n  setHeader(name, value) {\n    this.headers[headerize(name)] = value instanceof Array ? value : [value];\n  }\n  /**\n   * The Via header field indicates the transport used for the transaction\n   * and identifies the location where the response is to be sent.  A Via\n   * header field value is added only after the transport that will be\n   * used to reach the next hop has been selected (which may involve the\n   * usage of the procedures in [4]).\n   *\n   * When the UAC creates a request, it MUST insert a Via into that\n   * request.  The protocol name and protocol version in the header field\n   * MUST be SIP and 2.0, respectively.  The Via header field value MUST\n   * contain a branch parameter.  This parameter is used to identify the\n   * transaction created by that request.  This parameter is used by both\n   * the client and the server.\n   * https://tools.ietf.org/html/rfc3261#section-8.1.1.7\n   * @param branchParameter - The branch parameter.\n   * @param transport - The sent protocol transport.\n   */\n\n\n  setViaHeader(branch, transport) {\n    // FIXME: Hack\n    if (this.options.hackViaTcp) {\n      transport = \"TCP\";\n    }\n\n    let via = \"SIP/2.0/\" + transport;\n    via += \" \" + this.options.viaHost + \";branch=\" + branch;\n\n    if (this.options.forceRport) {\n      via += \";rport\";\n    }\n\n    this.setHeader(\"via\", via);\n    this.branch = branch;\n  }\n\n  toString() {\n    let msg = \"\";\n    msg += this.method + \" \" + this.ruri.toRaw() + \" SIP/2.0\\r\\n\";\n\n    for (const header in this.headers) {\n      if (this.headers[header]) {\n        for (const headerPart of this.headers[header]) {\n          msg += header + \": \" + headerPart + \"\\r\\n\";\n        }\n      }\n    }\n\n    for (const header of this.extraHeaders) {\n      msg += header.trim() + \"\\r\\n\";\n    }\n\n    msg += \"Supported: \" + this.options.optionTags.join(\", \") + \"\\r\\n\";\n    msg += \"User-Agent: \" + this.options.userAgentString + \"\\r\\n\";\n\n    if (this.body) {\n      if (typeof this.body === \"string\") {\n        msg += \"Content-Length: \" + utf8Length(this.body) + \"\\r\\n\\r\\n\";\n        msg += this.body;\n      } else {\n        if (this.body.body && this.body.contentType) {\n          msg += \"Content-Type: \" + this.body.contentType + \"\\r\\n\";\n          msg += \"Content-Length: \" + utf8Length(this.body.body) + \"\\r\\n\\r\\n\";\n          msg += this.body.body;\n        } else {\n          msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n        }\n      }\n    } else {\n      msg += \"Content-Length: \" + 0 + \"\\r\\n\\r\\n\";\n    }\n\n    return msg;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}