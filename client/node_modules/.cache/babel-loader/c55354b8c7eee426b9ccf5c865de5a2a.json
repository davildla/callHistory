{"ast":null,"code":"\"use strict\";\n\nvar _regenerator = require(\"babel-runtime/regenerator\");\n\nvar _regenerator2 = _interopRequireDefault(_regenerator);\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar __awaiter = undefined && undefined.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar Deferred_1 = require(\"./Deferred\");\n\nvar EventTarget_1 = require(\"./EventTarget\");\n/**\n * An {@link AudioPlayer} is an HTMLAudioElement-like object that uses AudioContext\n *   to circumvent browser limitations.\n */\n\n\nvar AudioPlayer = function (_EventTarget_1$defaul) {\n  _inherits(AudioPlayer, _EventTarget_1$defaul);\n  /**\n   * @private\n   */\n\n\n  function AudioPlayer(audioContext) {\n    var srcOrOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    _classCallCheck(this, AudioPlayer);\n    /**\n     * The AudioBufferSourceNode of the actively loaded sound. Null if a sound\n     *   has not been loaded yet. This is re-used for each time the sound is\n     *   played.\n     */\n\n\n    var _this = _possibleConstructorReturn(this, (AudioPlayer.__proto__ || Object.getPrototypeOf(AudioPlayer)).call(this));\n\n    _this._audioNode = null;\n    /**\n     * An Array of deferred-like objects for each pending `play` Promise. When\n     *   .pause() is called or .src is set, all pending play Promises are\n     *   immediately rejected.\n     */\n\n    _this._pendingPlayDeferreds = [];\n    /**\n     * Whether or not the audio element should loop. If disabled during playback,\n     *   playing continues until the sound ends and then stops looping.\n     */\n\n    _this._loop = false;\n    /**\n     * The source URL of the sound to play. When set, the currently playing sound will stop.\n     */\n\n    _this._src = '';\n    /**\n     * The current sinkId of the device audio is being played through.\n     */\n\n    _this._sinkId = 'default';\n\n    if (typeof srcOrOptions !== 'string') {\n      options = srcOrOptions;\n    }\n\n    _this._audioContext = audioContext;\n    _this._audioElement = new (options.AudioFactory || Audio)();\n    _this._bufferPromise = _this._createPlayDeferred().promise;\n    _this._destination = _this._audioContext.destination;\n    _this._gainNode = _this._audioContext.createGain();\n\n    _this._gainNode.connect(_this._destination);\n\n    _this._XMLHttpRequest = options.XMLHttpRequestFactory || XMLHttpRequest;\n\n    _this.addEventListener('canplaythrough', function () {\n      _this._resolvePlayDeferreds();\n    });\n\n    if (typeof srcOrOptions === 'string') {\n      _this.src = srcOrOptions;\n    }\n\n    return _this;\n  }\n\n  _createClass(AudioPlayer, [{\n    key: \"load\",\n\n    /**\n     * Stop any ongoing playback and reload the source file.\n     */\n    value: function load() {\n      this._load(this._src);\n    }\n    /**\n     * Pause the audio coming from this AudioPlayer. This will reject any pending\n     *   play Promises.\n     */\n\n  }, {\n    key: \"pause\",\n    value: function pause() {\n      if (this.paused) {\n        return;\n      }\n\n      this._audioElement.pause();\n\n      this._audioNode.stop();\n\n      this._audioNode.disconnect(this._gainNode);\n\n      this._audioNode = null;\n\n      this._rejectPlayDeferreds(new Error('The play() request was interrupted by a call to pause().'));\n    }\n    /**\n     * Play the sound. If the buffer hasn't loaded yet, wait for the buffer to load. If\n     *   the source URL is not set yet, this Promise will remain pending until a source\n     *   URL is set.\n     */\n\n  }, {\n    key: \"play\",\n    value: function play() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee() {\n        var _this2 = this;\n\n        var buffer;\n        return _regenerator2.default.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (this.paused) {\n                  _context.next = 6;\n                  break;\n                }\n\n                _context.next = 3;\n                return this._bufferPromise;\n\n              case 3:\n                if (this.paused) {\n                  _context.next = 5;\n                  break;\n                }\n\n                return _context.abrupt(\"return\");\n\n              case 5:\n                throw new Error('The play() request was interrupted by a call to pause().');\n\n              case 6:\n                this._audioNode = this._audioContext.createBufferSource();\n                this._audioNode.loop = this.loop;\n\n                this._audioNode.addEventListener('ended', function () {\n                  if (_this2._audioNode && _this2._audioNode.loop) {\n                    return;\n                  }\n\n                  _this2.dispatchEvent('ended');\n                });\n\n                _context.next = 11;\n                return this._bufferPromise;\n\n              case 11:\n                buffer = _context.sent;\n\n                if (!this.paused) {\n                  _context.next = 14;\n                  break;\n                }\n\n                throw new Error('The play() request was interrupted by a call to pause().');\n\n              case 14:\n                this._audioNode.buffer = buffer;\n\n                this._audioNode.connect(this._gainNode);\n\n                this._audioNode.start();\n\n                if (!this._audioElement.srcObject) {\n                  _context.next = 19;\n                  break;\n                }\n\n                return _context.abrupt(\"return\", this._audioElement.play());\n\n              case 19:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Change which device the sound should play through.\n     * @param sinkId - The sink of the device to play sound through.\n     */\n\n  }, {\n    key: \"setSinkId\",\n    value: function setSinkId(sinkId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee2() {\n        return _regenerator2.default.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this._audioElement.setSinkId !== 'function')) {\n                  _context2.next = 2;\n                  break;\n                }\n\n                throw new Error('This browser does not support setSinkId.');\n\n              case 2:\n                if (!(sinkId === this.sinkId)) {\n                  _context2.next = 4;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 4:\n                if (!(sinkId === 'default')) {\n                  _context2.next = 11;\n                  break;\n                }\n\n                if (!this.paused) {\n                  this._gainNode.disconnect(this._destination);\n                }\n\n                this._audioElement.srcObject = null;\n                this._destination = this._audioContext.destination;\n\n                this._gainNode.connect(this._destination);\n\n                this._sinkId = sinkId;\n                return _context2.abrupt(\"return\");\n\n              case 11:\n                _context2.next = 13;\n                return this._audioElement.setSinkId(sinkId);\n\n              case 13:\n                if (!this._audioElement.srcObject) {\n                  _context2.next = 15;\n                  break;\n                }\n\n                return _context2.abrupt(\"return\");\n\n              case 15:\n                this._gainNode.disconnect(this._audioContext.destination);\n\n                this._destination = this._audioContext.createMediaStreamDestination();\n                this._audioElement.srcObject = this._destination.stream;\n                this._sinkId = sinkId;\n\n                this._gainNode.connect(this._destination);\n\n              case 20:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Create a Deferred for a Promise that will be resolved when .src is set or rejected\n     *   when .pause is called.\n     */\n\n  }, {\n    key: \"_createPlayDeferred\",\n    value: function _createPlayDeferred() {\n      var deferred = new Deferred_1.default();\n\n      this._pendingPlayDeferreds.push(deferred);\n\n      return deferred;\n    }\n    /**\n     * Stop current playback and load a sound file.\n     * @param src - The source URL of the file to load\n     */\n\n  }, {\n    key: \"_load\",\n    value: function _load(src) {\n      var _this3 = this;\n\n      if (this._src && this._src !== src) {\n        this.pause();\n      }\n\n      this._src = src;\n      this._bufferPromise = new Promise(function (resolve, reject) {\n        return __awaiter(_this3, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee3() {\n          var buffer;\n          return _regenerator2.default.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  if (src) {\n                    _context3.next = 2;\n                    break;\n                  }\n\n                  return _context3.abrupt(\"return\", this._createPlayDeferred().promise);\n\n                case 2:\n                  _context3.next = 4;\n                  return bufferSound(this._audioContext, this._XMLHttpRequest, src);\n\n                case 4:\n                  buffer = _context3.sent;\n                  this.dispatchEvent('canplaythrough');\n                  resolve(buffer);\n\n                case 7:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3, this);\n        }));\n      });\n    }\n    /**\n     * Reject all deferreds for the Play promise.\n     * @param reason\n     */\n\n  }, {\n    key: \"_rejectPlayDeferreds\",\n    value: function _rejectPlayDeferreds(reason) {\n      var deferreds = this._pendingPlayDeferreds;\n      deferreds.splice(0, deferreds.length).forEach(function (_ref) {\n        var reject = _ref.reject;\n        return reject(reason);\n      });\n    }\n    /**\n     * Resolve all deferreds for the Play promise.\n     * @param result\n     */\n\n  }, {\n    key: \"_resolvePlayDeferreds\",\n    value: function _resolvePlayDeferreds(result) {\n      var deferreds = this._pendingPlayDeferreds;\n      deferreds.splice(0, deferreds.length).forEach(function (_ref2) {\n        var resolve = _ref2.resolve;\n        return resolve(result);\n      });\n    }\n  }, {\n    key: \"destination\",\n    get: function get() {\n      return this._destination;\n    }\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop;\n    },\n    set: function set(shouldLoop) {\n      // If a sound is already looping, it should continue playing\n      //   the current playthrough and then stop.\n      if (!shouldLoop && this.loop && !this.paused) {\n        var _pauseAfterPlaythrough = function _pauseAfterPlaythrough() {\n          self._audioNode.removeEventListener('ended', _pauseAfterPlaythrough);\n\n          self.pause();\n        };\n\n        var self = this;\n\n        this._audioNode.addEventListener('ended', _pauseAfterPlaythrough);\n      }\n\n      this._loop = shouldLoop;\n    }\n    /**\n     * Whether the audio element is muted.\n     */\n\n  }, {\n    key: \"muted\",\n    get: function get() {\n      return this._gainNode.gain.value === 0;\n    },\n    set: function set(shouldBeMuted) {\n      this._gainNode.gain.value = shouldBeMuted ? 0 : 1;\n    }\n    /**\n     * Whether the sound is paused. this._audioNode only exists when sound is playing;\n     *   otherwise AudioPlayer is considered paused.\n     */\n\n  }, {\n    key: \"paused\",\n    get: function get() {\n      return this._audioNode === null;\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return this._src;\n    },\n    set: function set(src) {\n      this._load(src);\n    }\n    /**\n     * The srcObject of the HTMLMediaElement\n     */\n\n  }, {\n    key: \"srcObject\",\n    get: function get() {\n      return this._audioElement.srcObject;\n    },\n    set: function set(srcObject) {\n      this._audioElement.srcObject = srcObject;\n    }\n  }, {\n    key: \"sinkId\",\n    get: function get() {\n      return this._sinkId;\n    }\n  }]);\n\n  return AudioPlayer;\n}(EventTarget_1.default);\n\nexports.default = AudioPlayer;\n/**\n * Use XMLHttpRequest to load the AudioBuffer of a remote audio asset.\n * @private\n * @param context - The AudioContext to use to decode the audio data\n * @param RequestFactory - The XMLHttpRequest factory to build\n * @param src - The URL of the audio asset to load.\n * @returns A Promise containing the decoded AudioBuffer.\n */\n// tslint:disable-next-line:variable-name\n\nfunction bufferSound(context, RequestFactory, src) {\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regenerator2.default.mark(function _callee4() {\n    var request, event;\n    return _regenerator2.default.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            request = new RequestFactory();\n            request.open('GET', src, true);\n            request.responseType = 'arraybuffer';\n            _context4.next = 5;\n            return new Promise(function (resolve) {\n              request.addEventListener('load', resolve);\n              request.send();\n            });\n\n          case 5:\n            event = _context4.sent;\n            _context4.prev = 6;\n            return _context4.abrupt(\"return\", context.decodeAudioData(event.target.response));\n\n          case 10:\n            _context4.prev = 10;\n            _context4.t0 = _context4[\"catch\"](6);\n            return _context4.abrupt(\"return\", new Promise(function (resolve) {\n              context.decodeAudioData(event.target.response, resolve);\n            }));\n\n          case 13:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this, [[6, 10]]);\n  }));\n} //# sourceMappingURL=AudioPlayer.js.map","map":null,"metadata":{},"sourceType":"script"}