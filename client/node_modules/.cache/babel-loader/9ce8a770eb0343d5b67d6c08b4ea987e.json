{"ast":null,"code":"/* eslint-disable @typescript-eslint/no-explicit-any */\nimport { Parameters } from \"./parameters.js\";\n/**\n * URI.\n * @public\n */\n\nexport class URI extends Parameters {\n  /**\n   * Constructor\n   * @param scheme -\n   * @param user -\n   * @param host -\n   * @param port -\n   * @param parameters -\n   * @param headers -\n   */\n  constructor() {\n    let scheme = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"sip\";\n    let user = arguments.length > 1 ? arguments[1] : undefined;\n    let host = arguments.length > 2 ? arguments[2] : undefined;\n    let port = arguments.length > 3 ? arguments[3] : undefined;\n    let parameters = arguments.length > 4 ? arguments[4] : undefined;\n    let headers = arguments.length > 5 ? arguments[5] : undefined;\n    super(parameters || {});\n    this.headers = {}; // Checks\n\n    if (!host) {\n      throw new TypeError('missing or invalid \"host\" parameter');\n    }\n\n    for (const header in headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (headers.hasOwnProperty(header)) {\n        this.setHeader(header, headers[header]);\n      }\n    } // Raw URI\n\n\n    this.raw = {\n      scheme,\n      user,\n      host,\n      port\n    }; // Normalized URI\n\n    this.normal = {\n      scheme: scheme.toLowerCase(),\n      user,\n      host: host.toLowerCase(),\n      port\n    };\n  }\n\n  get scheme() {\n    return this.normal.scheme;\n  }\n\n  set scheme(value) {\n    this.raw.scheme = value;\n    this.normal.scheme = value.toLowerCase();\n  }\n\n  get user() {\n    return this.normal.user;\n  }\n\n  set user(value) {\n    this.normal.user = this.raw.user = value;\n  }\n\n  get host() {\n    return this.normal.host;\n  }\n\n  set host(value) {\n    this.raw.host = value;\n    this.normal.host = value.toLowerCase();\n  }\n\n  get aor() {\n    return this.normal.user + \"@\" + this.normal.host;\n  }\n\n  get port() {\n    return this.normal.port;\n  }\n\n  set port(value) {\n    this.normal.port = this.raw.port = value === 0 ? value : value;\n  }\n\n  setHeader(name, value) {\n    this.headers[this.headerize(name)] = value instanceof Array ? value : [value];\n  }\n\n  getHeader(name) {\n    if (name) {\n      return this.headers[this.headerize(name)];\n    }\n  }\n\n  hasHeader(name) {\n    // eslint-disable-next-line no-prototype-builtins\n    return !!name && !!this.headers.hasOwnProperty(this.headerize(name));\n  }\n\n  deleteHeader(header) {\n    header = this.headerize(header); // eslint-disable-next-line no-prototype-builtins\n\n    if (this.headers.hasOwnProperty(header)) {\n      const value = this.headers[header];\n      delete this.headers[header];\n      return value;\n    }\n  }\n\n  clearHeaders() {\n    this.headers = {};\n  }\n\n  clone() {\n    return new URI(this._raw.scheme, this._raw.user || \"\", this._raw.host, this._raw.port, JSON.parse(JSON.stringify(this.parameters)), JSON.parse(JSON.stringify(this.headers)));\n  }\n\n  toRaw() {\n    return this._toString(this._raw);\n  }\n\n  toString() {\n    return this._toString(this._normal);\n  }\n\n  get _normal() {\n    return this.normal;\n  }\n\n  get _raw() {\n    return this.raw;\n  }\n\n  _toString(uri) {\n    let uriString = uri.scheme + \":\"; // add slashes if it's not a sip(s) URI\n\n    if (!uri.scheme.toLowerCase().match(\"^sips?$\")) {\n      uriString += \"//\";\n    }\n\n    if (uri.user) {\n      uriString += this.escapeUser(uri.user) + \"@\";\n    }\n\n    uriString += uri.host;\n\n    if (uri.port || uri.port === 0) {\n      uriString += \":\" + uri.port;\n    }\n\n    for (const parameter in this.parameters) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.parameters.hasOwnProperty(parameter)) {\n        uriString += \";\" + parameter;\n\n        if (this.parameters[parameter] !== null) {\n          uriString += \"=\" + this.parameters[parameter];\n        }\n      }\n    }\n\n    const headers = [];\n\n    for (const header in this.headers) {\n      // eslint-disable-next-line no-prototype-builtins\n      if (this.headers.hasOwnProperty(header)) {\n        // eslint-disable-next-line @typescript-eslint/no-for-in-array\n        for (const idx in this.headers[header]) {\n          // eslint-disable-next-line no-prototype-builtins\n          if (this.headers[header].hasOwnProperty(idx)) {\n            headers.push(header + \"=\" + this.headers[header][idx]);\n          }\n        }\n      }\n    }\n\n    if (headers.length > 0) {\n      uriString += \"?\" + headers.join(\"&\");\n    }\n\n    return uriString;\n  }\n  /*\n   * Hex-escape a SIP URI user.\n   * @private\n   * @param {String} user\n   */\n\n\n  escapeUser(user) {\n    let decodedUser; // FIXME: This is called by toString above which should never throw, but\n    // decodeURIComponent can throw and I've seen one case in production where\n    // it did throw resulting in a cascading failure. This class should be\n    // fixed so that decodeURIComponent is not called at this point (in toString).\n    // The user should be decoded when the URI is constructor or some other\n    // place where we can catch the error before the URI is created or somesuch.\n    // eslint-disable-next-line no-useless-catch\n\n    try {\n      decodedUser = decodeURIComponent(user);\n    } catch (error) {\n      throw error;\n    } // Don't hex-escape ':' (%3A), '+' (%2B), '?' (%3F\"), '/' (%2F).\n\n\n    return encodeURIComponent(decodedUser).replace(/%3A/ig, \":\").replace(/%2B/ig, \"+\").replace(/%3F/ig, \"?\").replace(/%2F/ig, \"/\");\n  }\n\n  headerize(str) {\n    const exceptions = {\n      \"Call-Id\": \"Call-ID\",\n      \"Cseq\": \"CSeq\",\n      \"Min-Se\": \"Min-SE\",\n      \"Rack\": \"RAck\",\n      \"Rseq\": \"RSeq\",\n      \"Www-Authenticate\": \"WWW-Authenticate\"\n    };\n    const name = str.toLowerCase().replace(/_/g, \"-\").split(\"-\");\n    const parts = name.length;\n    let hname = \"\";\n\n    for (let part = 0; part < parts; part++) {\n      if (part !== 0) {\n        hname += \"-\";\n      }\n\n      hname += name[part].charAt(0).toUpperCase() + name[part].substring(1);\n    }\n\n    if (exceptions[hname]) {\n      hname = exceptions[hname];\n    }\n\n    return hname;\n  }\n\n}\n/**\n * Returns true if URIs are equivalent per RFC 3261 Section 19.1.4.\n * @param a - URI to compare\n * @param b - URI to compare\n *\n * @remarks\n * 19.1.4 URI Comparison\n * Some operations in this specification require determining whether two\n * SIP or SIPS URIs are equivalent.\n *\n * https://tools.ietf.org/html/rfc3261#section-19.1.4\n * @internal\n */\n\nexport function equivalentURI(a, b) {\n  // o  A SIP and SIPS URI are never equivalent.\n  if (a.scheme !== b.scheme) {\n    return false;\n  } // o  Comparison of the userinfo of SIP and SIPS URIs is case-\n  //    sensitive.  This includes userinfo containing passwords or\n  //    formatted as telephone-subscribers.  Comparison of all other\n  //    components of the URI is case-insensitive unless explicitly\n  //    defined otherwise.\n  //\n  // o  The ordering of parameters and header fields is not significant\n  //    in comparing SIP and SIPS URIs.\n  //\n  // o  Characters other than those in the \"reserved\" set (see RFC 2396\n  //    [5]) are equivalent to their \"\"%\" HEX HEX\" encoding.\n  //\n  // o  An IP address that is the result of a DNS lookup of a host name\n  //    does not match that host name.\n  //\n  // o  For two URIs to be equal, the user, password, host, and port\n  //    components must match.\n  //\n  // A URI omitting the user component will not match a URI that\n  // includes one.  A URI omitting the password component will not\n  // match a URI that includes one.\n  //\n  // A URI omitting any component with a default value will not\n  // match a URI explicitly containing that component with its\n  // default value.  For instance, a URI omitting the optional port\n  // component will not match a URI explicitly declaring port 5060.\n  // The same is true for the transport-parameter, ttl-parameter,\n  // user-parameter, and method components.\n  //\n  // Defining sip:user@host to not be equivalent to\n  // sip:user@host:5060 is a change from RFC 2543.  When deriving\n  // addresses from URIs, equivalent addresses are expected from\n  // equivalent URIs.  The URI sip:user@host:5060 will always\n  // resolve to port 5060.  The URI sip:user@host may resolve to\n  // other ports through the DNS SRV mechanisms detailed in [4].\n  // FIXME: TODO:\n  // - character compared to hex encoding is not handled\n  // - password does not exist on URI currently\n\n\n  if (a.user !== b.user || a.host !== b.host || a.port !== b.port) {\n    return false;\n  } // o  URI uri-parameter components are compared as follows:\n\n\n  function compareParameters(a, b) {\n    //  -  Any uri-parameter appearing in both URIs must match.\n    const parameterKeysA = Object.keys(a.parameters);\n    const parameterKeysB = Object.keys(b.parameters);\n    const intersection = parameterKeysA.filter(x => parameterKeysB.includes(x));\n\n    if (!intersection.every(key => a.parameters[key] === b.parameters[key])) {\n      return false;\n    } //  -  A user, ttl, or method uri-parameter appearing in only one\n    //     URI never matches, even if it contains the default value.\n\n\n    if (![\"user\", \"ttl\", \"method\", \"transport\"].every(key => a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key))) {\n      return false;\n    } //  -  A URI that includes an maddr parameter will not match a URI\n    //     that contains no maddr parameter.\n\n\n    if (![\"maddr\"].every(key => a.hasParam(key) && b.hasParam(key) || !a.hasParam(key) && !b.hasParam(key))) {\n      return false;\n    } //  -  All other uri-parameters appearing in only one URI are\n    //     ignored when comparing the URIs.\n\n\n    return true;\n  }\n\n  if (!compareParameters(a, b)) {\n    return false;\n  } // o  URI header components are never ignored.  Any present header\n  //    component MUST be present in both URIs and match for the URIs\n  //    to match.  The matching rules are defined for each header field\n  //    in Section 20.\n\n\n  const headerKeysA = Object.keys(a.headers);\n  const headerKeysB = Object.keys(b.headers); // No need to check if no headers\n\n  if (headerKeysA.length !== 0 || headerKeysB.length !== 0) {\n    // Must have same number of headers\n    if (headerKeysA.length !== headerKeysB.length) {\n      return false;\n    } // Must have same headers\n\n\n    const intersection = headerKeysA.filter(x => headerKeysB.includes(x));\n\n    if (intersection.length !== headerKeysB.length) {\n      return false;\n    } // FIXME: Not to spec. But perhaps not worth fixing?\n    // Must have same header values\n    // It seems too much to consider multiple headers with same name.\n    // It seems too much to compare two header params according to the rule of each header.\n    // We'll assume a single header and compare them string to string...\n\n\n    if (!intersection.every(key => a.headers[key].length && b.headers[key].length && a.headers[key][0] === b.headers[key][0])) {\n      return false;\n    }\n  }\n\n  return true;\n}","map":null,"metadata":{},"sourceType":"module"}