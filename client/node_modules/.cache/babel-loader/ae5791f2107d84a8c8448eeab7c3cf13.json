{"ast":null,"code":"import { Timers } from \"../timers.js\";\nimport { ClientTransaction } from \"./client-transaction.js\";\nimport { TransactionState } from \"./transaction-state.js\";\n/**\n * INVITE Client Transaction.\n * @remarks\n * The INVITE transaction consists of a three-way handshake.  The client\n * transaction sends an INVITE, the server transaction sends responses,\n * and the client transaction sends an ACK.\n * https://tools.ietf.org/html/rfc3261#section-17.1.1\n * @public\n */\n\nexport class InviteClientTransaction extends ClientTransaction {\n  /**\n   * Constructor.\n   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n   * Then `toString` is called on the outgoing request and the message is sent via the transport.\n   * After construction the transaction will be in the \"calling\" state and the transaction id\n   * will equal the branch parameter set in the Via header of the outgoing request.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1\n   * @param request - The outgoing INVITE request.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Calling, \"sip.transaction.ict\");\n    /**\n     * Map of 2xx to-tag to ACK.\n     * If value is not undefined, value is the ACK which was sent.\n     * If key exists but value is undefined, a 2xx was received but the ACK not yet sent.\n     * Otherwise, a 2xx was not (yet) received for this transaction.\n     */\n\n    this.ackRetransmissionCache = new Map(); // FIXME: Timer A for unreliable transport not implemented\n    //\n    // If an unreliable transport is being used, the client transaction\n    // MUST start timer A with a value of T1. If a reliable transport is being used,\n    // the client transaction SHOULD NOT start timer A (Timer A controls request retransmissions).\n    // For any transport, the client transaction MUST start timer B with a value\n    // of 64*T1 seconds (Timer B controls transaction timeouts).\n    // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n    //\n    // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n    // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n    // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n    this.B = setTimeout(() => this.timerB(), Timers.TIMER_B);\n    this.send(request.toString()).catch(error => {\n      this.logTransportError(error, \"Failed to send initial outgoing request.\");\n    });\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    if (this.B) {\n      clearTimeout(this.B);\n      this.B = undefined;\n    }\n\n    if (this.D) {\n      clearTimeout(this.D);\n      this.D = undefined;\n    }\n\n    if (this.M) {\n      clearTimeout(this.M);\n      this.M = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"ict\";\n  }\n  /**\n   * ACK a 2xx final response.\n   *\n   * The transaction includes the ACK only if the final response was not a 2xx response (the\n   * transaction will generate and send the ACK to the transport automagically). If the\n   * final response was a 2xx, the ACK is not considered part of the transaction (the\n   * transaction user needs to generate and send the ACK).\n   *\n   * This library is not strictly RFC compliant with regard to ACK handling for 2xx final\n   * responses. Specifically, retransmissions of ACKs to a 2xx final responses is handled\n   * by the transaction layer (instead of the UAC core). The \"standard\" approach is for\n   * the UAC core to receive all 2xx responses and manage sending ACK retransmissions to\n   * the transport directly. Herein the transaction layer manages sending ACKs to 2xx responses\n   * and any retransmissions of those ACKs as needed.\n   *\n   * @param ack - The outgoing ACK request.\n   */\n\n\n  ackResponse(ack) {\n    const toTag = ack.toTag;\n\n    if (!toTag) {\n      throw new Error(\"To tag undefined.\");\n    }\n\n    const id = \"z9hG4bK\" + Math.floor(Math.random() * 10000000);\n    ack.setViaHeader(id, this.transport.protocol);\n    this.ackRetransmissionCache.set(toTag, ack); // Add to ACK retransmission cache\n\n    this.send(ack.toString()).catch(error => {\n      this.logTransportError(error, \"Failed to send ACK to 2xx response.\");\n    });\n  }\n  /**\n   * Handler for incoming responses from the transport which match this transaction.\n   * @param response - The incoming response.\n   */\n\n\n  receiveResponse(response) {\n    const statusCode = response.statusCode;\n\n    if (!statusCode || statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    switch (this.state) {\n      case TransactionState.Calling:\n        // If the client transaction receives a provisional response while in\n        // the \"Calling\" state, it transitions to the \"Proceeding\" state. In the\n        // \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n        // request any longer. Furthermore, the provisional response MUST be\n        // passed to the TU.  Any further provisional responses MUST be passed\n        // up to the TU while in the \"Proceeding\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          this.stateTransition(TransactionState.Proceeding);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When a 2xx response is received while in either the \"Calling\" or\n        // \"Proceeding\" states, the client transaction MUST transition to\n        // the \"Accepted\" state... The 2xx response MUST be passed up to the TU.\n        // The client transaction MUST NOT generate an ACK to the 2xx response -- its\n        // handling is delegated to the TU. A UAC core will send an ACK to\n        // the 2xx response using a new transaction.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n          this.stateTransition(TransactionState.Accepted);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n        // a response with status code from 300-699 MUST cause the client\n        // transaction to transition to \"Completed\". The client transaction\n        // MUST pass the received response up to the TU, and the client\n        // transaction MUST generate an ACK request, even if the transport is\n        // reliable (guidelines for constructing the ACK from the response\n        // are given in Section 17.1.1.3), and then pass the ACK to the\n        // transport layer for transmission. The ACK MUST be sent to the\n        // same address, port, and transport to which the original request was sent.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.ack(response);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Proceeding:\n        // In the \"Proceeding\" state, the client transaction SHOULD NOT retransmit the\n        // request any longer. Furthermore, the provisional response MUST be\n        // passed to the TU.  Any further provisional responses MUST be passed\n        // up to the TU while in the \"Proceeding\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When a 2xx response is received while in either the \"Calling\" or \"Proceeding\" states,\n        // the client transaction MUST transition to the \"Accepted\" state...\n        // The 2xx response MUST be passed up to the TU. The client\n        // transaction MUST NOT generate an ACK to the 2xx response -- its\n        // handling is delegated to the TU. A UAC core will send an ACK to\n        // the 2xx response using a new transaction.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 200 && statusCode <= 299) {\n          this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n          this.stateTransition(TransactionState.Accepted);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // When in either the \"Calling\" or \"Proceeding\" states, reception of\n        // a response with status code from 300-699 MUST cause the client\n        // transaction to transition to \"Completed\". The client transaction\n        // MUST pass the received response up to the TU, and the client\n        // transaction MUST generate an ACK request, even if the transport is\n        // reliable (guidelines for constructing the ACK from the response\n        // are given in Section 17.1.1.3), and then pass the ACK to the\n        // transport layer for transmission. The ACK MUST be sent to the\n        // same address, port, and transport to which the original request was sent.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n          this.ack(response);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n        // The purpose of the \"Accepted\" state is to allow the client\n        // transaction to continue to exist to receive, and pass to the TU,\n        // any retransmissions of the 2xx response and any additional 2xx\n        // responses from other branches of the INVITE if it forked\n        // downstream. Timer M reflects the amount of time that the\n        // transaction user will wait for such messages.\n        //\n        // Any 2xx responses that match this client transaction and that are\n        // received while in the \"Accepted\" state MUST be passed up to the\n        // TU. The client transaction MUST NOT generate an ACK to the 2xx\n        // response. The client transaction takes no further action.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (statusCode >= 200 && statusCode <= 299) {\n          // NOTE: This implementation herein is intentionally not RFC compliant.\n          // While the first 2xx response for a given branch is passed up to the TU,\n          // retransmissions of 2xx responses are absorbed and the ACK associated\n          // with the original response is resent. This approach is taken because\n          // our current transaction users are not currently in a good position to\n          // deal with 2xx retransmission. This SHOULD NOT cause any compliance issues - ;)\n          //\n          // If we don't have a cache hit, pass the response to the TU.\n          if (!this.ackRetransmissionCache.has(response.toTag)) {\n            this.ackRetransmissionCache.set(response.toTag, undefined); // Prime the ACK cache\n\n            if (this.user.receiveResponse) {\n              this.user.receiveResponse(response);\n            }\n\n            return;\n          } // If we have a cache hit, try pulling the ACK from cache and retransmitting it.\n\n\n          const ack = this.ackRetransmissionCache.get(response.toTag);\n\n          if (ack) {\n            this.send(ack.toString()).catch(error => {\n              this.logTransportError(error, \"Failed to send retransmission of ACK to 2xx response.\");\n            });\n            return;\n          } // If an ACK was not found in cache then we have received a retransmitted 2xx\n          // response before the TU responded to the original response (we don't have an ACK yet).\n          // So discard this response under the assumption that the TU will eventually\n          // get us a ACK for the original response.\n\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // Any retransmissions of a response with status code 300-699 that\n        // are received while in the \"Completed\" state MUST cause the ACK to\n        // be re-passed to the transport layer for retransmission, but the\n        // newly received response MUST NOT be passed up to the TU.\n        // https://tools.ietf.org/html/rfc6026#section-8.4\n        if (statusCode >= 300 && statusCode <= 699) {\n          this.ack(response);\n          return;\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        break;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    } // Any response received that does not match an existing client\n    // transaction state machine is simply dropped. (Implementations are,\n    // of course, free to log or do other implementation-specific things\n    // with such responses, but the implementer should be sure to consider\n    // the impact of large numbers of malicious stray responses.)\n    // https://tools.ietf.org/html/rfc6026#section-7.2\n\n\n    const message = `Received unexpected ${statusCode} response while in state ${this.state}.`;\n    this.logger.warn(message);\n    return;\n  }\n  /**\n   * The client transaction SHOULD inform the TU that a transport failure\n   * has occurred, and the client transaction SHOULD transition directly\n   * to the \"Terminated\" state.  The TU will handle the failover\n   * mechanisms described in [4].\n   * https://tools.ietf.org/html/rfc3261#section-17.1.4\n   * @param error - The error.\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n\n    this.stateTransition(TransactionState.Terminated, true);\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"INVITE client transaction\";\n  }\n\n  ack(response) {\n    // The ACK request constructed by the client transaction MUST contain\n    // values for the Call-ID, From, and Request-URI that are equal to the\n    // values of those header fields in the request passed to the transport\n    // by the client transaction (call this the \"original request\"). The To\n    // header field in the ACK MUST equal the To header field in the\n    // response being acknowledged, and therefore will usually differ from\n    // the To header field in the original request by the addition of the\n    // tag parameter. The ACK MUST contain a single Via header field, and\n    // this MUST be equal to the top Via header field of the original\n    // request. The CSeq header field in the ACK MUST contain the same\n    // value for the sequence number as was present in the original request,\n    // but the method parameter MUST be equal to \"ACK\".\n    //\n    // If the INVITE request whose response is being acknowledged had Route\n    // header fields, those header fields MUST appear in the ACK. This is\n    // to ensure that the ACK can be routed properly through any downstream\n    // stateless proxies.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.1.3\n    const ruri = this.request.ruri;\n    const callId = this.request.callId;\n    const cseq = this.request.cseq;\n    const from = this.request.getHeader(\"from\");\n    const to = response.getHeader(\"to\");\n    const via = this.request.getHeader(\"via\");\n    const route = this.request.getHeader(\"route\");\n\n    if (!from) {\n      throw new Error(\"From undefined.\");\n    }\n\n    if (!to) {\n      throw new Error(\"To undefined.\");\n    }\n\n    if (!via) {\n      throw new Error(\"Via undefined.\");\n    }\n\n    let ack = `ACK ${ruri} SIP/2.0\\r\\n`;\n\n    if (route) {\n      ack += `Route: ${route}\\r\\n`;\n    }\n\n    ack += `Via: ${via}\\r\\n`;\n    ack += `To: ${to}\\r\\n`;\n    ack += `From: ${from}\\r\\n`;\n    ack += `Call-ID: ${callId}\\r\\n`;\n    ack += `CSeq: ${cseq} ACK\\r\\n`;\n    ack += `Max-Forwards: 70\\r\\n`;\n    ack += `Content-Length: 0\\r\\n\\r\\n`; // TOOO: \"User-Agent\" header\n\n    this.send(ack).catch(error => {\n      this.logTransportError(error, \"Failed to send ACK to non-2xx response.\");\n    });\n    return;\n  }\n  /**\n   * Execute a state transition.\n   * @param newState - New state.\n   */\n\n\n  stateTransition(newState) {\n    let dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Calling:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Proceeding:\n        if (this.state !== TransactionState.Calling) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Accepted:\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Calling && this.state !== TransactionState.Accepted && this.state !== TransactionState.Completed) {\n          if (!dueToTransportError) {\n            invalidStateTransition();\n          }\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // While not spelled out in the RFC, Timer B is the maximum amount of time that a sender\n    // will wait for an INVITE message to be acknowledged (a SIP response message is received).\n    // So Timer B should be cleared when the transaction state proceeds from \"Calling\".\n\n\n    if (this.B) {\n      clearTimeout(this.B);\n      this.B = undefined;\n    }\n\n    if (newState === TransactionState.Proceeding) {// Timers have no effect on \"Proceeding\" state.\n      // In the \"Proceeding\" state, the client transaction\n      // SHOULD NOT retransmit the request any longer.\n      // https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n    } // The client transaction MUST start Timer D when it enters the \"Completed\" state\n    // for any reason, with a value of at least 32 seconds for unreliable transports,\n    // and a value of zero seconds for reliable transports.\n    // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n    if (newState === TransactionState.Completed) {\n      this.D = setTimeout(() => this.timerD(), Timers.TIMER_D);\n    } // The client transaction MUST transition to the \"Accepted\" state,\n    // and Timer M MUST be started with a value of 64*T1.\n    // https://tools.ietf.org/html/rfc6026#section-8.4\n\n\n    if (newState === TransactionState.Accepted) {\n      this.M = setTimeout(() => this.timerM(), Timers.TIMER_M);\n    } // Once the transaction is in the \"Terminated\" state, it MUST be destroyed immediately.\n    // https://tools.ietf.org/html/rfc6026#section-8.7\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    } // Update state.\n\n\n    this.setState(newState);\n  }\n  /**\n   * When timer A fires, the client transaction MUST retransmit the\n   * request by passing it to the transport layer, and MUST reset the\n   * timer with a value of 2*T1.\n   * When timer A fires 2*T1 seconds later, the request MUST be\n   * retransmitted again (assuming the client transaction is still in this\n   * state). This process MUST continue so that the request is\n   * retransmitted with intervals that double after each transmission.\n   * These retransmissions SHOULD only be done while the client\n   * transaction is in the \"Calling\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n   */\n\n\n  timerA() {// TODO\n  }\n  /**\n   * If the client transaction is still in the \"Calling\" state when timer\n   * B fires, the client transaction SHOULD inform the TU that a timeout\n   * has occurred.  The client transaction MUST NOT generate an ACK.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.1.2\n   */\n\n\n  timerB() {\n    this.logger.debug(`Timer B expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Calling) {\n      this.onRequestTimeout();\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * If Timer D fires while the client transaction is in the \"Completed\" state,\n   * the client transaction MUST move to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc6026#section-8.4\n   */\n\n\n  timerD() {\n    this.logger.debug(`Timer D expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Completed) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * If Timer M fires while the client transaction is in the \"Accepted\"\n   * state, the client transaction MUST move to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc6026#section-8.4\n   */\n\n\n  timerM() {\n    this.logger.debug(`Timer M expired for INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Accepted) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}