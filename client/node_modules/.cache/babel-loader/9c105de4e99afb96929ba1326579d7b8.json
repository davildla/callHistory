{"ast":null,"code":"import { Grammar } from \"../grammar/grammar.js\";\nimport { URI } from \"../grammar/uri.js\";\nimport { fromBodyLegacy, getBody } from \"../core/messages/body.js\";\nimport { SessionState as SessionDialogState, SignalingState } from \"../core/session/session.js\";\nimport { getReasonPhrase } from \"../core/messages/utils.js\";\nimport { AllowedMethods } from \"../core/user-agent-core/allowed-methods.js\";\nimport { Ack } from \"./ack.js\";\nimport { Bye } from \"./bye.js\";\nimport { EmitterImpl } from \"./emitter.js\";\nimport { ContentTypeUnsupportedError } from \"./exceptions/content-type-unsupported.js\";\nimport { RequestPendingError } from \"./exceptions/request-pending.js\";\nimport { Info } from \"./info.js\";\nimport { Message } from \"./message.js\";\nimport { Notification } from \"./notification.js\";\nimport { Referral } from \"./referral.js\";\nimport { SessionState } from \"./session-state.js\";\n/**\n * A session provides real time communication between one or more participants.\n *\n * @remarks\n * The transport behaves in a deterministic manner according to the\n * the state defined in {@link SessionState}.\n * @public\n */\n\nexport class Session {\n  /**\n   * Constructor.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @internal\n   */\n  constructor(userAgent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    /** True if there is an outgoing re-INVITE request outstanding. */\n    this.pendingReinvite = false;\n    /** True if there is an incoming re-INVITE ACK request outstanding. */\n\n    this.pendingReinviteAck = false;\n    /** Session state. */\n\n    this._state = SessionState.Initial;\n    this.delegate = options.delegate;\n    this._stateEventEmitter = new EmitterImpl();\n    this._userAgent = userAgent;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    this.logger.log(`Session ${this.id} in state ${this._state} is being disposed`); // Remove from the user agent's session collection\n\n    delete this.userAgent._sessions[this.id]; // Dispose of dialog media\n\n    if (this._sessionDescriptionHandler) {\n      this._sessionDescriptionHandler.close(); // TODO: The SDH needs to remain defined as it will be called after it is closed in cases\n      // where an answer/offer arrives while the session is being torn down. There are a variety\n      // of circumstances where this can happen - sending a BYE during a re-INVITE for example.\n      // The code is currently written such that it lazily makes a new SDH when it needs one\n      // and one is not yet defined. Thus if we undefined it here, it will currently make a\n      // new one which is out of sync and then never gets cleaned up.\n      //\n      // The downside of leaving it defined are that calls this closed SDH will continue to be\n      // made (think setDescription) and those should/will fail. These failures are handled, but\n      // it would be nice to have it all coded up in a way where having an undefined SDH where\n      // one is expected throws an error.\n      //\n      // this._sessionDescriptionHandler = undefined;\n\n    }\n\n    switch (this.state) {\n      case SessionState.Initial:\n        break;\n      // the Inviter/Invitation sub class dispose method handles this case\n\n      case SessionState.Establishing:\n        break;\n      // the Inviter/Invitation sub class dispose method handles this case\n\n      case SessionState.Established:\n        return new Promise(resolve => {\n          this._bye({\n            // wait for the response to the BYE before resolving\n            onAccept: () => resolve(),\n            onRedirect: () => resolve(),\n            onReject: () => resolve()\n          });\n        });\n\n      case SessionState.Terminating:\n        break;\n      // nothing to be done\n\n      case SessionState.Terminated:\n        break;\n      // nothing to be done\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n\n    return Promise.resolve();\n  }\n  /**\n   * The asserted identity of the remote user.\n   */\n\n\n  get assertedIdentity() {\n    return this._assertedIdentity;\n  }\n  /**\n   * The confirmed session dialog.\n   */\n\n\n  get dialog() {\n    return this._dialog;\n  }\n  /**\n   * A unique identifier for this session.\n   */\n\n\n  get id() {\n    return this._id;\n  }\n  /**\n   * The session being replace by this one.\n   */\n\n\n  get replacee() {\n    return this._replacee;\n  }\n  /**\n   * Session description handler.\n   * @remarks\n   * If `this` is an instance of `Invitation`,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n   * If `this` is an instance of `Inviter` and an offer was sent in the INVITE,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"establishing\".\n   * If `this` is an instance of `Inviter` and an offer was not sent in the INVITE,\n   * `sessionDescriptionHandler` will be defined when the session state changes to \"established\".\n   * Otherwise `undefined`.\n   */\n\n\n  get sessionDescriptionHandler() {\n    return this._sessionDescriptionHandler;\n  }\n  /**\n   * Session description handler factory.\n   */\n\n\n  get sessionDescriptionHandlerFactory() {\n    return this.userAgent.configuration.sessionDescriptionHandlerFactory;\n  }\n  /**\n   * SDH modifiers for the initial INVITE transaction.\n   * @remarks\n   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n   */\n\n\n  get sessionDescriptionHandlerModifiers() {\n    return this._sessionDescriptionHandlerModifiers || [];\n  }\n\n  set sessionDescriptionHandlerModifiers(modifiers) {\n    this._sessionDescriptionHandlerModifiers = modifiers.slice();\n  }\n  /**\n   * SDH options for the initial INVITE transaction.\n   * @remarks\n   * Used in all cases when handling the initial INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Inviter.invite() or Invitation.accept().\n   */\n\n\n  get sessionDescriptionHandlerOptions() {\n    return this._sessionDescriptionHandlerOptions || {};\n  }\n\n  set sessionDescriptionHandlerOptions(options) {\n    this._sessionDescriptionHandlerOptions = Object.assign({}, options);\n  }\n  /**\n   * SDH modifiers for re-INVITE transactions.\n   * @remarks\n   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Session.invite().\n   */\n\n\n  get sessionDescriptionHandlerModifiersReInvite() {\n    return this._sessionDescriptionHandlerModifiersReInvite || [];\n  }\n\n  set sessionDescriptionHandlerModifiersReInvite(modifiers) {\n    this._sessionDescriptionHandlerModifiersReInvite = modifiers.slice();\n  }\n  /**\n   * SDH options for re-INVITE transactions.\n   * @remarks\n   * Used in all cases when handling a re-INVITE transaction as either UAC or UAS.\n   * May be set directly at anytime.\n   * May optionally be set via constructor option.\n   * May optionally be set via options passed to Session.invite().\n   */\n\n\n  get sessionDescriptionHandlerOptionsReInvite() {\n    return this._sessionDescriptionHandlerOptionsReInvite || {};\n  }\n\n  set sessionDescriptionHandlerOptionsReInvite(options) {\n    this._sessionDescriptionHandlerOptionsReInvite = Object.assign({}, options);\n  }\n  /**\n   * Session state.\n   */\n\n\n  get state() {\n    return this._state;\n  }\n  /**\n   * Session state change emitter.\n   */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /**\n   * The user agent.\n   */\n\n\n  get userAgent() {\n    return this._userAgent;\n  }\n  /**\n   * End the {@link Session}. Sends a BYE.\n   * @param options - Options bucket. See {@link SessionByeOptions} for details.\n   */\n\n\n  bye() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let message = \"Session.bye() may only be called if established session.\";\n\n    switch (this.state) {\n      case SessionState.Initial:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof this.cancel === \"function\") {\n          message += \" However Inviter.invite() has not yet been called.\";\n          message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" However Invitation.accept() has not yet been called.\";\n          message += \" Perhaps you should have called Invitation.reject()?\";\n        }\n\n        break;\n\n      case SessionState.Establishing:\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        if (typeof this.cancel === \"function\") {\n          message += \" However a dialog does not yet exist.\";\n          message += \" Perhaps you should have called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" However Invitation.accept() has not yet been called (or not yet resolved).\";\n          message += \" Perhaps you should have called Invitation.reject()?\";\n        }\n\n        break;\n\n      case SessionState.Established:\n        {\n          const requestDelegate = options.requestDelegate;\n          const requestOptions = this.copyRequestOptions(options.requestOptions);\n          return this._bye(requestDelegate, requestOptions);\n        }\n\n      case SessionState.Terminating:\n        message += \" However this session is already terminating.\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        if (typeof this.cancel === \"function\") {\n          message += \" Perhaps you have already called Inviter.cancel()?\"; // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        } else if (typeof this.reject === \"function\") {\n          message += \" Perhaps you have already called Session.bye()?\";\n        }\n\n        break;\n\n      case SessionState.Terminated:\n        message += \" However this session is already terminated.\";\n        break;\n\n      default:\n        throw new Error(\"Unknown state\");\n    }\n\n    this.logger.error(message);\n    return Promise.reject(new Error(`Invalid session state ${this.state}`));\n  }\n  /**\n   * Share {@link Info} with peer. Sends an INFO.\n   * @param options - Options bucket. See {@link SessionInfoOptions} for details.\n   */\n\n\n  info() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.info() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    return this._info(requestDelegate, requestOptions);\n  }\n  /**\n   * Renegotiate the session. Sends a re-INVITE.\n   * @param options - Options bucket. See {@link SessionInviteOptions} for details.\n   */\n\n\n  invite() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Session.invite\");\n\n    if (this.state !== SessionState.Established) {\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    if (this.pendingReinvite) {\n      return Promise.reject(new RequestPendingError(\"Reinvite in progress. Please wait until complete, then try again.\"));\n    }\n\n    this.pendingReinvite = true; // Modifiers and options for initial INVITE transaction\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiersReInvite = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptionsReInvite = options.sessionDescriptionHandlerOptions;\n    }\n\n    const delegate = {\n      onAccept: response => {\n        // A re-INVITE transaction has an offer/answer [RFC3264] exchange\n        // associated with it.  The UAC (User Agent Client) generating a given\n        // re-INVITE can act as the offerer or as the answerer.  A UAC willing\n        // to act as the offerer includes an offer in the re-INVITE.  The UAS\n        // (User Agent Server) then provides an answer in a response to the\n        // re-INVITE.  A UAC willing to act as answerer does not include an\n        // offer in the re-INVITE.  The UAS then provides an offer in a response\n        // to the re-INVITE becoming, thus, the offerer.\n        // https://tools.ietf.org/html/rfc6141#section-1\n        const body = getBody(response.message);\n\n        if (!body) {\n          // No way to recover, so terminate session and mark as failed.\n          this.logger.error(\"Received 2xx response to re-INVITE without a session description\");\n          this.ackAndBye(response, 400, \"Missing session description\");\n          this.stateTransition(SessionState.Terminated);\n          this.pendingReinvite = false;\n          return;\n        }\n\n        if (options.withoutSdp) {\n          // INVITE without SDP - set remote offer and send an answer in the ACK\n          const answerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n          };\n          this.setOfferAndGetAnswer(body, answerOptions).then(answerBody => {\n            response.ack({\n              body: answerBody\n            });\n          }).catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to handle offer in 2xx response to re-INVITE\");\n            this.logger.error(error.message);\n\n            if (this.state === SessionState.Terminated) {\n              // A BYE should not be sent if already terminated.\n              // For example, a BYE may be sent/received while re-INVITE is outstanding.\n              response.ack();\n            } else {\n              this.ackAndBye(response, 488, \"Bad Media Description\");\n              this.stateTransition(SessionState.Terminated);\n            }\n          }).then(() => {\n            this.pendingReinvite = false;\n\n            if (options.requestDelegate && options.requestDelegate.onAccept) {\n              options.requestDelegate.onAccept(response);\n            }\n          });\n        } else {\n          // INVITE with SDP - set remote answer and send an ACK\n          const answerOptions = {\n            sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n            sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n          };\n          this.setAnswer(body, answerOptions).then(() => {\n            response.ack();\n          }).catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to handle answer in 2xx response to re-INVITE\");\n            this.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n            // The ACK needs to be sent regardless as it was not handled by the transaction.\n\n            if (this.state !== SessionState.Terminated) {\n              this.ackAndBye(response, 488, \"Bad Media Description\");\n              this.stateTransition(SessionState.Terminated);\n            } else {\n              response.ack();\n            }\n          }).then(() => {\n            this.pendingReinvite = false;\n\n            if (options.requestDelegate && options.requestDelegate.onAccept) {\n              options.requestDelegate.onAccept(response);\n            }\n          });\n        }\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onProgress: response => {\n        return;\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onRedirect: response => {\n        return;\n      },\n      onReject: response => {\n        this.logger.warn(\"Received a non-2xx response to re-INVITE\");\n        this.pendingReinvite = false;\n\n        if (options.withoutSdp) {\n          if (options.requestDelegate && options.requestDelegate.onReject) {\n            options.requestDelegate.onReject(response);\n          }\n        } else {\n          this.rollbackOffer().catch(error => {\n            // No way to recover, so terminate session and mark as failed.\n            this.logger.error(\"Failed to rollback offer on non-2xx response to re-INVITE\");\n            this.logger.error(error.message); // A BYE should only be sent if session is not already terminated.\n            // For example, a BYE may be sent/received while re-INVITE is outstanding.\n            // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n            if (this.state !== SessionState.Terminated) {\n              if (!this.dialog) {\n                throw new Error(\"Dialog undefined.\");\n              }\n\n              const extraHeaders = [];\n              extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n              this.dialog.bye(undefined, {\n                extraHeaders\n              });\n              this.stateTransition(SessionState.Terminated);\n            }\n          }).then(() => {\n            if (options.requestDelegate && options.requestDelegate.onReject) {\n              options.requestDelegate.onReject(response);\n            }\n          });\n        }\n      },\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      onTrying: response => {\n        return;\n      }\n    };\n    const requestOptions = options.requestOptions || {};\n    requestOptions.extraHeaders = (requestOptions.extraHeaders || []).slice();\n    requestOptions.extraHeaders.push(\"Allow: \" + AllowedMethods.toString());\n    requestOptions.extraHeaders.push(\"Contact: \" + this._contact); // Just send an INVITE with no sdp...\n\n    if (options.withoutSdp) {\n      if (!this.dialog) {\n        this.pendingReinvite = false;\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      return Promise.resolve(this.dialog.invite(delegate, requestOptions));\n    } // Get an offer and send it in an INVITE\n\n\n    const offerOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n    };\n    return this.getOffer(offerOptions).then(offerBody => {\n      if (!this.dialog) {\n        this.pendingReinvite = false;\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      requestOptions.body = offerBody;\n      return this.dialog.invite(delegate, requestOptions);\n    }).catch(error => {\n      this.logger.error(error.message);\n      this.logger.error(\"Failed to send re-INVITE\");\n      this.pendingReinvite = false;\n      throw error;\n    });\n  }\n  /**\n   * Deliver a {@link Message}. Sends a MESSAGE.\n   * @param options - Options bucket. See {@link SessionMessageOptions} for details.\n   */\n\n\n  message() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.message() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    return this._message(requestDelegate, requestOptions);\n  }\n  /**\n   * Proffer a {@link Referral}. Send a REFER.\n   * @param referTo - The referral target. If a `Session`, a REFER w/Replaces is sent.\n   * @param options - Options bucket. See {@link SessionReferOptions} for details.\n   */\n\n\n  refer(referTo) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    // guard session state\n    if (this.state !== SessionState.Established) {\n      const message = \"Session.refer() may only be called if established session.\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    } // REFER with Replaces (Attended Transfer) only supported with established sessions.\n\n\n    if (referTo instanceof Session && !referTo.dialog) {\n      const message = \"Session.refer() may only be called with session which is established. \" + \"You are perhaps attempting to attended transfer to a target for which \" + \"there is not dialog yet established. Perhaps you are attempting a \" + \"'semi-attended' tansfer? Regardless, this is not supported. The recommended \" + \"approached is to check to see if the target Session is in the Established \" + \"state before calling refer(); if the state is not Established you may \" + \"proceed by falling back using a URI as the target (blind transfer).\";\n      this.logger.error(message);\n      return Promise.reject(new Error(`Invalid session state ${this.state}`));\n    }\n\n    const requestDelegate = options.requestDelegate;\n    const requestOptions = this.copyRequestOptions(options.requestOptions);\n    requestOptions.extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.concat(this.referExtraHeaders(this.referToString(referTo))) : this.referExtraHeaders(this.referToString(referTo));\n    return this._refer(options.onNotify, requestDelegate, requestOptions);\n  }\n  /**\n   * Send BYE.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _bye(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    const dialog = this.dialog; // The caller's UA MAY send a BYE for either confirmed or early dialogs,\n    // and the callee's UA MAY send a BYE on confirmed dialogs, but MUST NOT\n    // send a BYE on early dialogs. However, the callee's UA MUST NOT send a\n    // BYE on a confirmed dialog until it has received an ACK for its 2xx\n    // response or until the server transaction times out.\n    // https://tools.ietf.org/html/rfc3261#section-15\n\n    switch (dialog.sessionState) {\n      case SessionDialogState.Initial:\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      case SessionDialogState.Early:\n        // Implementation choice - not sending BYE for early dialogs.\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      case SessionDialogState.AckWait:\n        {\n          // This state only occurs if we are the callee.\n          this.stateTransition(SessionState.Terminating); // We're terminating\n\n          return new Promise(resolve => {\n            dialog.delegate = {\n              // When ACK shows up, say BYE.\n              onAck: () => {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                resolve(request);\n                return Promise.resolve();\n              },\n              // Or the server transaction times out before the ACK arrives.\n              onAckTimeout: () => {\n                const request = dialog.bye(delegate, options);\n                this.stateTransition(SessionState.Terminated);\n                resolve(request);\n              }\n            };\n          });\n        }\n\n      case SessionDialogState.Confirmed:\n        {\n          const request = dialog.bye(delegate, options);\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve(request);\n        }\n\n      case SessionDialogState.Terminated:\n        throw new Error(`Invalid dialog state ${dialog.sessionState}`);\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    }\n  }\n  /**\n   * Send INFO.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _info(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    return Promise.resolve(this.dialog.info(delegate, options));\n  }\n  /**\n   * Send MESSAGE.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _message(delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    }\n\n    return Promise.resolve(this.dialog.message(delegate, options));\n  }\n  /**\n   * Send REFER.\n   * @param onNotify - Notification callback.\n   * @param delegate - Request delegate.\n   * @param options - Request options bucket.\n   * @internal\n   */\n\n\n  _refer(onNotify, delegate, options) {\n    // Using core session dialog\n    if (!this.dialog) {\n      return Promise.reject(new Error(\"Session dialog undefined.\"));\n    } // If set, deliver any in-dialog NOTIFY requests here...\n\n\n    this.onNotify = onNotify;\n    return Promise.resolve(this.dialog.refer(delegate, options));\n  }\n  /**\n   * Send ACK and then BYE. There are unrecoverable errors which can occur\n   * while handling dialog forming and in-dialog INVITE responses and when\n   * they occur we ACK the response and send a BYE.\n   * Note that the BYE is sent in the dialog associated with the response\n   * which is not necessarily `this.dialog`. And, accordingly, the\n   * session state is not transitioned to terminated and session is not closed.\n   * @param inviteResponse - The response causing the error.\n   * @param statusCode - Status code for he reason phrase.\n   * @param reasonPhrase - Reason phrase for the BYE.\n   * @internal\n   */\n\n\n  ackAndBye(response, statusCode, reasonPhrase) {\n    response.ack();\n    const extraHeaders = [];\n\n    if (statusCode) {\n      extraHeaders.push(\"Reason: \" + this.getReasonHeaderValue(statusCode, reasonPhrase));\n    } // Using the dialog session associate with the response (which might not be this.dialog)\n\n\n    response.session.bye(undefined, {\n      extraHeaders\n    });\n  }\n  /**\n   * Handle in dialog ACK request.\n   * @internal\n   */\n\n\n  onAckRequest(request) {\n    this.logger.log(\"Session.onAckRequest\");\n\n    if (this.state !== SessionState.Established && this.state !== SessionState.Terminating) {\n      this.logger.error(`ACK received while in state ${this.state}, dropping request`);\n      return Promise.resolve();\n    }\n\n    const dialog = this.dialog;\n\n    if (!dialog) {\n      throw new Error(\"Dialog undefined.\");\n    } // if received answer in ACK.\n\n\n    const answerOptions = {\n      sessionDescriptionHandlerOptions: this.pendingReinviteAck ? this.sessionDescriptionHandlerOptionsReInvite : this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.pendingReinviteAck ? this._sessionDescriptionHandlerModifiersReInvite : this._sessionDescriptionHandlerModifiers\n    };\n\n    if (this.delegate && this.delegate.onAck) {\n      const ack = new Ack(request);\n      this.delegate.onAck(ack);\n    } // reset pending ACK flag\n\n\n    this.pendingReinviteAck = false;\n\n    switch (dialog.signalingState) {\n      case SignalingState.Initial:\n        {\n          // State should never be reached as first reliable response must have answer/offer.\n          // So we must have never has sent an offer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.Stable:\n        {\n          // State we should be in.\n          // Either the ACK has the answer that got us here, or we were in this state prior to the ACK.\n          const body = getBody(request.message); // If the ACK doesn't have an answer, nothing to be done.\n\n          if (!body) {\n            return Promise.resolve();\n          }\n\n          if (body.contentDisposition === \"render\") {\n            this._renderbody = body.content;\n            this._rendertype = body.contentType;\n            return Promise.resolve();\n          }\n\n          if (body.contentDisposition !== \"session\") {\n            return Promise.resolve();\n          }\n\n          return this.setAnswer(body, answerOptions).catch(error => {\n            this.logger.error(error.message);\n            const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n            dialog.bye(undefined, {\n              extraHeaders\n            });\n            this.stateTransition(SessionState.Terminated);\n          });\n        }\n\n      case SignalingState.HaveLocalOffer:\n        {\n          // State should never be reached as local offer would be answered by this ACK.\n          // So we must have received an ACK without an answer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.HaveRemoteOffer:\n        {\n          // State should never be reached as remote offer would be answered in first reliable response.\n          // So we must have never has sent an answer.\n          this.logger.error(`Invalid signaling state ${dialog.signalingState}.`);\n          const extraHeaders = [\"Reason: \" + this.getReasonHeaderValue(488, \"Bad Media Description\")];\n          dialog.bye(undefined, {\n            extraHeaders\n          });\n          this.stateTransition(SessionState.Terminated);\n          return Promise.resolve();\n        }\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${dialog.signalingState}.`);\n    }\n  }\n  /**\n   * Handle in dialog BYE request.\n   * @internal\n   */\n\n\n  onByeRequest(request) {\n    this.logger.log(\"Session.onByeRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`BYE received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onBye) {\n      const bye = new Bye(request);\n      this.delegate.onBye(bye);\n    } else {\n      request.accept();\n    }\n\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Handle in dialog INFO request.\n   * @internal\n   */\n\n\n  onInfoRequest(request) {\n    this.logger.log(\"Session.onInfoRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`INFO received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onInfo) {\n      const info = new Info(request);\n      this.delegate.onInfo(info);\n    } else {\n      // FIXME: TODO: We should reject request...\n      //\n      // If a UA receives an INFO request associated with an Info Package that\n      // the UA has not indicated willingness to receive, the UA MUST send a\n      // 469 (Bad Info Package) response (see Section 11.6), which contains a\n      // Recv-Info header field with Info Packages for which the UA is willing\n      // to receive INFO requests.\n      // https://tools.ietf.org/html/rfc6086#section-4.2.2\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog INVITE request.\n   * @internal\n   */\n\n\n  onInviteRequest(request) {\n    this.logger.log(\"Session.onInviteRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`INVITE received while in state ${this.state}, dropping request`);\n      return;\n    } // set pending ACK flag\n\n\n    this.pendingReinviteAck = true; // TODO: would be nice to have core track and set the Contact header,\n    // but currently the session which is setting it is holding onto it.\n\n    const extraHeaders = [\"Contact: \" + this._contact]; // Handle P-Asserted-Identity\n\n    if (request.message.hasHeader(\"P-Asserted-Identity\")) {\n      const header = request.message.getHeader(\"P-Asserted-Identity\");\n\n      if (!header) {\n        throw new Error(\"Header undefined.\");\n      }\n\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(header);\n    }\n\n    const options = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptionsReInvite,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiersReInvite\n    };\n    this.generateResponseOfferAnswerInDialog(options).then(body => {\n      const outgoingResponse = request.accept({\n        statusCode: 200,\n        extraHeaders,\n        body\n      });\n\n      if (this.delegate && this.delegate.onInvite) {\n        this.delegate.onInvite(request.message, outgoingResponse.message, 200);\n      }\n    }).catch(error => {\n      this.logger.error(error.message);\n      this.logger.error(\"Failed to handle to re-INVITE request\");\n\n      if (!this.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      this.logger.error(this.dialog.signalingState); // If we don't have a local/remote offer...\n\n      if (this.dialog.signalingState === SignalingState.Stable) {\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n\n        return;\n      } // Otherwise rollback\n\n\n      this.rollbackOffer().then(() => {\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n      }).catch(errorRollback => {\n        // No way to recover, so terminate session and mark as failed.\n        this.logger.error(errorRollback.message);\n        this.logger.error(\"Failed to rollback offer on re-INVITE request\");\n        const outgoingResponse = request.reject({\n          statusCode: 488\n        }); // Not Acceptable Here\n        // A BYE should only be sent if session is not already terminated.\n        // For example, a BYE may be sent/received while re-INVITE is outstanding.\n        // Note that the ACK was already sent by the transaction, so just need to send BYE.\n\n        if (this.state !== SessionState.Terminated) {\n          if (!this.dialog) {\n            throw new Error(\"Dialog undefined.\");\n          }\n\n          const extraHeadersBye = [];\n          extraHeadersBye.push(\"Reason: \" + this.getReasonHeaderValue(500, \"Internal Server Error\"));\n          this.dialog.bye(undefined, {\n            extraHeaders: extraHeadersBye\n          });\n          this.stateTransition(SessionState.Terminated);\n        }\n\n        if (this.delegate && this.delegate.onInvite) {\n          this.delegate.onInvite(request.message, outgoingResponse.message, 488);\n        }\n      });\n    });\n  }\n  /**\n   * Handle in dialog MESSAGE request.\n   * @internal\n   */\n\n\n  onMessageRequest(request) {\n    this.logger.log(\"Session.onMessageRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`MESSAGE received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onMessage) {\n      const message = new Message(request);\n      this.delegate.onMessage(message);\n    } else {\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog NOTIFY request.\n   * @internal\n   */\n\n\n  onNotifyRequest(request) {\n    this.logger.log(\"Session.onNotifyRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`NOTIFY received while in state ${this.state}, dropping request`);\n      return;\n    } // If this a NOTIFY associated with the progress of a REFER,\n    // look to delegate handling to the associated callback.\n\n\n    if (this.onNotify) {\n      const notification = new Notification(request);\n      this.onNotify(notification);\n      return;\n    } // Otherwise accept the NOTIFY.\n\n\n    if (this.delegate && this.delegate.onNotify) {\n      const notification = new Notification(request);\n      this.delegate.onNotify(notification);\n    } else {\n      request.accept();\n    }\n  }\n  /**\n   * Handle in dialog PRACK request.\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onPrackRequest(request) {\n    this.logger.log(\"Session.onPrackRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`PRACK received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    throw new Error(\"Unimplemented.\");\n  }\n  /**\n   * Handle in dialog REFER request.\n   * @internal\n   */\n\n\n  onReferRequest(request) {\n    this.logger.log(\"Session.onReferRequest\");\n\n    if (this.state !== SessionState.Established) {\n      this.logger.error(`REFER received while in state ${this.state}, dropping request`);\n      return;\n    } // REFER is a SIP request and is constructed as defined in [1].  A REFER\n    // request MUST contain exactly one Refer-To header field value.\n    // https://tools.ietf.org/html/rfc3515#section-2.4.1\n\n\n    if (!request.message.hasHeader(\"refer-to\")) {\n      this.logger.warn(\"Invalid REFER packet. A refer-to header is required. Rejecting.\");\n      request.reject();\n      return;\n    }\n\n    const referral = new Referral(request, this);\n\n    if (this.delegate && this.delegate.onRefer) {\n      this.delegate.onRefer(referral);\n    } else {\n      this.logger.log(\"No delegate available to handle REFER, automatically accepting and following.\");\n      referral.accept().then(() => referral.makeInviter(this._referralInviterOptions).invite()).catch(error => {\n        // FIXME: logging and eating error...\n        this.logger.error(error.message);\n      });\n    }\n  }\n  /**\n   * Generate an offer or answer for a response to an INVITE request.\n   * If a remote offer was provided in the request, set the remote\n   * description and get a local answer. If a remote offer was not\n   * provided, generates a local offer.\n   * @internal\n   */\n\n\n  generateResponseOfferAnswer(request, options) {\n    if (this.dialog) {\n      return this.generateResponseOfferAnswerInDialog(options);\n    }\n\n    const body = getBody(request.message);\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return this.getOffer(options);\n    } else {\n      return this.setOfferAndGetAnswer(body, options);\n    }\n  }\n  /**\n   * Generate an offer or answer for a response to an INVITE request\n   * when a dialog (early or otherwise) has already been established.\n   * This method may NOT be called if a dialog has yet to be established.\n   * @internal\n   */\n\n\n  generateResponseOfferAnswerInDialog(options) {\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    }\n\n    switch (this.dialog.signalingState) {\n      case SignalingState.Initial:\n        return this.getOffer(options);\n\n      case SignalingState.HaveLocalOffer:\n        // o  Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        return Promise.resolve(undefined);\n\n      case SignalingState.HaveRemoteOffer:\n        if (!this.dialog.offer) {\n          throw new Error(`Session offer undefined in signaling state ${this.dialog.signalingState}.`);\n        }\n\n        return this.setOfferAndGetAnswer(this.dialog.offer, options);\n\n      case SignalingState.Stable:\n        // o  Once the UAS has sent or received an answer to the initial\n        // offer, it MUST NOT generate subsequent offers in any responses\n        // to the initial INVITE.  This means that a UAS based on this\n        // specification alone can never generate subsequent offers until\n        // completion of the initial transaction.\n        // https://tools.ietf.org/html/rfc3261#section-13.2.1\n        if (this.state !== SessionState.Established) {\n          return Promise.resolve(undefined);\n        } // In dialog INVITE without offer, get an offer for the response.\n\n\n        return this.getOffer(options);\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n    }\n  }\n  /**\n   * Get local offer.\n   * @internal\n   */\n\n\n  getOffer(options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      return sdh.getDescription(sdhOptions, sdhModifiers).then(bodyAndContentType => fromBodyLegacy(bodyAndContentType)).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.getOffer: SDH getDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.getOffer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.getOffer: SDH getDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Rollback local/remote offer.\n   * @internal\n   */\n\n\n  rollbackOffer() {\n    const sdh = this.setupSessionDescriptionHandler();\n\n    if (sdh.rollbackDescription === undefined) {\n      return Promise.resolve();\n    } // This is intentionally written very defensively. Don't trust SDH to behave.\n\n\n    try {\n      return sdh.rollbackDescription().catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.rollbackOffer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.rollbackOffer: SDH rollbackDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Set remote answer.\n   * @internal\n   */\n\n\n  setAnswer(answer, options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      if (!sdh.hasDescription(answer.contentType)) {\n        return Promise.reject(new ContentTypeUnsupportedError());\n      }\n    } catch (error) {\n      this.logger.error(\"Session.setAnswer: SDH hasDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n\n    try {\n      return sdh.setDescription(answer.content, sdhOptions, sdhModifiers).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.setAnswer: SDH setDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.setAnswer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.setAnswer: SDH setDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * Set remote offer and get local answer.\n   * @internal\n   */\n\n\n  setOfferAndGetAnswer(offer, options) {\n    const sdh = this.setupSessionDescriptionHandler();\n    const sdhOptions = options.sessionDescriptionHandlerOptions;\n    const sdhModifiers = options.sessionDescriptionHandlerModifiers; // This is intentionally written very defensively. Don't trust SDH to behave.\n\n    try {\n      if (!sdh.hasDescription(offer.contentType)) {\n        return Promise.reject(new ContentTypeUnsupportedError());\n      }\n    } catch (error) {\n      this.logger.error(\"Session.setOfferAndGetAnswer: SDH hasDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n\n    try {\n      return sdh.setDescription(offer.content, sdhOptions, sdhModifiers).then(() => sdh.getDescription(sdhOptions, sdhModifiers)).then(bodyAndContentType => fromBodyLegacy(bodyAndContentType)).catch(error => {\n        // don't trust SDH to reject with Error\n        this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription rejected...\");\n        const e = error instanceof Error ? error : new Error(\"Session.setOfferAndGetAnswer unknown error.\");\n        this.logger.error(e.message);\n        throw e;\n      });\n    } catch (error) {\n      // don't trust SDH to throw an Error\n      this.logger.error(\"Session.setOfferAndGetAnswer: SDH setDescription or getDescription threw...\");\n      const e = error instanceof Error ? error : new Error(error);\n      this.logger.error(e.message);\n      return Promise.reject(e);\n    }\n  }\n  /**\n   * SDH for confirmed dialog.\n   * @internal\n   */\n\n\n  setSessionDescriptionHandler(sdh) {\n    if (this._sessionDescriptionHandler) {\n      throw new Error(\"Session description handler defined.\");\n    }\n\n    this._sessionDescriptionHandler = sdh;\n  }\n  /**\n   * SDH for confirmed dialog.\n   * @internal\n   */\n\n\n  setupSessionDescriptionHandler() {\n    var _a;\n\n    if (this._sessionDescriptionHandler) {\n      return this._sessionDescriptionHandler;\n    }\n\n    this._sessionDescriptionHandler = this.sessionDescriptionHandlerFactory(this, this.userAgent.configuration.sessionDescriptionHandlerFactoryOptions);\n\n    if ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onSessionDescriptionHandler) {\n      this.delegate.onSessionDescriptionHandler(this._sessionDescriptionHandler, false);\n    }\n\n    return this._sessionDescriptionHandler;\n  }\n  /**\n   * Transition session state.\n   * @internal\n   */\n\n\n  stateTransition(newState) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate transition\n\n\n    switch (this._state) {\n      case SessionState.Initial:\n        if (newState !== SessionState.Establishing && newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Establishing:\n        if (newState !== SessionState.Established && newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Established:\n        if (newState !== SessionState.Terminating && newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Terminating:\n        if (newState !== SessionState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case SessionState.Terminated:\n        invalidTransition();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    } // Transition\n\n\n    this._state = newState;\n    this.logger.log(`Session ${this.id} transitioned to state ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); // Dispose\n\n\n    if (newState === SessionState.Terminated) {\n      this.dispose();\n    }\n  }\n\n  copyRequestOptions() {\n    let requestOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const extraHeaders = requestOptions.extraHeaders ? requestOptions.extraHeaders.slice() : undefined;\n    const body = requestOptions.body ? {\n      contentDisposition: requestOptions.body.contentDisposition || \"render\",\n      contentType: requestOptions.body.contentType || \"text/plain\",\n      content: requestOptions.body.content || \"\"\n    } : undefined;\n    return {\n      extraHeaders,\n      body\n    };\n  }\n\n  getReasonHeaderValue(code, reason) {\n    const cause = code;\n    let text = getReasonPhrase(code);\n\n    if (!text && reason) {\n      text = reason;\n    }\n\n    return \"SIP;cause=\" + cause + ';text=\"' + text + '\"';\n  }\n\n  referExtraHeaders(referTo) {\n    const extraHeaders = [];\n    extraHeaders.push(\"Referred-By: <\" + this.userAgent.configuration.uri + \">\");\n    extraHeaders.push(\"Contact: \" + this._contact);\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString());\n    extraHeaders.push(\"Refer-To: \" + referTo);\n    return extraHeaders;\n  }\n\n  referToString(target) {\n    let referTo;\n\n    if (target instanceof URI) {\n      // REFER without Replaces (Blind Transfer)\n      referTo = target.toString();\n    } else {\n      // REFER with Replaces (Attended Transfer)\n      if (!target.dialog) {\n        throw new Error(\"Dialog undefined.\");\n      }\n\n      const displayName = target.remoteIdentity.friendlyName;\n      const remoteTarget = target.dialog.remoteTarget.toString();\n      const callId = target.dialog.callId;\n      const remoteTag = target.dialog.remoteTag;\n      const localTag = target.dialog.localTag;\n      const replaces = encodeURIComponent(`${callId};to-tag=${remoteTag};from-tag=${localTag}`);\n      referTo = `\"${displayName}\" <${remoteTarget}?Replaces=${replaces}>`;\n    }\n\n    return referTo;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}