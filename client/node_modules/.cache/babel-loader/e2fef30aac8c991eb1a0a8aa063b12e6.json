{"ast":null,"code":"\"use strict\";\n/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar mos_1 = require(\"./rtc/mos\");\n\nvar util_1 = require(\"./util\");\n\nvar getRTCStats = require('./rtc/stats').getRTCStats; // How many samples we use when testing metric thresholds\n\n\nvar SAMPLE_COUNT_METRICS = 5; // How many samples that need to cross the threshold to\n// raise or clear a warning.\n\nvar SAMPLE_COUNT_CLEAR = 0;\nvar SAMPLE_COUNT_RAISE = 3;\nvar SAMPLE_INTERVAL = 1000;\nvar WARNING_TIMEOUT = 5 * 1000;\nvar DEFAULT_THRESHOLDS = {\n  audioInputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  audioOutputLevel: {\n    minStandardDeviation: 327.67,\n    sampleCount: 10\n  },\n  bytesReceived: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  bytesSent: {\n    clearCount: 2,\n    min: 1,\n    raiseCount: 3,\n    sampleCount: 3\n  },\n  jitter: {\n    max: 30\n  },\n  mos: {\n    min: 3\n  },\n  packetsLostFraction: [{\n    max: 1\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7\n  }],\n  rtt: {\n    max: 400\n  }\n};\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\nfunction countHigh(max, values) {\n  return values.reduce(function (highCount, value) {\n    return highCount += value > max ? 1 : 0;\n  }, 0);\n}\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\n\n\nfunction countLow(min, values) {\n  return values.reduce(function (lowCount, value) {\n    return lowCount += value < min ? 1 : 0;\n  }, 0);\n}\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\n\n\nfunction calculateStandardDeviation(values) {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  var valueAverage = values.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / values.length;\n  var diffSquared = values.map(function (value) {\n    return Math.pow(value - valueAverage, 2);\n  });\n  var stdDev = Math.sqrt(diffSquared.reduce(function (partialSum, value) {\n    return partialSum + value;\n  }, 0) / diffSquared.length);\n  return stdDev;\n}\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\n\n\nfunction flattenSamples(sampleSets) {\n  return sampleSets.reduce(function (flat, current) {\n    return __spreadArrays(flat, current);\n  }, []);\n}\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\n\n\nvar StatsMonitor =\n/** @class */\nfunction (_super) {\n  __extends(StatsMonitor, _super);\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n\n\n  function StatsMonitor(options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A map of warnings with their raised time\n     */\n\n\n    _this._activeWarnings = new Map();\n    /**\n     * A map of stats with the number of exceeded thresholds\n     */\n\n    _this._currentStreaks = new Map();\n    /**\n     * Keeps track of input volumes in the last second\n     */\n\n    _this._inputVolumes = [];\n    /**\n     * Keeps track of output volumes in the last second\n     */\n\n    _this._outputVolumes = [];\n    /**\n     * Sample buffer. Saves most recent samples\n     */\n\n    _this._sampleBuffer = [];\n    /**\n     * Keeps track of supplemental sample values.\n     *\n     * Currently used for constant audio detection. Contains an array of volume\n     * samples for each sample interval.\n     */\n\n    _this._supplementalSampleBuffers = {\n      audioInputLevel: [],\n      audioOutputLevel: []\n    };\n    /**\n     * Whether warnings should be enabled\n     */\n\n    _this._warningsEnabled = true;\n    options = options || {};\n    _this._getRTCStats = options.getRTCStats || getRTCStats;\n    _this._mos = options.Mos || mos_1.default;\n    _this._peerConnection = options.peerConnection;\n    _this._thresholds = __assign(__assign({}, DEFAULT_THRESHOLDS), options.thresholds);\n    var thresholdSampleCounts = Object.values(_this._thresholds).map(function (threshold) {\n      return threshold.sampleCount;\n    }).filter(function (sampleCount) {\n      return !!sampleCount;\n    });\n    _this._maxSampleCount = Math.max.apply(Math, __spreadArrays([SAMPLE_COUNT_METRICS], thresholdSampleCounts));\n\n    if (_this._peerConnection) {\n      _this.enable(_this._peerConnection);\n    }\n\n    return _this;\n  }\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n\n\n  StatsMonitor.prototype.addVolumes = function (inputVolume, outputVolume) {\n    this._inputVolumes.push(inputVolume);\n\n    this._outputVolumes.push(outputVolume);\n  };\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disable = function () {\n    clearInterval(this._sampleInterval);\n    delete this._sampleInterval;\n    return this;\n  };\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.disableWarnings = function () {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  };\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enable = function (peerConnection) {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new errors_1.InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new errors_1.InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval || setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n    return this;\n  };\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n\n\n  StatsMonitor.prototype.enableWarnings = function () {\n    this._warningsEnabled = true;\n    return this;\n  };\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n\n\n  StatsMonitor.prototype.hasActiveWarning = function (statName, thresholdName) {\n    var warningId = statName + \":\" + thresholdName;\n    return !!this._activeWarnings.get(warningId);\n  };\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n\n\n  StatsMonitor.prototype._addSample = function (sample) {\n    var samples = this._sampleBuffer;\n    samples.push(sample); // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  };\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._clearWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    var activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) {\n      return;\n    }\n\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName]\n      }\n    }));\n  };\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._createSample = function (stats, previousSample) {\n    var previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    var previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    var previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    var previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    var previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n    var currentBytesSent = stats.bytesSent - previousBytesSent;\n    var currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    var currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    var currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    var currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    var currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    var currentPacketsLostFraction = currentInboundPackets > 0 ? currentPacketsLost / currentInboundPackets * 100 : 0;\n    var totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    var totalPacketsLostFraction = totalInboundPackets > 0 ? stats.packetsLost / totalInboundPackets * 100 : 100;\n    var rttValue = typeof stats.rtt === 'number' || !previousSample ? stats.rtt : previousSample.rtt;\n\n    var audioInputLevelValues = this._inputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    var audioOutputLevelValues = this._outputVolumes.splice(0);\n\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(util_1.average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(util_1.average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent\n      }\n    };\n  };\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n\n\n  StatsMonitor.prototype._fetchSample = function () {\n    var _this = this;\n\n    this._getSample().then(function (sample) {\n      _this._addSample(sample);\n\n      _this._raiseWarnings();\n\n      _this.emit('sample', sample);\n    }).catch(function (error) {\n      _this.disable(); // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n\n\n      _this.emit('error', error);\n    });\n  };\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n\n\n  StatsMonitor.prototype._getSample = function () {\n    var _this = this;\n\n    return this._getRTCStats(this._peerConnection).then(function (stats) {\n      var previousSample = null;\n\n      if (_this._sampleBuffer.length) {\n        previousSample = _this._sampleBuffer[_this._sampleBuffer.length - 1];\n      }\n\n      return _this._createSample(stats, previousSample);\n    });\n  };\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n\n\n  StatsMonitor.prototype._raiseWarning = function (statName, thresholdName, data) {\n    var warningId = statName + \":\" + thresholdName;\n\n    if (this._activeWarnings.has(warningId)) {\n      return;\n    }\n\n    this._activeWarnings.set(warningId, {\n      timeRaised: Date.now()\n    });\n\n    var thresholds = this._thresholds[statName];\n    var thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      var foundThreshold = thresholds.find(function (threshold) {\n        return thresholdName in threshold;\n      });\n\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', __assign(__assign({}, data), {\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue\n      }\n    }));\n  };\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n\n\n  StatsMonitor.prototype._raiseWarnings = function () {\n    var _this = this;\n\n    if (!this._warningsEnabled) {\n      return;\n    }\n\n    Object.keys(this._thresholds).forEach(function (name) {\n      return _this._raiseWarningsForStat(name);\n    });\n  };\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n\n\n  StatsMonitor.prototype._raiseWarningsForStat = function (statName) {\n    var _this = this;\n\n    var limits = Array.isArray(this._thresholds[statName]) ? this._thresholds[statName] : [this._thresholds[statName]];\n    limits.forEach(function (limit) {\n      var samples = _this._sampleBuffer;\n      var clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      var raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      var sampleCount = limit.sampleCount || _this._maxSampleCount;\n      var relevantSamples = samples.slice(-sampleCount);\n      var values = relevantSamples.map(function (sample) {\n        return sample[statName];\n      }); // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n\n      var containsNull = values.some(function (value) {\n        return typeof value === 'undefined' || value === null;\n      });\n\n      if (containsNull) {\n        return;\n      }\n\n      var count;\n\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'max', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n\n        if (count >= raiseCount) {\n          _this._raiseWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        } else if (count <= clearCount) {\n          _this._clearWarning(statName, 'min', {\n            values: values,\n            samples: relevantSamples\n          });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        var prevValue = relevantSamples[0][statName];\n        var curValue = relevantSamples[1][statName];\n        var prevStreak = _this._currentStreaks.get(statName) || 0;\n        var streak = prevValue === curValue ? prevStreak + 1 : 0;\n\n        _this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          _this._raiseWarning(statName, 'maxDuration', {\n            value: streak\n          });\n        } else if (streak === 0) {\n          _this._clearWarning(statName, 'maxDuration', {\n            value: prevStreak\n          });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        var sampleSets = _this._supplementalSampleBuffers[statName];\n\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n\n        var flatSamples = flattenSamples(sampleSets.slice(-sampleCount));\n        var stdDev = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          _this._raiseWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        } else {\n          _this._clearWarning(statName, 'minStandardDeviation', {\n            value: stdDev\n          });\n        }\n      }\n\n      [['maxAverage', function (x, y) {\n        return x > y;\n      }], ['minAverage', function (x, y) {\n        return x < y;\n      }]].forEach(function (_a) {\n        var thresholdName = _a[0],\n            comparator = _a[1];\n\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          var avg = util_1.average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            _this._raiseWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            _this._clearWarning(statName, thresholdName, {\n              values: values,\n              samples: relevantSamples\n            });\n          }\n        }\n      });\n    });\n  };\n\n  return StatsMonitor;\n}(events_1.EventEmitter);\n\nexports.default = StatsMonitor;","map":{"version":3,"mappings":"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","names":["SAMPLE_COUNT_METRICS","SAMPLE_COUNT_CLEAR","SAMPLE_COUNT_RAISE","SAMPLE_INTERVAL","WARNING_TIMEOUT","DEFAULT_THRESHOLDS","audioInputLevel","minStandardDeviation","sampleCount","audioOutputLevel","bytesReceived","clearCount","min","raiseCount","bytesSent","jitter","max","mos","packetsLostFraction","clearValue","maxAverage","rtt","countHigh","values","reduce","highCount","value","countLow","lowCount","calculateStandardDeviation","length","valueAverage","partialSum","diffSquared","map","pow","stdDev","Math","sqrt","flattenSamples","sampleSets","flat","current","__extends","options","_super","_this","Map","_getRTCStats","getRTCStats","_mos","Mos","mos_1","_peerConnection","peerConnection","_thresholds","__assign","thresholds","thresholdSampleCounts","Object","threshold","filter","_maxSampleCount","apply","__spreadArrays","enable","StatsMonitor","inputVolume","outputVolume","_inputVolumes","push","_outputVolumes","clearInterval","_sampleInterval","_warningsEnabled","_activeWarnings","clear","errors_1","setInterval","_fetchSample","bind","statName","thresholdName","warningId","get","sample","samples","_sampleBuffer","splice","data","activeWarning","Date","now","timeRaised","delete","emit","name","stats","previousSample","previousBytesSent","totals","previousBytesReceived","previousPacketsSent","packetsSent","previousPacketsReceived","packetsReceived","previousPacketsLost","packetsLost","currentBytesSent","currentBytesReceived","currentPacketsSent","currentPacketsReceived","currentPacketsLost","currentInboundPackets","currentPacketsLostFraction","totalInboundPackets","totalPacketsLostFraction","rttValue","audioInputLevelValues","_supplementalSampleBuffers","audioOutputLevelValues","round","util_1","codecName","calculate","timestamp","_getSample","then","_addSample","_raiseWarnings","catch","disable","error","_createSample","has","set","thresholdValue","Array","isArray","foundThreshold","find","keys","forEach","_raiseWarningsForStat","limits","limit","relevantSamples","slice","containsNull","some","count","_raiseWarning","_clearWarning","maxDuration","prevValue","curValue","prevStreak","_currentStreaks","streak","flatSamples","x","y","_a","comparator","avg","events_1","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/statsMonitor.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @internalapi\n */\n\nimport { EventEmitter } from 'events';\nimport { InvalidArgumentError } from './errors';\nimport Mos from './rtc/mos';\nimport RTCSample from './rtc/sample';\nimport RTCWarning from './rtc/warning';\nimport { average } from './util';\n\nconst { getRTCStats } = require('./rtc/stats');\n\n// How many samples we use when testing metric thresholds\nconst SAMPLE_COUNT_METRICS = 5;\n\n// How many samples that need to cross the threshold to\n// raise or clear a warning.\nconst SAMPLE_COUNT_CLEAR = 0;\nconst SAMPLE_COUNT_RAISE = 3;\n\nconst SAMPLE_INTERVAL = 1000;\nconst WARNING_TIMEOUT = 5 * 1000;\n\nconst DEFAULT_THRESHOLDS: StatsMonitor.ThresholdOptions = {\n  audioInputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  audioOutputLevel: { minStandardDeviation: 327.67, sampleCount: 10 },\n  bytesReceived: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  bytesSent: { clearCount: 2, min: 1, raiseCount: 3, sampleCount: 3 },\n  jitter: { max: 30 },\n  mos: { min: 3 },\n  packetsLostFraction: [{\n    max: 1,\n  }, {\n    clearValue: 1,\n    maxAverage: 3,\n    sampleCount: 7,\n  }],\n  rtt: { max: 400 },\n};\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPeerConnection = any;\n\n/**\n * @private\n */\nexport type IRTCStats = any;\n\n/**\n * @private\n */\nexport type IMos = typeof Mos;\n\n/**\n * Count the number of values that cross the max threshold.\n * @private\n * @param max - The max allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countHigh(max: number, values: number[]): number {\n  return values.reduce((highCount, value) => highCount += (value > max) ? 1 : 0, 0);\n}\n\n/**\n * Count the number of values that cross the min threshold.\n * @private\n * @param min - The minimum allowable value.\n * @param values - The values to iterate over.\n * @returns The amount of values in which the stat crossed the threshold.\n */\nfunction countLow(min: number, values: number[]): number {\n  return values.reduce((lowCount, value) => lowCount += (value < min) ? 1 : 0, 0);\n}\n\n/**\n * Calculate the standard deviation from a list of numbers.\n * @private\n * @param values The list of numbers to calculate the standard deviation from.\n * @returns The standard deviation of a list of numbers.\n */\nfunction calculateStandardDeviation(values: number[]): number | null {\n  if (values.length <= 0) {\n    return null;\n  }\n\n  const valueAverage: number = values.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / values.length;\n\n  const diffSquared: number[] = values.map(\n    (value: number) => Math.pow(value - valueAverage, 2),\n  );\n\n  const stdDev: number = Math.sqrt(diffSquared.reduce(\n    (partialSum: number, value: number) => partialSum + value,\n    0,\n  ) / diffSquared.length);\n\n  return stdDev;\n}\n\n/**\n * Flatten a set of numerical sample sets into a single array of samples.\n * @param sampleSets\n */\nfunction flattenSamples(sampleSets: number[][]): number[] {\n  return sampleSets.reduce(\n    (flat: number[], current: number[]) => [...flat, ...current],\n    [],\n  );\n}\n\n/**\n * {@link StatsMonitor} polls a peerConnection via PeerConnection.getStats\n * and emits warnings when stats cross the specified threshold values.\n */\nclass StatsMonitor extends EventEmitter {\n  /**\n   * A map of warnings with their raised time\n   */\n  private _activeWarnings: Map<string, StatsMonitor.WarningTimestamp> = new Map();\n\n  /**\n   * A map of stats with the number of exceeded thresholds\n   */\n  private _currentStreaks: Map<string, number> = new Map();\n\n  /**\n   * Method to get stats from a PeerConnection object. Overrides getRTCStats library\n   */\n  private _getRTCStats: (peerConnection: IPeerConnection) => IRTCStats;\n\n  /**\n   * Keeps track of input volumes in the last second\n   */\n  private _inputVolumes: number[] = [];\n\n  /**\n   * How many samples we use when testing metric thresholds.\n   */\n  private _maxSampleCount: number;\n\n  /**\n   * For calculating Mos. Overrides Mos library\n   */\n  private _mos: IMos;\n\n  /**\n   * Keeps track of output volumes in the last second\n   */\n  private _outputVolumes: number[] = [];\n\n  /**\n   * The PeerConnection to monitor.\n   */\n  private _peerConnection: IPeerConnection;\n\n  /**\n   * Sample buffer. Saves most recent samples\n   */\n  private _sampleBuffer: RTCSample[] = [];\n\n  /**\n   * The setInterval id for fetching samples.\n   */\n  private _sampleInterval: NodeJS.Timer;\n\n  /**\n   * Keeps track of supplemental sample values.\n   *\n   * Currently used for constant audio detection. Contains an array of volume\n   * samples for each sample interval.\n   */\n  private _supplementalSampleBuffers: Record<string, number[][]> = {\n    audioInputLevel: [],\n    audioOutputLevel: [],\n  };\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   */\n  private _thresholds: StatsMonitor.ThresholdOptions;\n\n  /**\n   * Whether warnings should be enabled\n   */\n  private _warningsEnabled: boolean = true;\n\n  /**\n   * @constructor\n   * @param [options] - Optional settings\n   */\n  constructor(options?: StatsMonitor.Options) {\n    super();\n\n    options = options || {};\n    this._getRTCStats = options.getRTCStats || getRTCStats;\n    this._mos = options.Mos || Mos;\n    this._peerConnection = options.peerConnection;\n    this._thresholds = {...DEFAULT_THRESHOLDS, ...options.thresholds};\n\n    const thresholdSampleCounts = Object.values(this._thresholds)\n      .map((threshold: StatsMonitor.ThresholdOptions) => threshold.sampleCount)\n      .filter((sampleCount: number | undefined) => !!sampleCount);\n\n    this._maxSampleCount = Math.max(SAMPLE_COUNT_METRICS, ...thresholdSampleCounts);\n\n    if (this._peerConnection) {\n      this.enable(this._peerConnection);\n    }\n  }\n\n  /**\n   * Called when a volume sample is available\n   * @param inputVolume - Input volume level from 0 to 32767\n   * @param outputVolume - Output volume level from 0 to 32767\n   */\n  addVolumes(inputVolume: number, outputVolume: number): void {\n    this._inputVolumes.push(inputVolume);\n    this._outputVolumes.push(outputVolume);\n  }\n\n  /**\n   * Stop sampling RTC statistics for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disable(): this {\n    clearInterval(this._sampleInterval);\n    delete this._sampleInterval;\n\n    return this;\n  }\n\n  /**\n   * Disable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  disableWarnings(): this {\n    if (this._warningsEnabled) {\n      this._activeWarnings.clear();\n    }\n\n    this._warningsEnabled = false;\n    return this;\n  }\n\n  /**\n   * Start sampling RTC statistics for this {@link StatsMonitor}.\n   * @param peerConnection - A PeerConnection to monitor.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enable(peerConnection: IPeerConnection): this {\n    if (peerConnection) {\n      if (this._peerConnection && peerConnection !== this._peerConnection) {\n        throw new InvalidArgumentError('Attempted to replace an existing PeerConnection in StatsMonitor.enable');\n      }\n      this._peerConnection = peerConnection;\n    }\n\n    if (!this._peerConnection) {\n      throw new InvalidArgumentError('Can not enable StatsMonitor without a PeerConnection');\n    }\n\n    this._sampleInterval = this._sampleInterval ||\n      setInterval(this._fetchSample.bind(this), SAMPLE_INTERVAL);\n\n    return this;\n  }\n\n  /**\n   * Enable warnings for this {@link StatsMonitor}.\n   * @returns The current {@link StatsMonitor}.\n   */\n  enableWarnings(): this {\n    this._warningsEnabled = true;\n    return this;\n  }\n\n  /**\n   * Check if there is an active warning for a specific stat and threshold\n   * @param statName - The name of the stat to check\n   * @param thresholdName - The name of the threshold to check\n   * @returns Whether there is an active warning for a specific stat and threshold\n   */\n  hasActiveWarning(statName: string, thresholdName: string): boolean {\n    const warningId = `${statName}:${thresholdName}`;\n    return !!this._activeWarnings.get(warningId);\n  }\n\n  /**\n   * Add a sample to our sample buffer and remove the oldest if we are over the limit.\n   * @param sample - Sample to add\n   */\n  private _addSample(sample: RTCSample): void {\n    const samples = this._sampleBuffer;\n    samples.push(sample);\n\n    // We store 1 extra sample so that we always have (current, previous)\n    // available for all {sampleBufferSize} threshold validations.\n    if (samples.length > this._maxSampleCount) {\n      samples.splice(0, samples.length - this._maxSampleCount);\n    }\n  }\n\n  /**\n   * Clear an active warning.\n   * @param statName - The name of the stat to clear.\n   * @param thresholdName - The name of the threshold to clear\n   * @param [data] - Any relevant sample data.\n   */\n  private _clearWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n    const activeWarning = this._activeWarnings.get(warningId);\n\n    if (!activeWarning || Date.now() - activeWarning.timeRaised < WARNING_TIMEOUT) { return; }\n    this._activeWarnings.delete(warningId);\n\n    this.emit('warning-cleared', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: this._thresholds[statName][thresholdName],\n      },\n    });\n  }\n\n  /**\n   * Create a sample object from a stats object using the previous sample, if available.\n   * @param stats - Stats retrieved from getStatistics\n   * @param [previousSample=null] - The previous sample to use to calculate deltas.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _createSample(stats: IRTCStats, previousSample: RTCSample | null): RTCSample {\n    const previousBytesSent = previousSample && previousSample.totals.bytesSent || 0;\n    const previousBytesReceived = previousSample && previousSample.totals.bytesReceived || 0;\n    const previousPacketsSent = previousSample && previousSample.totals.packetsSent || 0;\n    const previousPacketsReceived = previousSample && previousSample.totals.packetsReceived || 0;\n    const previousPacketsLost = previousSample && previousSample.totals.packetsLost || 0;\n\n    const currentBytesSent = stats.bytesSent - previousBytesSent;\n    const currentBytesReceived = stats.bytesReceived - previousBytesReceived;\n    const currentPacketsSent = stats.packetsSent - previousPacketsSent;\n    const currentPacketsReceived = stats.packetsReceived - previousPacketsReceived;\n    const currentPacketsLost = stats.packetsLost - previousPacketsLost;\n    const currentInboundPackets = currentPacketsReceived + currentPacketsLost;\n    const currentPacketsLostFraction = (currentInboundPackets > 0) ?\n      (currentPacketsLost / currentInboundPackets) * 100 : 0;\n\n    const totalInboundPackets = stats.packetsReceived + stats.packetsLost;\n    const totalPacketsLostFraction = (totalInboundPackets > 0) ?\n      (stats.packetsLost / totalInboundPackets) * 100 : 100;\n\n    const rttValue = (typeof stats.rtt === 'number' || !previousSample) ? stats.rtt : previousSample.rtt;\n\n    const audioInputLevelValues = this._inputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioInputLevel.push(audioInputLevelValues);\n\n    const audioOutputLevelValues = this._outputVolumes.splice(0);\n    this._supplementalSampleBuffers.audioOutputLevel.push(audioOutputLevelValues);\n\n    return {\n      audioInputLevel: Math.round(average(audioInputLevelValues)),\n      audioOutputLevel: Math.round(average(audioOutputLevelValues)),\n      bytesReceived: currentBytesReceived,\n      bytesSent: currentBytesSent,\n      codecName: stats.codecName,\n      jitter: stats.jitter,\n      mos: this._mos.calculate(rttValue, stats.jitter, previousSample && currentPacketsLostFraction),\n      packetsLost: currentPacketsLost,\n      packetsLostFraction: currentPacketsLostFraction,\n      packetsReceived: currentPacketsReceived,\n      packetsSent: currentPacketsSent,\n      rtt: rttValue,\n      timestamp: stats.timestamp,\n      totals: {\n        bytesReceived: stats.bytesReceived,\n        bytesSent: stats.bytesSent,\n        packetsLost: stats.packetsLost,\n        packetsLostFraction: totalPacketsLostFraction,\n        packetsReceived: stats.packetsReceived,\n        packetsSent: stats.packetsSent,\n      },\n    };\n  }\n\n  /**\n   * Get stats from the PeerConnection and add it to our list of samples.\n   */\n  private _fetchSample(): void {\n    this._getSample().then(sample => {\n      this._addSample(sample);\n      this._raiseWarnings();\n      this.emit('sample', sample);\n    }).catch(error => {\n      this.disable();\n      // We only bubble up any errors coming from pc.getStats()\n      // No need to attach a twilioError\n      this.emit('error', error);\n    });\n  }\n\n  /**\n   * Get stats from the PeerConnection.\n   * @returns A universally-formatted version of RTC stats.\n   */\n  private _getSample(): Promise<RTCSample> {\n    return this._getRTCStats(this._peerConnection).then((stats: IRTCStats) => {\n      let previousSample = null;\n      if (this._sampleBuffer.length) {\n        previousSample = this._sampleBuffer[this._sampleBuffer.length - 1];\n      }\n\n      return this._createSample(stats, previousSample);\n    });\n  }\n\n  /**\n   * Raise a warning and log its raised time.\n   * @param statName - The name of the stat to raise.\n   * @param thresholdName - The name of the threshold to raise\n   * @param [data] - Any relevant sample data.\n   */\n  private _raiseWarning(statName: string, thresholdName: string, data?: RTCWarning): void {\n    const warningId = `${statName}:${thresholdName}`;\n\n    if (this._activeWarnings.has(warningId)) { return; }\n    this._activeWarnings.set(warningId, { timeRaised: Date.now() });\n\n    const thresholds: StatsMonitor.ThresholdOption | StatsMonitor.ThresholdOption[] =\n      this._thresholds[statName];\n\n    let thresholdValue;\n\n    if (Array.isArray(thresholds)) {\n      const foundThreshold = thresholds.find(threshold => thresholdName in threshold);\n      if (foundThreshold) {\n        thresholdValue = foundThreshold[thresholdName as keyof StatsMonitor.ThresholdOption];\n      }\n    } else {\n      thresholdValue = this._thresholds[statName][thresholdName];\n    }\n\n    this.emit('warning', {\n      ...data,\n      name: statName,\n      threshold: {\n        name: thresholdName,\n        value: thresholdValue,\n      },\n    });\n  }\n\n  /**\n   * Apply our thresholds to our array of RTCStat samples.\n   */\n  private _raiseWarnings(): void {\n    if (!this._warningsEnabled) { return; }\n\n    Object.keys(this._thresholds).forEach(name => this._raiseWarningsForStat(name));\n  }\n\n  /**\n   * Apply thresholds for a given stat name to our array of\n   * RTCStat samples and raise or clear any associated warnings.\n   * @param statName - Name of the stat to compare.\n   */\n  private _raiseWarningsForStat(statName: string): void {\n    const limits: StatsMonitor.ThresholdOptions[] =\n      Array.isArray(this._thresholds[statName])\n        ? this._thresholds[statName]\n        : [this._thresholds[statName]];\n\n    limits.forEach((limit: StatsMonitor.ThresholdOptions) => {\n      const samples = this._sampleBuffer;\n\n      const clearCount = limit.clearCount || SAMPLE_COUNT_CLEAR;\n      const raiseCount = limit.raiseCount || SAMPLE_COUNT_RAISE;\n      const sampleCount = limit.sampleCount || this._maxSampleCount;\n\n      let relevantSamples = samples.slice(-sampleCount);\n      const values = relevantSamples.map(sample => sample[statName]);\n\n      // (rrowland) If we have a bad or missing value in the set, we don't\n      // have enough information to throw or clear a warning. Bail out.\n      const containsNull = values.some(value => typeof value === 'undefined' || value === null);\n\n      if (containsNull) {\n        return;\n      }\n\n      let count;\n      if (typeof limit.max === 'number') {\n        count = countHigh(limit.max, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'max', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'max', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.min === 'number') {\n        count = countLow(limit.min, values);\n        if (count >= raiseCount) {\n          this._raiseWarning(statName, 'min', { values, samples: relevantSamples });\n        } else if (count <= clearCount) {\n          this._clearWarning(statName, 'min', { values, samples: relevantSamples });\n        }\n      }\n\n      if (typeof limit.maxDuration === 'number' && samples.length > 1) {\n        relevantSamples = samples.slice(-2);\n        const prevValue = relevantSamples[0][statName];\n        const curValue = relevantSamples[1][statName];\n\n        const prevStreak = this._currentStreaks.get(statName) || 0;\n        const streak = (prevValue === curValue) ? prevStreak + 1 : 0;\n\n        this._currentStreaks.set(statName, streak);\n\n        if (streak >= limit.maxDuration) {\n          this._raiseWarning(statName, 'maxDuration', { value: streak });\n        } else if (streak === 0) {\n          this._clearWarning(statName, 'maxDuration', { value: prevStreak });\n        }\n      }\n\n      if (typeof limit.minStandardDeviation === 'number') {\n        const sampleSets: number[][] = this._supplementalSampleBuffers[statName];\n        if (!sampleSets || sampleSets.length < limit.sampleCount) {\n          return;\n        }\n        if (sampleSets.length > limit.sampleCount) {\n          sampleSets.splice(0, sampleSets.length - limit.sampleCount);\n        }\n        const flatSamples: number[] = flattenSamples(sampleSets.slice(-sampleCount));\n        const stdDev: number | null = calculateStandardDeviation(flatSamples);\n\n        if (typeof stdDev !== 'number') {\n          return;\n        }\n\n        if (stdDev < limit.minStandardDeviation) {\n          this._raiseWarning(statName, 'minStandardDeviation', { value: stdDev });\n        } else {\n          this._clearWarning(statName, 'minStandardDeviation', { value: stdDev });\n        }\n      }\n\n      ([\n        ['maxAverage', (x: number, y: number) => x > y],\n        ['minAverage', (x: number, y: number) => x < y],\n      ] as const).forEach(([thresholdName, comparator]) => {\n        if (typeof limit[thresholdName] === 'number' && values.length >= sampleCount) {\n          const avg: number = average(values);\n\n          if (comparator(avg, limit[thresholdName])) {\n            this._raiseWarning(statName, thresholdName, { values, samples: relevantSamples });\n          } else if (!comparator(avg, limit.clearValue || limit[thresholdName])) {\n            this._clearWarning(statName, thresholdName, { values, samples: relevantSamples });\n          }\n        }\n      });\n    });\n  }\n}\n\nnamespace StatsMonitor {\n  /**\n   * Config options to be passed to the {@link StatsMonitor} constructor.\n   * @private\n   */\n  export interface Options {\n    /**\n     * Method to get stats from a PeerConnection object\n     */\n    getRTCStats?: (peerConnection: IPeerConnection) => IRTCStats;\n\n    /**\n     * For calculating Mos. Overrides Mos library\n     */\n    Mos?: IMos;\n\n    /**\n     * The PeerConnection to monitor.\n     */\n    peerConnection?: IPeerConnection;\n\n    /**\n     * Optional custom threshold values.\n     */\n    thresholds?: ThresholdOptions;\n  }\n\n  /**\n   * Speficic threshold value for {@link ThresholdOptions}\n   * @private\n   */\n  export interface ThresholdOption {\n    /**\n     * How many samples that need to cross the threshold to clear a warning.\n     * Overrides SAMPLE_COUNT_CLEAR\n     */\n    clearCount?: number;\n\n    /**\n     * Used with the `minAverage` and `maxAverage` options. If `maxAverage` is\n     * used, then the warning will be cleared when at or below this value. If\n     * `minAverage` is used, then the warning will be cleared at or above this\n     * value.\n     */\n    clearValue?: number;\n\n    /**\n     * Warning will be raised if tracked metric rises above this value.\n     */\n    max?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is above the `raiseValue` amount and\n     * is cleared when below the `clearValue` amount.\n     */\n    maxAverage?: number;\n\n    /**\n     * Warning will be raised if tracked metric stays constant for\n     * the specified number of consequent samples.\n     */\n    maxDuration?: number;\n\n    /**\n     * Warning will be raised if tracked metric falls below this value.\n     */\n    min?: number;\n\n    /**\n     * Warning will be raised based on the average over `sampleCount` samples.\n     * The warning is raised if the average is below the `raiseValue` amount and\n     * is cleared when above the `clearValue` amount.\n     */\n    minAverage?: number;\n\n    /**\n     * Warning will be raised if the standard deviation of the tracked metric\n     * does not exceed this value.\n     */\n    minStandardDeviation?: number;\n\n    /**\n     * How many samples that need to cross the threshold to raise a warning.\n     * Overrides SAMPLE_COUNT_RAISE\n     */\n    raiseCount?: number;\n\n    /**\n     * How many samples we use when testing metric thresholds.\n     * Overrides _maxSampleCount\n     */\n    sampleCount?: number;\n  }\n\n  /**\n   * Threshold values for {@link StatsMonitor}\n   * @private\n   */\n  export interface ThresholdOptions {\n    [key: string]: any;\n\n    /**\n     * Audio input level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioInputLevel?: ThresholdOption;\n\n    /**\n     * Audio output level between 0 and 32767, representing -100 to -30 dB.\n     */\n    audioOutputLevel?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.jitter\n     */\n    jitter?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.mos\n     */\n    mos?: ThresholdOption;\n\n    /**\n     * Rules to apply to sample.packetsLostFraction\n     */\n    packetsLostFraction?: ThresholdOption[];\n\n    /**\n     * Rules to apply to sample.rtt\n     */\n    rtt?: ThresholdOption;\n  }\n\n  /**\n   * Timestamp for raised warnings\n   * @private\n   */\n  export interface WarningTimestamp {\n    /**\n     * Timestamp in milliseconds\n     */\n    timeRaised: number;\n  }\n}\n\nexport default StatsMonitor;\n"]},"metadata":{},"sourceType":"script"}