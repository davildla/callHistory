{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\n\nvar events_1 = require(\"events\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar outputdevicecollection_1 = require(\"./outputdevicecollection\");\n\nvar defaultMediaDevices = require(\"./shims/mediadevices\");\n\nvar util_1 = require(\"./util\");\n\nvar MediaDeviceInfoShim = require('./shims/mediadeviceinfo');\n/**\n * Aliases for audio kinds, used for labelling.\n * @private\n */\n\n\nvar kindAliases = {\n  audioinput: 'Audio Input',\n  audiooutput: 'Audio Output'\n};\n/**\n * Provides input and output audio-based functionality in one convenient class.\n * @publicapi\n */\n\nvar AudioHelper =\n/** @class */\nfunction (_super) {\n  __extends(AudioHelper, _super);\n  /**\n   * @constructor\n   * @private\n   * @param onActiveOutputsChanged - A callback to be called when the user changes the active output devices.\n   * @param onActiveInputChanged - A callback to be called when the user changes the active input device.\n   * @param getUserMedia - The getUserMedia method to use.\n   * @param [options]\n   */\n\n\n  function AudioHelper(onActiveOutputsChanged, onActiveInputChanged, getUserMedia, options) {\n    var _this = _super.call(this) || this;\n    /**\n     * A Map of all audio input devices currently available to the browser by their device ID.\n     */\n\n\n    _this.availableInputDevices = new Map();\n    /**\n     * A Map of all audio output devices currently available to the browser by their device ID.\n     */\n\n    _this.availableOutputDevices = new Map();\n    /**\n     * The currently set audio constraints set by setAudioConstraints().\n     */\n\n    _this._audioConstraints = null;\n    /**\n     * The current input device.\n     */\n\n    _this._inputDevice = null;\n    /**\n     * The current input stream.\n     */\n\n    _this._inputStream = null;\n    /**\n     * Whether the {@link AudioHelper} is currently polling the input stream's volume.\n     */\n\n    _this._isPollingInputVolume = false;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * A record of unknown devices (Devices without labels)\n     */\n\n    _this._unknownDeviceIndexes = {\n      audioinput: {},\n      audiooutput: {}\n    };\n    /**\n     * Remove an input device from inputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n\n    _this._removeLostInput = function (lostDevice) {\n      if (!_this.inputDevice || _this.inputDevice.deviceId !== lostDevice.deviceId) {\n        return false;\n      }\n\n      _this._replaceStream(null);\n\n      _this._inputDevice = null;\n\n      _this._maybeStopPollingVolume();\n\n      var defaultDevice = _this.availableInputDevices.get('default') || Array.from(_this.availableInputDevices.values())[0];\n\n      if (defaultDevice) {\n        _this.setInputDevice(defaultDevice.deviceId);\n      }\n\n      return true;\n    };\n    /**\n     * Remove an input device from outputs\n     * @param lostDevice\n     * @returns Whether the device was active\n     */\n\n\n    _this._removeLostOutput = function (lostDevice) {\n      var wasSpeakerLost = _this.speakerDevices.delete(lostDevice);\n\n      var wasRingtoneLost = _this.ringtoneDevices.delete(lostDevice);\n\n      return wasSpeakerLost || wasRingtoneLost;\n    };\n    /**\n     * Update the available input and output devices\n     */\n\n\n    _this._updateAvailableDevices = function () {\n      if (!_this._mediaDevices) {\n        return Promise.reject('Enumeration not supported');\n      }\n\n      return _this._mediaDevices.enumerateDevices().then(function (devices) {\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audiooutput';\n        }), _this.availableOutputDevices, _this._removeLostOutput);\n\n        _this._updateDevices(devices.filter(function (d) {\n          return d.kind === 'audioinput';\n        }), _this.availableInputDevices, _this._removeLostInput);\n\n        var defaultDevice = _this.availableOutputDevices.get('default') || Array.from(_this.availableOutputDevices.values())[0];\n        [_this.speakerDevices, _this.ringtoneDevices].forEach(function (outputDevices) {\n          if (!outputDevices.get().size && _this.availableOutputDevices.size && _this.isOutputSelectionSupported) {\n            outputDevices.set(defaultDevice.deviceId).catch(function (reason) {\n              _this._log.warn(\"Unable to set audio output devices. \" + reason);\n            });\n          }\n        });\n      });\n    };\n\n    options = Object.assign({\n      AudioContext: typeof AudioContext !== 'undefined' && AudioContext,\n      setSinkId: typeof HTMLAudioElement !== 'undefined' && HTMLAudioElement.prototype.setSinkId\n    }, options);\n    _this._getUserMedia = getUserMedia;\n    _this._mediaDevices = options.mediaDevices || defaultMediaDevices;\n    _this._onActiveInputChanged = onActiveInputChanged;\n    var isAudioContextSupported = !!(options.AudioContext || options.audioContext);\n    var isEnumerationSupported = !!(_this._mediaDevices && _this._mediaDevices.enumerateDevices);\n    var isSetSinkSupported = typeof options.setSinkId === 'function';\n    _this.isOutputSelectionSupported = isEnumerationSupported && isSetSinkSupported;\n    _this.isVolumeSupported = isAudioContextSupported;\n\n    if (options.enabledSounds) {\n      _this._addEnabledSounds(options.enabledSounds);\n    }\n\n    if (_this.isVolumeSupported) {\n      _this._audioContext = options.audioContext || options.AudioContext && new options.AudioContext();\n\n      if (_this._audioContext) {\n        _this._inputVolumeAnalyser = _this._audioContext.createAnalyser();\n        _this._inputVolumeAnalyser.fftSize = 32;\n        _this._inputVolumeAnalyser.smoothingTimeConstant = 0.3;\n      }\n    }\n\n    _this.ringtoneDevices = new outputdevicecollection_1.default('ringtone', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n    _this.speakerDevices = new outputdevicecollection_1.default('speaker', _this.availableOutputDevices, onActiveOutputsChanged, _this.isOutputSelectionSupported);\n\n    _this.addListener('newListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStartPollingVolume();\n      }\n    });\n\n    _this.addListener('removeListener', function (eventName) {\n      if (eventName === 'inputVolume') {\n        _this._maybeStopPollingVolume();\n      }\n    });\n\n    _this.once('newListener', function () {\n      // NOTE (rrowland): Ideally we would only check isEnumerationSupported here, but\n      //   in at least one browser version (Tested in FF48) enumerateDevices actually\n      //   returns bad data for the listed devices. Instead, we check for\n      //   isOutputSelectionSupported to avoid these quirks that may negatively affect customers.\n      if (!_this.isOutputSelectionSupported) {\n        _this._log.warn('Warning: This browser does not support audio output selection.');\n      }\n\n      if (!_this.isVolumeSupported) {\n        _this._log.warn(\"Warning: This browser does not support Twilio's volume indicator feature.\");\n      }\n    });\n\n    if (isEnumerationSupported) {\n      _this._initializeEnumeration();\n    }\n\n    return _this;\n  }\n\n  Object.defineProperty(AudioHelper.prototype, \"audioConstraints\", {\n    /**\n     * The currently set audio constraints set by setAudioConstraints(). Starts as null.\n     */\n    get: function () {\n      return this._audioConstraints;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputDevice\", {\n    /**\n     * The active input device. Having no inputDevice specified by `setInputDevice()`\n     * will disable input selection related functionality.\n     */\n    get: function () {\n      return this._inputDevice;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(AudioHelper.prototype, \"inputStream\", {\n    /**\n     * The current input stream.\n     */\n    get: function () {\n      return this._inputStream;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Start polling volume if it's supported and there's an input stream to poll.\n   * @private\n   */\n\n  AudioHelper.prototype._maybeStartPollingVolume = function () {\n    var _this = this;\n\n    if (!this.isVolumeSupported || !this._inputStream) {\n      return;\n    }\n\n    this._updateVolumeSource();\n\n    if (this._isPollingInputVolume || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    var bufferLength = this._inputVolumeAnalyser.frequencyBinCount;\n    var buffer = new Uint8Array(bufferLength);\n    this._isPollingInputVolume = true;\n\n    var emitVolume = function () {\n      if (!_this._isPollingInputVolume) {\n        return;\n      }\n\n      if (_this._inputVolumeAnalyser) {\n        _this._inputVolumeAnalyser.getByteFrequencyData(buffer);\n\n        var inputVolume = util_1.average(buffer);\n\n        _this.emit('inputVolume', inputVolume / 255);\n      }\n\n      requestAnimationFrame(emitVolume);\n    };\n\n    requestAnimationFrame(emitVolume);\n  };\n  /**\n   * Stop polling volume if it's currently polling and there are no listeners.\n   * @private\n   */\n\n\n  AudioHelper.prototype._maybeStopPollingVolume = function () {\n    if (!this.isVolumeSupported) {\n      return;\n    }\n\n    if (!this._isPollingInputVolume || this._inputStream && this.listenerCount('inputVolume')) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n\n      delete this._inputVolumeSource;\n    }\n\n    this._isPollingInputVolume = false;\n  };\n  /**\n   * Unbind the listeners from mediaDevices.\n   * @private\n   */\n\n\n  AudioHelper.prototype._unbind = function () {\n    if (!this._mediaDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.removeEventListener) {\n      this._mediaDevices.removeEventListener('devicechange', this._updateAvailableDevices);\n\n      this._mediaDevices.removeEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n  };\n  /**\n   * Set the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. Any deviceId specified here will be ignored. Instead, device IDs should\n   * be specified using {@link AudioHelper#setInputDevice}. The returned Promise resolves\n   * when the media is successfully reacquired, or immediately if no input device is set.\n   * @param audioConstraints - The MediaTrackConstraints to apply.\n   */\n\n\n  AudioHelper.prototype.setAudioConstraints = function (audioConstraints) {\n    this._audioConstraints = Object.assign({}, audioConstraints);\n    delete this._audioConstraints.deviceId;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   */\n\n\n  AudioHelper.prototype.setInputDevice = function (deviceId) {\n    return !util_1.isFirefox() ? this._setInputDevice(deviceId, false) : Promise.reject(new errors_1.NotSupportedError('Firefox does not currently support opening multiple ' + 'audio input tracks simultaneously, even across different tabs. As a result, ' + 'Device.audio.setInputDevice is disabled on Firefox until support is added.\\n' + 'Related BugZilla thread: https://bugzilla.mozilla.org/show_bug.cgi?id=1299324'));\n  };\n  /**\n   * Unset the MediaTrackConstraints to be applied on every getUserMedia call for new input\n   * device audio. The returned Promise resolves when the media is successfully reacquired,\n   * or immediately if no input device is set.\n   */\n\n\n  AudioHelper.prototype.unsetAudioConstraints = function () {\n    this._audioConstraints = null;\n    return this.inputDevice ? this._setInputDevice(this.inputDevice.deviceId, true) : Promise.resolve();\n  };\n  /**\n   * Unset the input device, stopping the tracks. This should only be called when not in a connection, and\n   *   will not allow removal of the input device during a live call.\n   */\n\n\n  AudioHelper.prototype.unsetInputDevice = function () {\n    var _this = this;\n\n    if (!this.inputDevice) {\n      return Promise.resolve();\n    }\n\n    return this._onActiveInputChanged(null).then(function () {\n      _this._replaceStream(null);\n\n      _this._inputDevice = null;\n\n      _this._maybeStopPollingVolume();\n    });\n  };\n  /**\n   * Merge the passed enabledSounds into {@link AudioHelper}. Currently used to merge the deprecated\n   *   Device.sounds object onto the new {@link AudioHelper} interface. Mutates\n   *   by reference, sharing state between {@link Device} and {@link AudioHelper}.\n   * @param enabledSounds - The initial sound settings to merge.\n   * @private\n   */\n\n\n  AudioHelper.prototype._addEnabledSounds = function (enabledSounds) {\n    var _this = this;\n\n    function setValue(key, value) {\n      if (typeof value !== 'undefined') {\n        enabledSounds[key] = value;\n      }\n\n      return enabledSounds[key];\n    }\n\n    Object.keys(enabledSounds).forEach(function (key) {\n      _this[key] = setValue.bind(null, key);\n    });\n  };\n  /**\n   * Get the index of an un-labeled Device.\n   * @param mediaDeviceInfo\n   * @returns The index of the passed MediaDeviceInfo\n   */\n\n\n  AudioHelper.prototype._getUnknownDeviceIndex = function (mediaDeviceInfo) {\n    var id = mediaDeviceInfo.deviceId;\n    var kind = mediaDeviceInfo.kind;\n    var index = this._unknownDeviceIndexes[kind][id];\n\n    if (!index) {\n      index = Object.keys(this._unknownDeviceIndexes[kind]).length + 1;\n      this._unknownDeviceIndexes[kind][id] = index;\n    }\n\n    return index;\n  };\n  /**\n   * Initialize output device enumeration.\n   */\n\n\n  AudioHelper.prototype._initializeEnumeration = function () {\n    var _this = this;\n\n    if (!this._mediaDevices) {\n      throw new errors_1.NotSupportedError('Enumeration is not supported');\n    }\n\n    if (this._mediaDevices.addEventListener) {\n      this._mediaDevices.addEventListener('devicechange', this._updateAvailableDevices);\n\n      this._mediaDevices.addEventListener('deviceinfochange', this._updateAvailableDevices);\n    }\n\n    this._updateAvailableDevices().then(function () {\n      if (!_this.isOutputSelectionSupported) {\n        return;\n      }\n\n      Promise.all([_this.speakerDevices.set('default'), _this.ringtoneDevices.set('default')]).catch(function (reason) {\n        _this._log.warn(\"Warning: Unable to set audio output devices. \" + reason);\n      });\n    });\n  };\n  /**\n   * Stop the tracks on the current input stream before replacing it with the passed stream.\n   * @param stream - The new stream\n   */\n\n\n  AudioHelper.prototype._replaceStream = function (stream) {\n    if (this._inputStream) {\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n\n    this._inputStream = stream;\n  };\n  /**\n   * Replace the current input device with a new device by ID.\n   * @param deviceId - An ID of a device to replace the existing\n   *   input device with.\n   * @param forceGetUserMedia - If true, getUserMedia will be called even if\n   *   the specified device is already active.\n   */\n\n\n  AudioHelper.prototype._setInputDevice = function (deviceId, forceGetUserMedia) {\n    var _this = this;\n\n    if (typeof deviceId !== 'string') {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify the device to set'));\n    }\n\n    var device = this.availableInputDevices.get(deviceId);\n\n    if (!device) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Device not found: \" + deviceId));\n    }\n\n    if (this._inputDevice && this._inputDevice.deviceId === deviceId && this._inputStream) {\n      if (!forceGetUserMedia) {\n        return Promise.resolve();\n      } // If the currently active track is still in readyState `live`, gUM may return the same track\n      // rather than returning a fresh track.\n\n\n      this._inputStream.getTracks().forEach(function (track) {\n        track.stop();\n      });\n    }\n\n    var constraints = {\n      audio: Object.assign({\n        deviceId: {\n          exact: deviceId\n        }\n      }, this.audioConstraints)\n    };\n    return this._getUserMedia(constraints).then(function (stream) {\n      return _this._onActiveInputChanged(stream).then(function () {\n        _this._replaceStream(stream);\n\n        _this._inputDevice = device;\n\n        _this._maybeStartPollingVolume();\n      });\n    });\n  };\n  /**\n   * Update a set of devices.\n   * @param updatedDevices - An updated list of available Devices\n   * @param availableDevices - The previous list of available Devices\n   * @param removeLostDevice - The method to call if a previously available Device is\n   *   no longer available.\n   */\n\n\n  AudioHelper.prototype._updateDevices = function (updatedDevices, availableDevices, removeLostDevice) {\n    var _this = this;\n\n    var updatedDeviceIds = updatedDevices.map(function (d) {\n      return d.deviceId;\n    });\n    var knownDeviceIds = Array.from(availableDevices.values()).map(function (d) {\n      return d.deviceId;\n    });\n    var lostActiveDevices = []; // Remove lost devices\n\n    var lostDeviceIds = util_1.difference(knownDeviceIds, updatedDeviceIds);\n    lostDeviceIds.forEach(function (lostDeviceId) {\n      var lostDevice = availableDevices.get(lostDeviceId);\n\n      if (lostDevice) {\n        availableDevices.delete(lostDeviceId);\n\n        if (removeLostDevice(lostDevice)) {\n          lostActiveDevices.push(lostDevice);\n        }\n      }\n    }); // Add any new devices, or devices with updated labels\n\n    var deviceChanged = false;\n    updatedDevices.forEach(function (newDevice) {\n      var existingDevice = availableDevices.get(newDevice.deviceId);\n\n      var newMediaDeviceInfo = _this._wrapMediaDeviceInfo(newDevice);\n\n      if (!existingDevice || existingDevice.label !== newMediaDeviceInfo.label) {\n        availableDevices.set(newDevice.deviceId, newMediaDeviceInfo);\n        deviceChanged = true;\n      }\n    });\n\n    if (deviceChanged || lostDeviceIds.length) {\n      // Force a new gUM in case the underlying tracks of the active stream have changed. One\n      //   reason this might happen is when `default` is selected and set to a USB device,\n      //   then that device is unplugged or plugged back in. We can't check for the 'ended'\n      //   event or readyState because it is asynchronous and may take upwards of 5 seconds,\n      //   in my testing. (rrowland)\n      if (this.inputDevice !== null && this.inputDevice.deviceId === 'default') {\n        this._log.warn(\"Calling getUserMedia after device change to ensure that the           tracks of the active device (default) have not gone stale.\");\n\n        this._setInputDevice(this.inputDevice.deviceId, true);\n      }\n\n      this.emit('deviceChange', lostActiveDevices);\n    }\n  };\n  /**\n   * Disconnect the old input volume source, and create and connect a new one with the current\n   * input stream.\n   */\n\n\n  AudioHelper.prototype._updateVolumeSource = function () {\n    if (!this._inputStream || !this._audioContext || !this._inputVolumeAnalyser) {\n      return;\n    }\n\n    if (this._inputVolumeSource) {\n      this._inputVolumeSource.disconnect();\n    }\n\n    this._inputVolumeSource = this._audioContext.createMediaStreamSource(this._inputStream);\n\n    this._inputVolumeSource.connect(this._inputVolumeAnalyser);\n  };\n  /**\n   * Convert a MediaDeviceInfo to a IMediaDeviceInfoShim.\n   * @param mediaDeviceInfo - The info to convert\n   * @returns The converted shim\n   */\n\n\n  AudioHelper.prototype._wrapMediaDeviceInfo = function (mediaDeviceInfo) {\n    var options = {\n      deviceId: mediaDeviceInfo.deviceId,\n      groupId: mediaDeviceInfo.groupId,\n      kind: mediaDeviceInfo.kind,\n      label: mediaDeviceInfo.label\n    };\n\n    if (!options.label) {\n      if (options.deviceId === 'default') {\n        options.label = 'Default';\n      } else {\n        var index = this._getUnknownDeviceIndex(mediaDeviceInfo);\n\n        options.label = \"Unknown \" + kindAliases[options.kind] + \" Device \" + index;\n      }\n    }\n\n    return new MediaDeviceInfoShim(options);\n  };\n\n  return AudioHelper;\n}(events_1.EventEmitter);\n\n(function (AudioHelper) {})(AudioHelper || (AudioHelper = {}));\n\nexports.default = AudioHelper; //# sourceMappingURL=audiohelper.js.map","map":null,"metadata":{},"sourceType":"script"}