{"ast":null,"code":"import { SessionManager } from \"../session-manager/session-manager.js\";\n/**\n * A simple SIP user class.\n * @remarks\n * While this class is completely functional for simple use cases, it is not intended\n * to provide an interface which is suitable for most (must less all) applications.\n * While this class has many limitations (for example, it only handles a single concurrent session),\n * it is, however, intended to serve as a simple example of using the SIP.js API.\n * @public\n */\n\nexport class SimpleUser {\n  /**\n   * Constructs a new instance of the `SimpleUser` class.\n   * @param server - SIP WebSocket Server URL.\n   * @param options - Options bucket. See {@link SimpleUserOptions} for details.\n   */\n  constructor(server) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.session = undefined; // Delegate\n\n    this.delegate = options.delegate; // Copy options\n\n    this.options = Object.assign({}, options); // Session manager options\n\n    const sessionManagerOptions = {\n      aor: this.options.aor,\n      delegate: {\n        onCallAnswered: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallAnswered) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onCallCreated: session => {\n          var _a, _b;\n\n          this.session = session;\n          (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallCreated) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onCallReceived: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallReceived) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onCallHangup: () => {\n          var _a, _b;\n\n          this.session = undefined;\n          ((_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallHangup) && ((_b = this.delegate) === null || _b === void 0 ? void 0 : _b.onCallHangup());\n        },\n        onCallHold: (s, held) => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallHold) === null || _b === void 0 ? void 0 : _b.call(_a, held);\n        },\n        onCallDTMFReceived: (s, tone, dur) => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onCallDTMFReceived) === null || _b === void 0 ? void 0 : _b.call(_a, tone, dur);\n        },\n        onMessageReceived: message => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onMessageReceived) === null || _b === void 0 ? void 0 : _b.call(_a, message.request.body);\n        },\n        onRegistered: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onRegistered) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onUnregistered: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onUnregistered) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onServerConnect: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onServerConnect) === null || _b === void 0 ? void 0 : _b.call(_a);\n        },\n        onServerDisconnect: () => {\n          var _a, _b;\n\n          return (_b = (_a = this.delegate) === null || _a === void 0 ? void 0 : _a.onServerDisconnect) === null || _b === void 0 ? void 0 : _b.call(_a);\n        }\n      },\n      maxSimultaneousSessions: 1,\n      media: this.options.media,\n      reconnectionAttempts: this.options.reconnectionAttempts,\n      reconnectionDelay: this.options.reconnectionDelay,\n      registererOptions: this.options.registererOptions,\n      sendDTMFUsingSessionDescriptionHandler: this.options.sendDTMFUsingSessionDescriptionHandler,\n      userAgentOptions: this.options.userAgentOptions\n    };\n    this.sessionManager = new SessionManager(server, sessionManagerOptions); // Use the SIP.js logger\n\n    this.logger = this.sessionManager.userAgent.getLogger(\"sip.SimpleUser\");\n  }\n  /**\n   * Instance identifier.\n   * @internal\n   */\n\n\n  get id() {\n    return this.options.userAgentOptions && this.options.userAgentOptions.displayName || \"Anonymous\";\n  }\n  /** The local media stream. Undefined if call not answered. */\n\n\n  get localMediaStream() {\n    return this.session && this.sessionManager.getLocalMediaStream(this.session);\n  }\n  /** The remote media stream. Undefined if call not answered. */\n\n\n  get remoteMediaStream() {\n    return this.session && this.sessionManager.getRemoteMediaStream(this.session);\n  }\n  /**\n   * The local audio track, if available.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  get localAudioTrack() {\n    return this.session && this.sessionManager.getLocalAudioTrack(this.session);\n  }\n  /**\n   * The local video track, if available.\n   * @deprecated Use localMediaStream and get track from the stream.\n   */\n\n\n  get localVideoTrack() {\n    return this.session && this.sessionManager.getLocalVideoTrack(this.session);\n  }\n  /**\n   * The remote audio track, if available.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  get remoteAudioTrack() {\n    return this.session && this.sessionManager.getRemoteAudioTrack(this.session);\n  }\n  /**\n   * The remote video track, if available.\n   * @deprecated Use remoteMediaStream and get track from the stream.\n   */\n\n\n  get remoteVideoTrack() {\n    return this.session && this.sessionManager.getRemoteVideoTrack(this.session);\n  }\n  /**\n   * Connect.\n   * @remarks\n   * Start the UserAgent's WebSocket Transport.\n   */\n\n\n  connect() {\n    this.logger.log(`[${this.id}] Connecting UserAgent...`);\n    return this.sessionManager.connect();\n  }\n  /**\n   * Disconnect.\n   * @remarks\n   * Stop the UserAgent's WebSocket Transport.\n   */\n\n\n  disconnect() {\n    this.logger.log(`[${this.id}] Disconnecting UserAgent...`);\n    return this.sessionManager.disconnect();\n  }\n  /**\n   * Return true if connected.\n   */\n\n\n  isConnected() {\n    return this.sessionManager.isConnected();\n  }\n  /**\n   * Start receiving incoming calls.\n   * @remarks\n   * Send a REGISTER request for the UserAgent's AOR.\n   * Resolves when the REGISTER request is sent, otherwise rejects.\n   */\n\n\n  register(registererRegisterOptions) {\n    this.logger.log(`[${this.id}] Registering UserAgent...`);\n    return this.sessionManager.register(registererRegisterOptions);\n  }\n  /**\n   * Stop receiving incoming calls.\n   * @remarks\n   * Send an un-REGISTER request for the UserAgent's AOR.\n   * Resolves when the un-REGISTER request is sent, otherwise rejects.\n   */\n\n\n  unregister(registererUnregisterOptions) {\n    this.logger.log(`[${this.id}] Unregistering UserAgent...`);\n    return this.sessionManager.unregister(registererUnregisterOptions);\n  }\n  /**\n   * Make an outgoing call.\n   * @remarks\n   * Send an INVITE request to create a new Session.\n   * Resolves when the INVITE request is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if Session is established.\n   * @param destination - The target destination to call. A SIP address to send the INVITE to.\n   * @param inviterOptions - Optional options for Inviter constructor.\n   * @param inviterInviteOptions - Optional options for Inviter.invite().\n   */\n\n\n  call(destination, inviterOptions, inviterInviteOptions) {\n    this.logger.log(`[${this.id}] Beginning Session...`);\n\n    if (this.session) {\n      return Promise.reject(new Error(\"Session already exists.\"));\n    }\n\n    return this.sessionManager.call(destination, inviterOptions, inviterInviteOptions).then(() => {\n      return;\n    });\n  }\n  /**\n   * Hangup a call.\n   * @remarks\n   * Send a BYE request, CANCEL request or reject response to end the current Session.\n   * Resolves when the request/response is sent, otherwise rejects.\n   * Use `onCallHangup` delegate method to determine if and when call is ended.\n   */\n\n\n  hangup() {\n    this.logger.log(`[${this.id}] Hangup...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.hangup(this.session).then(() => {\n      this.session = undefined;\n    });\n  }\n  /**\n   * Answer an incoming call.\n   * @remarks\n   * Accept an incoming INVITE request creating a new Session.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallAnswered` delegate method to determine if and when call is established.\n   * @param invitationAcceptOptions - Optional options for Inviter.accept().\n   */\n\n\n  answer(invitationAcceptOptions) {\n    this.logger.log(`[${this.id}] Accepting Invitation...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.answer(this.session, invitationAcceptOptions);\n  }\n  /**\n   * Decline an incoming call.\n   * @remarks\n   * Reject an incoming INVITE request.\n   * Resolves with the response is sent, otherwise rejects.\n   * Use `onCallHangup` delegate method to determine if and when call is ended.\n   */\n\n\n  decline() {\n    this.logger.log(`[${this.id}] rejecting Invitation...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.decline(this.session);\n  }\n  /**\n   * Hold call\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"hold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  hold() {\n    this.logger.log(`[${this.id}] holding session...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.hold(this.session);\n  }\n  /**\n   * Unhold call.\n   * @remarks\n   * Send a re-INVITE with new offer indicating \"unhold\".\n   * Resolves when the re-INVITE request is sent, otherwise rejects.\n   * Use `onCallHold` delegate method to determine if request is accepted or rejected.\n   * See: https://tools.ietf.org/html/rfc6337\n   */\n\n\n  unhold() {\n    this.logger.log(`[${this.id}] unholding session...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.unhold(this.session);\n  }\n  /**\n   * Hold state.\n   * @remarks\n   * True if session is on hold.\n   */\n\n\n  isHeld() {\n    return this.session ? this.sessionManager.isHeld(this.session) : false;\n  }\n  /**\n   * Mute call.\n   * @remarks\n   * Disable sender's media tracks.\n   */\n\n\n  mute() {\n    this.logger.log(`[${this.id}] disabling media tracks...`);\n    return this.session && this.sessionManager.mute(this.session);\n  }\n  /**\n   * Unmute call.\n   * @remarks\n   * Enable sender's media tracks.\n   */\n\n\n  unmute() {\n    this.logger.log(`[${this.id}] enabling media tracks...`);\n    return this.session && this.sessionManager.unmute(this.session);\n  }\n  /**\n   * Mute state.\n   * @remarks\n   * True if sender's media track is disabled.\n   */\n\n\n  isMuted() {\n    return this.session ? this.sessionManager.isMuted(this.session) : false;\n  }\n  /**\n   * Send DTMF.\n   * @remarks\n   * Send an INFO request with content type application/dtmf-relay.\n   * @param tone - Tone to send.\n   */\n\n\n  sendDTMF(tone) {\n    this.logger.log(`[${this.id}] sending DTMF...`);\n\n    if (!this.session) {\n      return Promise.reject(new Error(\"Session does not exist.\"));\n    }\n\n    return this.sessionManager.sendDTMF(this.session, tone);\n  }\n  /**\n   * Send a message.\n   * @remarks\n   * Send a MESSAGE request.\n   * @param destination - The target destination for the message. A SIP address to send the MESSAGE to.\n   */\n\n\n  message(destination, message) {\n    this.logger.log(`[${this.id}] sending message...`);\n    return this.sessionManager.message(destination, message);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}