{"ast":null,"code":"import { Grammar } from \"../grammar/grammar.js\";\nimport { fromBodyLegacy, getBody } from \"../core/messages/body.js\";\nimport { SignalingState } from \"../core/session/session.js\";\nimport { Timers } from \"../core/timers.js\";\nimport { TransactionStateError } from \"../core/exceptions/transaction-state-error.js\";\nimport { getReasonPhrase } from \"../core/messages/utils.js\";\nimport { Cancel } from \"./cancel.js\";\nimport { ContentTypeUnsupportedError } from \"./exceptions/content-type-unsupported.js\";\nimport { SessionDescriptionHandlerError } from \"./exceptions/session-description-handler.js\";\nimport { SessionTerminatedError } from \"./exceptions/session-terminated.js\";\nimport { Session } from \"./session.js\";\nimport { SessionState } from \"./session-state.js\";\nimport { SIPExtension } from \"./user-agent-options.js\";\n/**\n * An invitation is an offer to establish a {@link Session} (incoming INVITE).\n * @public\n */\n\nexport class Invitation extends Session {\n  /** @internal */\n  constructor(userAgent, incomingInviteRequest) {\n    super(userAgent);\n    this.incomingInviteRequest = incomingInviteRequest;\n    /** True if dispose() has been called. */\n\n    this.disposed = false;\n    /** INVITE will be rejected if not accepted within a certain period time. */\n\n    this.expiresTimer = undefined;\n    /** True if this Session has been Terminated due to a CANCEL request. */\n\n    this.isCanceled = false;\n    /** Are reliable provisional responses required or supported. */\n\n    this.rel100 = \"none\";\n    /** The current RSeq header value. */\n\n    this.rseq = Math.floor(Math.random() * 10000);\n    /** INVITE will be rejected if final response not sent in a certain period time. */\n\n    this.userNoAnswerTimer = undefined;\n    /** True if waiting for a PRACK before sending a 200 Ok. */\n\n    this.waitingForPrack = false;\n    this.logger = userAgent.getLogger(\"sip.Invitation\");\n    const incomingRequestMessage = this.incomingInviteRequest.message; // Set 100rel if necessary\n\n    const requireHeader = incomingRequestMessage.getHeader(\"require\");\n\n    if (requireHeader && requireHeader.toLowerCase().includes(\"100rel\")) {\n      this.rel100 = \"required\";\n    }\n\n    const supportedHeader = incomingRequestMessage.getHeader(\"supported\");\n\n    if (supportedHeader && supportedHeader.toLowerCase().includes(\"100rel\")) {\n      this.rel100 = \"supported\";\n    } // FIXME: HACK: This is a hack to port an existing behavior.\n    // Set the toTag on the incoming request message to the toTag which\n    // will be used in the response to the incoming request!!!\n    // The behavior being ported appears to be a hack itself,\n    // so this is a hack to port a hack. At least one test spec\n    // relies on it (which is yet another hack).\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n    incomingRequestMessage.toTag = incomingInviteRequest.toTag;\n\n    if (typeof incomingRequestMessage.toTag !== \"string\") {\n      throw new TypeError(\"toTag should have been a string.\");\n    } // The following mapping values are RECOMMENDED:\n    // ...\n    // 19 no answer from the user              480 Temporarily unavailable\n    // https://tools.ietf.org/html/rfc3398#section-7.2.4.1\n\n\n    this.userNoAnswerTimer = setTimeout(() => {\n      incomingInviteRequest.reject({\n        statusCode: 480\n      });\n      this.stateTransition(SessionState.Terminated);\n    }, this.userAgent.configuration.noAnswerTimeout ? this.userAgent.configuration.noAnswerTimeout * 1000 : 60000); // 1. If the request is an INVITE that contains an Expires header\n    // field, the UAS core sets a timer for the number of seconds\n    // indicated in the header field value.  When the timer fires, the\n    // invitation is considered to be expired.  If the invitation\n    // expires before the UAS has generated a final response, a 487\n    // (Request Terminated) response SHOULD be generated.\n    // https://tools.ietf.org/html/rfc3261#section-13.3.1\n\n    if (incomingRequestMessage.hasHeader(\"expires\")) {\n      const expires = Number(incomingRequestMessage.getHeader(\"expires\") || 0) * 1000;\n      this.expiresTimer = setTimeout(() => {\n        if (this.state === SessionState.Initial) {\n          incomingInviteRequest.reject({\n            statusCode: 487\n          });\n          this.stateTransition(SessionState.Terminated);\n        }\n      }, expires);\n    } // Session parent properties\n\n\n    const assertedIdentity = this.request.getHeader(\"P-Asserted-Identity\");\n\n    if (assertedIdentity) {\n      this._assertedIdentity = Grammar.nameAddrHeaderParse(assertedIdentity);\n    }\n\n    this._contact = this.userAgent.contact.toString();\n    const contentDisposition = incomingRequestMessage.parseHeader(\"Content-Disposition\");\n\n    if (contentDisposition && contentDisposition.type === \"render\") {\n      this._renderbody = incomingRequestMessage.body;\n      this._rendertype = incomingRequestMessage.getHeader(\"Content-Type\");\n    } // Identifier\n\n\n    this._id = incomingRequestMessage.callId + incomingRequestMessage.fromTag; // Add to the user agent's session collection.\n\n    this.userAgent._sessions[this._id] = this;\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    // Only run through this once. It can and does get called multiple times\n    // depending on the what the sessions state is when first called.\n    // For example, if called when \"establishing\" it will be called again\n    // at least once when the session transitions to \"terminated\".\n    // Regardless, running through this more than once is pointless.\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true; // Clear timers\n\n    if (this.expiresTimer) {\n      clearTimeout(this.expiresTimer);\n      this.expiresTimer = undefined;\n    }\n\n    if (this.userNoAnswerTimer) {\n      clearTimeout(this.userNoAnswerTimer);\n      this.userNoAnswerTimer = undefined;\n    } // If accept() is still waiting for a PRACK, make sure it rejects\n\n\n    this.prackNeverArrived(); // If the final response for the initial INVITE not yet been sent, reject it\n\n    switch (this.state) {\n      case SessionState.Initial:\n        return this.reject().then(() => super.dispose());\n\n      case SessionState.Establishing:\n        return this.reject().then(() => super.dispose());\n\n      case SessionState.Established:\n        return super.dispose();\n\n      case SessionState.Terminating:\n        return super.dispose();\n\n      case SessionState.Terminated:\n        return super.dispose();\n\n      default:\n        throw new Error(\"Unknown state.\");\n    }\n  }\n  /**\n   * If true, a first provisional response after the 100 Trying\n   * will be sent automatically. This is false it the UAC required\n   * reliable provisional responses (100rel in Require header) or\n   * the user agent configuration has specified to not send an\n   * initial response, otherwise it is true. The provisional is sent by\n   * calling `progress()` without any options.\n   */\n\n\n  get autoSendAnInitialProvisionalResponse() {\n    return this.rel100 !== \"required\" && this.userAgent.configuration.sendInitialProvisionalResponse;\n  }\n  /**\n   * Initial incoming INVITE request message body.\n   */\n\n\n  get body() {\n    return this.incomingInviteRequest.message.body;\n  }\n  /**\n   * The identity of the local user.\n   */\n\n\n  get localIdentity() {\n    return this.request.to;\n  }\n  /**\n   * The identity of the remote user.\n   */\n\n\n  get remoteIdentity() {\n    return this.request.from;\n  }\n  /**\n   * Initial incoming INVITE request message.\n   */\n\n\n  get request() {\n    return this.incomingInviteRequest.message;\n  }\n  /**\n   * Accept the invitation.\n   *\n   * @remarks\n   * Accept the incoming INVITE request to start a Session.\n   * Replies to the INVITE request with a 200 Ok response.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * This method may reject for a variety of reasons including\n   * the receipt of a CANCEL request before `accept` is able\n   * to construct a response.\n   * @param options - Options bucket.\n   */\n\n\n  accept() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Invitation.accept\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // transition state\n\n\n    this.stateTransition(SessionState.Establishing);\n    return this.sendAccept(options) // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    .then(_ref => {\n      let {\n        message,\n        session\n      } = _ref;\n      session.delegate = {\n        onAck: ackRequest => this.onAckRequest(ackRequest),\n        onAckTimeout: () => this.onAckTimeout(),\n        onBye: byeRequest => this.onByeRequest(byeRequest),\n        onInfo: infoRequest => this.onInfoRequest(infoRequest),\n        onInvite: inviteRequest => this.onInviteRequest(inviteRequest),\n        onMessage: messageRequest => this.onMessageRequest(messageRequest),\n        onNotify: notifyRequest => this.onNotifyRequest(notifyRequest),\n        onPrack: prackRequest => this.onPrackRequest(prackRequest),\n        onRefer: referRequest => this.onReferRequest(referRequest)\n      };\n      this._dialog = session;\n      this.stateTransition(SessionState.Established); // TODO: Reconsider this \"automagic\" send of a BYE to replacee behavior.\n      // This behavior has been ported forward from legacy versions.\n\n      if (this._replacee) {\n        this._replacee._bye();\n      }\n    }).catch(error => this.handleResponseError(error));\n  }\n  /**\n   * Indicate progress processing the invitation.\n   *\n   * @remarks\n   * Report progress to the the caller.\n   * Replies to the INVITE request with a 1xx provisional response.\n   * Resolves once the response sent, otherwise rejects.\n   * @param options - Options bucket.\n   */\n\n\n  progress() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Invitation.progress\"); // validate state\n\n    if (this.state !== SessionState.Initial) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    } // Ported\n\n\n    const statusCode = options.statusCode || 180;\n\n    if (statusCode < 100 || statusCode > 199) {\n      throw new TypeError(\"Invalid statusCode: \" + statusCode);\n    } // Modifiers and options for initial INVITE transaction\n\n\n    if (options.sessionDescriptionHandlerModifiers) {\n      this.sessionDescriptionHandlerModifiers = options.sessionDescriptionHandlerModifiers;\n    }\n\n    if (options.sessionDescriptionHandlerOptions) {\n      this.sessionDescriptionHandlerOptions = options.sessionDescriptionHandlerOptions;\n    } // After the first reliable provisional response for a request has been\n    // acknowledged, the UAS MAY send additional reliable provisional\n    // responses.  The UAS MUST NOT send a second reliable provisional\n    // response until the first is acknowledged.  After the first, it is\n    // RECOMMENDED that the UAS not send an additional reliable provisional\n    // response until the previous is acknowledged.  The first reliable\n    // provisional response receives special treatment because it conveys\n    // the initial sequence number.  If additional reliable provisional\n    // responses were sent before the first was acknowledged, the UAS could\n    // not be certain these were received in order.\n    // https://tools.ietf.org/html/rfc3262#section-3\n\n\n    if (this.waitingForPrack) {\n      this.logger.warn(\"Unexpected call for progress while waiting for prack, ignoring\");\n      return Promise.resolve();\n    } // Trying provisional response\n\n\n    if (options.statusCode === 100) {\n      return this.sendProgressTrying().then(() => {\n        return;\n      }).catch(error => this.handleResponseError(error));\n    } // Standard provisional response\n\n\n    if (!(this.rel100 === \"required\") && !(this.rel100 === \"supported\" && options.rel100) && !(this.rel100 === \"supported\" && this.userAgent.configuration.sipExtension100rel === SIPExtension.Required)) {\n      return this.sendProgress(options).then(() => {\n        return;\n      }).catch(error => this.handleResponseError(error));\n    } // Reliable provisional response\n\n\n    return this.sendProgressReliableWaitForPrack(options).then(() => {\n      return;\n    }).catch(error => this.handleResponseError(error));\n  }\n  /**\n   * Reject the invitation.\n   *\n   * @remarks\n   * Replies to the INVITE request with a 4xx, 5xx, or 6xx final response.\n   * Resolves once the response sent, otherwise rejects.\n   *\n   * The expectation is that this method is used to reject an INVITE request.\n   * That is indeed the case - a call to `progress` followed by `reject` is\n   * a typical way to \"decline\" an incoming INVITE request. However it may\n   * also be called after calling `accept` (but only before it completes)\n   * which will reject the call and cause `accept` to reject.\n   * @param options - Options bucket.\n   */\n\n\n  reject() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.logger.log(\"Invitation.reject\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      const error = new Error(`Invalid session state ${this.state}`);\n      this.logger.error(error.message);\n      return Promise.reject(error);\n    }\n\n    const statusCode = options.statusCode || 480;\n    const reasonPhrase = options.reasonPhrase ? options.reasonPhrase : getReasonPhrase(statusCode);\n    const extraHeaders = options.extraHeaders || [];\n\n    if (statusCode < 300 || statusCode > 699) {\n      throw new TypeError(\"Invalid statusCode: \" + statusCode);\n    }\n\n    const body = options.body ? fromBodyLegacy(options.body) : undefined; // FIXME: Need to redirect to someplace\n\n    statusCode < 400 ? this.incomingInviteRequest.redirect([], {\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    }) : this.incomingInviteRequest.reject({\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    });\n    this.stateTransition(SessionState.Terminated);\n    return Promise.resolve();\n  }\n  /**\n   * Handle CANCEL request.\n   *\n   * @param message - CANCEL message.\n   * @internal\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  _onCancel(message) {\n    this.logger.log(\"Invitation._onCancel\"); // validate state\n\n    if (this.state !== SessionState.Initial && this.state !== SessionState.Establishing) {\n      this.logger.error(`CANCEL received while in state ${this.state}, dropping request`);\n      return;\n    }\n\n    if (this.delegate && this.delegate.onCancel) {\n      const cancel = new Cancel(message);\n      this.delegate.onCancel(cancel);\n    } // flag canceled\n\n\n    this.isCanceled = true; // reject INVITE with 487 status code\n\n    this.incomingInviteRequest.reject({\n      statusCode: 487\n    });\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * Helper function to handle offer/answer in a PRACK.\n   */\n\n\n  handlePrackOfferAnswer(request) {\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    } // If the PRACK doesn't have an offer/answer, nothing to be done.\n\n\n    const body = getBody(request.message);\n\n    if (!body || body.contentDisposition !== \"session\") {\n      return Promise.resolve(undefined);\n    }\n\n    const options = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    }; // If the UAC receives a reliable provisional response with an offer\n    // (this would occur if the UAC sent an INVITE without an offer, in\n    // which case the first reliable provisional response will contain the\n    // offer), it MUST generate an answer in the PRACK.  If the UAC receives\n    // a reliable provisional response with an answer, it MAY generate an\n    // additional offer in the PRACK.  If the UAS receives a PRACK with an\n    // offer, it MUST place the answer in the 2xx to the PRACK.\n    // https://tools.ietf.org/html/rfc3262#section-5\n\n    switch (this.dialog.signalingState) {\n      case SignalingState.Initial:\n        // State should never be reached as first reliable provisional response must have answer/offer.\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      case SignalingState.Stable:\n        // Receved answer.\n        return this.setAnswer(body, options).then(() => undefined);\n\n      case SignalingState.HaveLocalOffer:\n        // State should never be reached as local offer would be answered by this PRACK\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      case SignalingState.HaveRemoteOffer:\n        // Received offer, generate answer.\n        return this.setOfferAndGetAnswer(body, options);\n\n      case SignalingState.Closed:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n\n      default:\n        throw new Error(`Invalid signaling state ${this.dialog.signalingState}.`);\n    }\n  }\n  /**\n   * A handler for errors which occur while attempting to send 1xx and 2xx responses.\n   * In all cases, an attempt is made to reject the request if it is still outstanding.\n   * And while there are a variety of things which can go wrong and we log something here\n   * for all errors, there are a handful of common exceptions we pay some extra attention to.\n   * @param error - The error which occurred.\n   */\n\n\n  handleResponseError(error) {\n    let statusCode = 480; // \"Temporarily Unavailable\"\n    // Log Error message\n\n    if (error instanceof Error) {\n      this.logger.error(error.message);\n    } else {\n      // We don't actually know what a session description handler implementation might throw our way,\n      // and more generally as a last resort catch all, just assume we are getting an \"unknown\" and log it.\n      this.logger.error(error);\n    } // Log Exception message\n\n\n    if (error instanceof ContentTypeUnsupportedError) {\n      this.logger.error(\"A session description handler occurred while sending response (content type unsupported\");\n      statusCode = 415; // \"Unsupported Media Type\"\n    } else if (error instanceof SessionDescriptionHandlerError) {\n      this.logger.error(\"A session description handler occurred while sending response\");\n    } else if (error instanceof SessionTerminatedError) {\n      this.logger.error(\"Session ended before response could be formulated and sent (while waiting for PRACK)\");\n    } else if (error instanceof TransactionStateError) {\n      this.logger.error(\"Session changed state before response could be formulated and sent\");\n    } // Reject if still in \"initial\" or \"establishing\" state.\n\n\n    if (this.state === SessionState.Initial || this.state === SessionState.Establishing) {\n      try {\n        this.incomingInviteRequest.reject({\n          statusCode\n        });\n        this.stateTransition(SessionState.Terminated);\n      } catch (e) {\n        this.logger.error(\"An error occurred attempting to reject the request while handling another error\");\n        throw e; // This is not a good place to be...\n      }\n    } // FIXME: TODO:\n    // Here we are squelching the throwing of errors due to an race condition.\n    // We have an internal race between calling `accept()` and handling an incoming\n    // CANCEL request. As there is no good way currently to delegate the handling of\n    // these race errors to the caller of `accept()`, we are squelching the throwing\n    // of ALL errors when/if they occur after receiving a CANCEL to catch the ONE we know\n    // is a \"normal\" exceptional condition. While this is a completely reasonable approach,\n    // the decision should be left up to the library user. Furthermore, as we are eating\n    // ALL errors in this case, we are potentially (likely) hiding \"real\" errors which occur.\n    //\n    // Only rethrow error if the session has not been canceled.\n\n\n    if (this.isCanceled) {\n      this.logger.warn(\"An error occurred while attempting to formulate and send a response to an incoming INVITE.\" + \" However a CANCEL was received and processed while doing so which can (and often does) result\" + \" in errors occurring as the session terminates in the meantime. Said error is being ignored.\");\n      return;\n    }\n\n    throw error;\n  }\n  /**\n   * Callback for when ACK for a 2xx response is never received.\n   * @param session - Session the ACK never arrived for.\n   */\n\n\n  onAckTimeout() {\n    this.logger.log(\"Invitation.onAckTimeout\");\n\n    if (!this.dialog) {\n      throw new Error(\"Dialog undefined.\");\n    }\n\n    this.logger.log(\"No ACK received for an extended period of time, terminating session\");\n    this.dialog.bye();\n    this.stateTransition(SessionState.Terminated);\n  }\n  /**\n   * A version of `accept` which resolves a session when the 200 Ok response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendAccept() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    };\n    const extraHeaders = options.extraHeaders || []; // The UAS MAY send a final response to the initial request before\n    // having received PRACKs for all unacknowledged reliable provisional\n    // responses, unless the final response is 2xx and any of the\n    // unacknowledged reliable provisional responses contained a session\n    // description.  In that case, it MUST NOT send a final response until\n    // those provisional responses are acknowledged.  If the UAS does send a\n    // final response when reliable responses are still unacknowledged, it\n    // SHOULD NOT continue to retransmit the unacknowledged reliable\n    // provisional responses, but it MUST be prepared to process PRACK\n    // requests for those outstanding responses.  A UAS MUST NOT send new\n    // reliable provisional responses (as opposed to retransmissions of\n    // unacknowledged ones) after sending a final response to a request.\n    // https://tools.ietf.org/html/rfc3262#section-3\n\n    if (this.waitingForPrack) {\n      return this.waitForArrivalOfPrack().then(() => clearTimeout(this.userNoAnswerTimer)) // Ported\n      .then(() => this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions)).then(body => this.incomingInviteRequest.accept({\n        statusCode: 200,\n        body,\n        extraHeaders\n      }));\n    }\n\n    clearTimeout(this.userNoAnswerTimer); // Ported\n\n    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(body => this.incomingInviteRequest.accept({\n      statusCode: 200,\n      body,\n      extraHeaders\n    }));\n  }\n  /**\n   * A version of `progress` which resolves when the provisional response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgress() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const statusCode = options.statusCode || 180;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice();\n    const body = options.body ? fromBodyLegacy(options.body) : undefined; // The 183 (Session Progress) response is used to convey information\n    // about the progress of the call that is not otherwise classified.  The\n    // Reason-Phrase, header fields, or message body MAY be used to convey\n    // more details about the call progress.\n    // https://tools.ietf.org/html/rfc3261#section-21.1.5\n    // It is the de facto industry standard to utilize 183 with SDP to provide \"early media\".\n    // While it is unlikely someone would want to send a 183 without SDP, so it should be an option.\n\n    if (statusCode === 183 && !body) {\n      return this.sendProgressWithSDP(options);\n    }\n\n    try {\n      const progressResponse = this.incomingInviteRequest.progress({\n        statusCode,\n        reasonPhrase,\n        extraHeaders,\n        body\n      });\n      this._dialog = progressResponse.session;\n      return Promise.resolve(progressResponse);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * A version of `progress` which resolves when the provisional response with sdp is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressWithSDP() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    };\n    const statusCode = options.statusCode || 183;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice(); // Get an offer/answer and send a reply.\n\n    return this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(body => this.incomingInviteRequest.progress({\n      statusCode,\n      reasonPhrase,\n      extraHeaders,\n      body\n    })).then(progressResponse => {\n      this._dialog = progressResponse.session;\n      return progressResponse;\n    });\n  }\n  /**\n   * A version of `progress` which resolves when the reliable provisional response is sent.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressReliable() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    options.extraHeaders = (options.extraHeaders || []).slice();\n    options.extraHeaders.push(\"Require: 100rel\");\n    options.extraHeaders.push(\"RSeq: \" + Math.floor(Math.random() * 10000));\n    return this.sendProgressWithSDP(options);\n  }\n  /**\n   * A version of `progress` which resolves when the reliable provisional response is acknowledged.\n   * @param options - Options bucket.\n   */\n\n\n  sendProgressReliableWaitForPrack() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const responseOptions = {\n      sessionDescriptionHandlerOptions: this.sessionDescriptionHandlerOptions,\n      sessionDescriptionHandlerModifiers: this.sessionDescriptionHandlerModifiers\n    };\n    const statusCode = options.statusCode || 183;\n    const reasonPhrase = options.reasonPhrase;\n    const extraHeaders = (options.extraHeaders || []).slice();\n    extraHeaders.push(\"Require: 100rel\");\n    extraHeaders.push(\"RSeq: \" + this.rseq++);\n    let body;\n    return new Promise((resolve, reject) => {\n      this.waitingForPrack = true;\n      this.generateResponseOfferAnswer(this.incomingInviteRequest, responseOptions).then(offerAnswer => {\n        body = offerAnswer;\n        return this.incomingInviteRequest.progress({\n          statusCode,\n          reasonPhrase,\n          extraHeaders,\n          body\n        });\n      }).then(progressResponse => {\n        this._dialog = progressResponse.session;\n        let prackRequest;\n        let prackResponse;\n        progressResponse.session.delegate = {\n          onPrack: request => {\n            prackRequest = request; // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n            clearTimeout(prackWaitTimeoutTimer); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n            clearTimeout(rel1xxRetransmissionTimer);\n\n            if (!this.waitingForPrack) {\n              return;\n            }\n\n            this.waitingForPrack = false;\n            this.handlePrackOfferAnswer(prackRequest).then(prackResponseBody => {\n              try {\n                prackResponse = prackRequest.accept({\n                  statusCode: 200,\n                  body: prackResponseBody\n                });\n                this.prackArrived();\n                resolve({\n                  prackRequest,\n                  prackResponse,\n                  progressResponse\n                });\n              } catch (error) {\n                reject(error);\n              }\n            }).catch(error => reject(error));\n          }\n        }; // https://tools.ietf.org/html/rfc3262#section-3\n\n        const prackWaitTimeout = () => {\n          if (!this.waitingForPrack) {\n            return;\n          }\n\n          this.waitingForPrack = false;\n          this.logger.warn(\"No PRACK received, rejecting INVITE.\"); // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n          clearTimeout(rel1xxRetransmissionTimer);\n          this.reject({\n            statusCode: 504\n          }).then(() => reject(new SessionTerminatedError())).catch(error => reject(error));\n        };\n\n        const prackWaitTimeoutTimer = setTimeout(prackWaitTimeout, Timers.T1 * 64); // https://tools.ietf.org/html/rfc3262#section-3\n\n        const rel1xxRetransmission = () => {\n          try {\n            this.incomingInviteRequest.progress({\n              statusCode,\n              reasonPhrase,\n              extraHeaders,\n              body\n            });\n          } catch (error) {\n            this.waitingForPrack = false;\n            reject(error);\n            return;\n          } // eslint-disable-next-line @typescript-eslint/no-use-before-define\n\n\n          rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout *= 2);\n        };\n\n        let timeout = Timers.T1;\n        let rel1xxRetransmissionTimer = setTimeout(rel1xxRetransmission, timeout);\n      }).catch(error => {\n        this.waitingForPrack = false;\n        reject(error);\n      });\n    });\n  }\n  /**\n   * A version of `progress` which resolves when a 100 Trying provisional response is sent.\n   */\n\n\n  sendProgressTrying() {\n    try {\n      const progressResponse = this.incomingInviteRequest.trying();\n      return Promise.resolve(progressResponse);\n    } catch (error) {\n      return Promise.reject(error);\n    }\n  }\n  /**\n   * When attempting to accept the INVITE, an invitation waits\n   * for any outstanding PRACK to arrive before sending the 200 Ok.\n   * It will be waiting on this Promise to resolve which lets it know\n   * the PRACK has arrived and it may proceed to send the 200 Ok.\n   */\n\n\n  waitForArrivalOfPrack() {\n    if (this.waitingForPrackPromise) {\n      throw new Error(\"Already waiting for PRACK\");\n    }\n\n    this.waitingForPrackPromise = new Promise((resolve, reject) => {\n      this.waitingForPrackResolve = resolve;\n      this.waitingForPrackReject = reject;\n    });\n    return this.waitingForPrackPromise;\n  }\n  /**\n   * Here we are resolving the promise which in turn will cause\n   * the accept to proceed (it may still fail for other reasons, but...).\n   */\n\n\n  prackArrived() {\n    if (this.waitingForPrackResolve) {\n      this.waitingForPrackResolve();\n    }\n\n    this.waitingForPrackPromise = undefined;\n    this.waitingForPrackResolve = undefined;\n    this.waitingForPrackReject = undefined;\n  }\n  /**\n   * Here we are rejecting the promise which in turn will cause\n   * the accept to fail and the session to transition to \"terminated\".\n   */\n\n\n  prackNeverArrived() {\n    if (this.waitingForPrackReject) {\n      this.waitingForPrackReject(new SessionTerminatedError());\n    }\n\n    this.waitingForPrackPromise = undefined;\n    this.waitingForPrackResolve = undefined;\n    this.waitingForPrackReject = undefined;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}