{"ast":null,"code":"import { Grammar } from \"../grammar/grammar.js\";\nimport { equivalentURI, URI } from \"../grammar/uri.js\";\nimport { C } from \"../core/messages/methods/constants.js\";\nimport { EmitterImpl } from \"./emitter.js\";\nimport { RequestPendingError } from \"./exceptions/request-pending.js\";\nimport { RegistererState } from \"./registerer-state.js\";\n/**\n * A registerer registers a contact for an address of record (outgoing REGISTER).\n * @public\n */\n\nexport class Registerer {\n  /**\n   * Constructs a new instance of the `Registerer` class.\n   * @param userAgent - User agent. See {@link UserAgent} for details.\n   * @param options - Options bucket. See {@link RegistererOptions} for details.\n   */\n  constructor(userAgent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.disposed = false;\n    /** The contacts returned from the most recent accepted REGISTER request. */\n\n    this._contacts = [];\n    /** The number of seconds to wait before retrying to register. */\n\n    this._retryAfter = undefined;\n    /** The registration state. */\n\n    this._state = RegistererState.Initial;\n    /** True is waiting for final response to outstanding REGISTER request. */\n\n    this._waiting = false; // state emitter\n\n    this._stateEventEmitter = new EmitterImpl(); // waiting emitter\n\n    this._waitingEventEmitter = new EmitterImpl(); // Set user agent\n\n    this.userAgent = userAgent; // Default registrar is domain portion of user agent uri\n\n    const defaultUserAgentRegistrar = userAgent.configuration.uri.clone();\n    defaultUserAgentRegistrar.user = undefined; // Initialize configuration\n\n    this.options = Object.assign(Object.assign(Object.assign({}, Registerer.defaultOptions()), {\n      registrar: defaultUserAgentRegistrar\n    }), Registerer.stripUndefinedProperties(options)); // Make sure we are not using references to array options\n\n    this.options.extraContactHeaderParams = (this.options.extraContactHeaderParams || []).slice();\n    this.options.extraHeaders = (this.options.extraHeaders || []).slice(); // Make sure we are not using references to registrar uri\n\n    if (!this.options.registrar) {\n      throw new Error(\"Registrar undefined.\");\n    }\n\n    this.options.registrar = this.options.registrar.clone(); // Set instanceId and regId conditional defaults and validate\n\n    if (this.options.regId && !this.options.instanceId) {\n      this.options.instanceId = this.userAgent.instanceId;\n    } else if (!this.options.regId && this.options.instanceId) {\n      this.options.regId = 1;\n    }\n\n    if (this.options.instanceId && Grammar.parse(this.options.instanceId, \"uuid\") === -1) {\n      throw new Error(\"Invalid instanceId.\");\n    }\n\n    if (this.options.regId && this.options.regId < 0) {\n      throw new Error(\"Invalid regId.\");\n    }\n\n    const registrar = this.options.registrar;\n    const fromURI = this.options.params && this.options.params.fromUri || userAgent.userAgentCore.configuration.aor;\n    const toURI = this.options.params && this.options.params.toUri || userAgent.configuration.uri;\n    const params = this.options.params || {};\n    const extraHeaders = (options.extraHeaders || []).slice(); // Build the request\n\n    this.request = userAgent.userAgentCore.makeOutgoingRequestMessage(C.REGISTER, registrar, fromURI, toURI, params, extraHeaders, undefined); // Registration expires\n\n    this.expires = this.options.expires || Registerer.defaultExpires;\n\n    if (this.expires < 0) {\n      throw new Error(\"Invalid expires.\");\n    } // Interval at which re-REGISTER requests are sent\n\n\n    this.refreshFrequency = this.options.refreshFrequency || Registerer.defaultRefreshFrequency;\n\n    if (this.refreshFrequency < 50 || this.refreshFrequency > 99) {\n      throw new Error(\"Invalid refresh frequency. The value represents a percentage of the expiration time and should be between 50 and 99.\");\n    } // initialize logger\n\n\n    this.logger = userAgent.getLogger(\"sip.Registerer\");\n\n    if (this.options.logConfiguration) {\n      this.logger.log(\"Configuration:\");\n      Object.keys(this.options).forEach(key => {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        const value = this.options[key];\n\n        switch (key) {\n          case \"registrar\":\n            this.logger.log(\"· \" + key + \": \" + value);\n            break;\n\n          default:\n            this.logger.log(\"· \" + key + \": \" + JSON.stringify(value));\n        }\n      });\n    } // Identifier\n\n\n    this.id = this.request.callId + this.request.from.parameters.tag; // Add to the user agent's session collection.\n\n    this.userAgent._registerers[this.id] = this;\n  }\n  /** Default registerer options. */\n\n\n  static defaultOptions() {\n    return {\n      expires: Registerer.defaultExpires,\n      extraContactHeaderParams: [],\n      extraHeaders: [],\n      logConfiguration: true,\n      instanceId: \"\",\n      params: {},\n      regId: 0,\n      registrar: new URI(\"sip\", \"anonymous\", \"anonymous.invalid\"),\n      refreshFrequency: Registerer.defaultRefreshFrequency\n    };\n  }\n  /**\n   * Strip properties with undefined values from options.\n   * This is a work around while waiting for missing vs undefined to be addressed (or not)...\n   * https://github.com/Microsoft/TypeScript/issues/13195\n   * @param options - Options to reduce\n   */\n\n\n  static stripUndefinedProperties(options) {\n    return Object.keys(options).reduce((object, key) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      if (options[key] !== undefined) {\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        object[key] = options[key];\n      }\n\n      return object;\n    }, {});\n  }\n  /** The registered contacts. */\n\n\n  get contacts() {\n    return this._contacts.slice();\n  }\n  /**\n   * The number of seconds to wait before retrying to register.\n   * @defaultValue `undefined`\n   * @remarks\n   * When the server rejects a registration request, if it provides a suggested\n   * duration to wait before retrying, that value is available here when and if\n   * the state transitions to `Unsubscribed`. It is also available during the\n   * callback to `onReject` after a call to `register`. (Note that if the state\n   * if already `Unsubscribed`, a rejected request created by `register` will\n   * not cause the state to transition to `Unsubscribed`. One way to avoid this\n   * case is to dispose of `Registerer` when unregistered and create a new\n   * `Registerer` for any attempts to retry registering.)\n   * @example\n   * ```ts\n   * // Checking for retry after on state change\n   * registerer.stateChange.addListener((newState) => {\n   *   switch (newState) {\n   *     case RegistererState.Unregistered:\n   *       const retryAfter = registerer.retryAfter;\n   *       break;\n   *   }\n   * });\n   *\n   * // Checking for retry after on request rejection\n   * registerer.register({\n   *   requestDelegate: {\n   *     onReject: () => {\n   *       const retryAfter = registerer.retryAfter;\n   *     }\n   *   }\n   * });\n   * ```\n   */\n\n\n  get retryAfter() {\n    return this._retryAfter;\n  }\n  /** The registration state. */\n\n\n  get state() {\n    return this._state;\n  }\n  /** Emits when the registerer state changes. */\n\n\n  get stateChange() {\n    return this._stateEventEmitter;\n  }\n  /** Destructor. */\n\n\n  dispose() {\n    if (this.disposed) {\n      return Promise.resolve();\n    }\n\n    this.disposed = true;\n    this.logger.log(`Registerer ${this.id} in state ${this.state} is being disposed`); // Remove from the user agent's registerer collection\n\n    delete this.userAgent._registerers[this.id]; // If registered, unregisters and resolves after final response received.\n\n    return new Promise(resolve => {\n      const doClose = () => {\n        // If we are registered, unregister and resolve after our state changes\n        if (!this.waiting && this._state === RegistererState.Registered) {\n          this.stateChange.addListener(() => {\n            this.terminated();\n            resolve();\n          }, {\n            once: true\n          });\n          this.unregister();\n          return;\n        } // Otherwise just resolve\n\n\n        this.terminated();\n        resolve();\n      }; // If we are waiting for an outstanding request, wait for it to finish and then try closing.\n      // Otherwise just try closing.\n\n\n      if (this.waiting) {\n        this.waitingChange.addListener(() => {\n          doClose();\n        }, {\n          once: true\n        });\n      } else {\n        doClose();\n      }\n    });\n  }\n  /**\n   * Sends the REGISTER request.\n   * @remarks\n   * If successful, sends re-REGISTER requests prior to registration expiration until `unsubscribe()` is called.\n   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n   */\n\n\n  register() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.state === RegistererState.Terminated) {\n      this.stateError();\n      throw new Error(\"Registerer terminated. Unable to register.\");\n    }\n\n    if (this.disposed) {\n      this.stateError();\n      throw new Error(\"Registerer disposed. Unable to register.\");\n    } // UAs MUST NOT send a new registration (that is, containing new Contact\n    // header field values, as opposed to a retransmission) until they have\n    // received a final response from the registrar for the previous one or\n    // the previous REGISTER request has timed out.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    if (this.waiting) {\n      this.waitingWarning();\n      const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n      return Promise.reject(error);\n    } // Options\n\n\n    if (options.requestOptions) {\n      this.options = Object.assign(Object.assign({}, this.options), options.requestOptions);\n    } // Extra headers\n\n\n    const extraHeaders = (this.options.extraHeaders || []).slice();\n    extraHeaders.push(\"Contact: \" + this.generateContactHeader(this.expires)); // this is UA.C.ALLOWED_METHODS, removed to get around circular dependency\n\n    extraHeaders.push(\"Allow: \" + [\"ACK\", \"CANCEL\", \"INVITE\", \"MESSAGE\", \"BYE\", \"OPTIONS\", \"INFO\", \"NOTIFY\", \"REFER\"].toString()); // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n    // header field value for registrations sent to a particular\n    // registrar.\n    //\n    // CSeq: The CSeq value guarantees proper ordering of REGISTER\n    // requests.  A UA MUST increment the CSeq value by one for each\n    // REGISTER request with the same Call-ID.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n    this.request.cseq++;\n    this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\");\n    this.request.extraHeaders = extraHeaders;\n    this.waitingToggle(true);\n    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n      onAccept: response => {\n        let expires; // FIXME: This does NOT appear to be to spec and should be removed.\n        // I haven't found anywhere that an Expires header may be used in a response.\n\n        if (response.message.hasHeader(\"expires\")) {\n          expires = Number(response.message.getHeader(\"expires\"));\n        } // 8. The registrar returns a 200 (OK) response.  The response MUST\n        // contain Contact header field values enumerating all current\n        // bindings.  Each Contact value MUST feature an \"expires\"\n        // parameter indicating its expiration interval chosen by the\n        // registrar.  The response SHOULD include a Date header field.\n        // https://tools.ietf.org/html/rfc3261#section-10.3\n\n\n        this._contacts = response.message.getHeaders(\"contact\");\n        let contacts = this._contacts.length;\n\n        if (!contacts) {\n          this.logger.error(\"No Contact header in response to REGISTER, dropping response.\");\n          this.unregistered();\n          return;\n        } // The 200 (OK) response from the registrar contains a list of Contact\n        // fields enumerating all current bindings.  The UA compares each\n        // contact address to see if it created the contact address, using\n        // comparison rules in Section 19.1.4.  If so, it updates the expiration\n        // time interval according to the expires parameter or, if absent, the\n        // Expires field value.  The UA then issues a REGISTER request for each\n        // of its bindings before the expiration interval has elapsed.\n        // https://tools.ietf.org/html/rfc3261#section-10.2.4\n\n\n        let contact;\n\n        while (contacts--) {\n          contact = response.message.parseHeader(\"contact\", contacts);\n\n          if (!contact) {\n            throw new Error(\"Contact undefined\");\n          }\n\n          if (this.userAgent.contact.pubGruu && equivalentURI(contact.uri, this.userAgent.contact.pubGruu)) {\n            expires = Number(contact.getParam(\"expires\"));\n            break;\n          } // If we are using a randomly generated user name (which is the default behavior)\n\n\n          if (this.userAgent.configuration.contactName === \"\") {\n            // compare the user portion of the URI under the assumption that it will be unique\n            if (contact.uri.user === this.userAgent.contact.uri.user) {\n              expires = Number(contact.getParam(\"expires\"));\n              break;\n            }\n          } else {\n            // otherwise use comparision rules in Section 19.1.4\n            if (equivalentURI(contact.uri, this.userAgent.contact.uri)) {\n              expires = Number(contact.getParam(\"expires\"));\n              break;\n            }\n          }\n\n          contact = undefined;\n        } // There must be a matching contact.\n\n\n        if (contact === undefined) {\n          this.logger.error(\"No Contact header pointing to us, dropping response\");\n          this.unregistered();\n          this.waitingToggle(false);\n          return;\n        } // The contact must have an expires.\n\n\n        if (expires === undefined) {\n          this.logger.error(\"Contact pointing to us is missing expires parameter, dropping response\");\n          this.unregistered();\n          this.waitingToggle(false);\n          return;\n        } // Save gruu values\n\n\n        if (contact.hasParam(\"temp-gruu\")) {\n          const gruu = contact.getParam(\"temp-gruu\");\n\n          if (gruu) {\n            this.userAgent.contact.tempGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n          }\n        }\n\n        if (contact.hasParam(\"pub-gruu\")) {\n          const gruu = contact.getParam(\"pub-gruu\");\n\n          if (gruu) {\n            this.userAgent.contact.pubGruu = Grammar.URIParse(gruu.replace(/\"/g, \"\"));\n          }\n        }\n\n        this.registered(expires);\n\n        if (options.requestDelegate && options.requestDelegate.onAccept) {\n          options.requestDelegate.onAccept(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onProgress: response => {\n        if (options.requestDelegate && options.requestDelegate.onProgress) {\n          options.requestDelegate.onProgress(response);\n        }\n      },\n      onRedirect: response => {\n        this.logger.error(\"Redirect received. Not supported.\");\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onReject: response => {\n        if (response.message.statusCode === 423) {\n          // If a UA receives a 423 (Interval Too Brief) response, it MAY retry\n          // the registration after making the expiration interval of all contact\n          // addresses in the REGISTER request equal to or greater than the\n          // expiration interval within the Min-Expires header field of the 423\n          // (Interval Too Brief) response.\n          // https://tools.ietf.org/html/rfc3261#section-10.2.8\n          //\n          // The registrar MAY choose an expiration less than the requested\n          // expiration interval.  If and only if the requested expiration\n          // interval is greater than zero AND smaller than one hour AND\n          // less than a registrar-configured minimum, the registrar MAY\n          // reject the registration with a response of 423 (Interval Too\n          // Brief).  This response MUST contain a Min-Expires header field\n          // that states the minimum expiration interval the registrar is\n          // willing to honor.  It then skips the remaining steps.\n          // https://tools.ietf.org/html/rfc3261#section-10.3\n          if (!response.message.hasHeader(\"min-expires\")) {\n            // This response MUST contain a Min-Expires header field\n            this.logger.error(\"423 response received for REGISTER without Min-Expires, dropping response\");\n            this.unregistered();\n            this.waitingToggle(false);\n            return;\n          } // Increase our registration interval to the suggested minimum\n\n\n          this.expires = Number(response.message.getHeader(\"min-expires\")); // Attempt the registration again immediately\n\n          this.waitingToggle(false);\n          this.register();\n          return;\n        }\n\n        this.logger.warn(`Failed to register, status code ${response.message.statusCode}`); // The Retry-After header field can be used with a 500 (Server Internal\n        // Error) or 503 (Service Unavailable) response to indicate how long the\n        // service is expected to be unavailable to the requesting client...\n        // https://tools.ietf.org/html/rfc3261#section-20.33\n\n        let retryAfterDuration = NaN;\n\n        if (response.message.statusCode === 500 || response.message.statusCode === 503) {\n          const header = response.message.getHeader(\"retry-after\");\n\n          if (header) {\n            retryAfterDuration = Number.parseInt(header, undefined);\n          }\n        } // Set for the state change (if any) and the delegate callback (if any)\n\n\n        this._retryAfter = isNaN(retryAfterDuration) ? undefined : retryAfterDuration;\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(response);\n        }\n\n        this._retryAfter = undefined;\n        this.waitingToggle(false);\n      },\n      onTrying: response => {\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(response);\n        }\n      }\n    });\n    return Promise.resolve(outgoingRegisterRequest);\n  }\n  /**\n   * Sends the REGISTER request with expires equal to zero.\n   * @remarks\n   * Rejects with `RequestPendingError` if a REGISTER request is already in progress.\n   */\n\n\n  unregister() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.state === RegistererState.Terminated) {\n      this.stateError();\n      throw new Error(\"Registerer terminated. Unable to register.\");\n    }\n\n    if (this.disposed) {\n      if (this.state !== RegistererState.Registered) {\n        // allows unregister while disposing and registered\n        this.stateError();\n        throw new Error(\"Registerer disposed. Unable to register.\");\n      }\n    } // UAs MUST NOT send a new registration (that is, containing new Contact\n    // header field values, as opposed to a retransmission) until they have\n    // received a final response from the registrar for the previous one or\n    // the previous REGISTER request has timed out.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    if (this.waiting) {\n      this.waitingWarning();\n      const error = new RequestPendingError(\"REGISTER request already in progress, waiting for final response\");\n      return Promise.reject(error);\n    }\n\n    if (this._state !== RegistererState.Registered && !options.all) {\n      this.logger.warn(\"Not currently registered, but sending an unregister anyway.\");\n    } // Extra headers\n\n\n    const extraHeaders = (options.requestOptions && options.requestOptions.extraHeaders || []).slice();\n    this.request.extraHeaders = extraHeaders; // Registrations are soft state and expire unless refreshed, but can\n    // also be explicitly removed.  A client can attempt to influence the\n    // expiration interval selected by the registrar as described in Section\n    // 10.2.1.  A UA requests the immediate removal of a binding by\n    // specifying an expiration interval of \"0\" for that contact address in\n    // a REGISTER request.  UAs SHOULD support this mechanism so that\n    // bindings can be removed before their expiration interval has passed.\n    //\n    // The REGISTER-specific Contact header field value of \"*\" applies to\n    // all registrations, but it MUST NOT be used unless the Expires header\n    // field is present with a value of \"0\".\n    // https://tools.ietf.org/html/rfc3261#section-10.2.2\n\n    if (options.all) {\n      extraHeaders.push(\"Contact: *\");\n      extraHeaders.push(\"Expires: 0\");\n    } else {\n      extraHeaders.push(\"Contact: \" + this.generateContactHeader(0));\n    } // Call-ID: All registrations from a UAC SHOULD use the same Call-ID\n    // header field value for registrations sent to a particular\n    // registrar.\n    //\n    // CSeq: The CSeq value guarantees proper ordering of REGISTER\n    // requests.  A UA MUST increment the CSeq value by one for each\n    // REGISTER request with the same Call-ID.\n    // https://tools.ietf.org/html/rfc3261#section-10.2\n\n\n    this.request.cseq++;\n    this.request.setHeader(\"cseq\", this.request.cseq + \" REGISTER\"); // Pre-emptive clear the registration timer to avoid a race condition where\n    // this timer fires while waiting for a final response to the unsubscribe.\n\n    if (this.registrationTimer !== undefined) {\n      clearTimeout(this.registrationTimer);\n      this.registrationTimer = undefined;\n    }\n\n    this.waitingToggle(true);\n    const outgoingRegisterRequest = this.userAgent.userAgentCore.register(this.request, {\n      onAccept: response => {\n        this._contacts = response.message.getHeaders(\"contact\"); // Update contacts\n\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onAccept) {\n          options.requestDelegate.onAccept(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onProgress: response => {\n        if (options.requestDelegate && options.requestDelegate.onProgress) {\n          options.requestDelegate.onProgress(response);\n        }\n      },\n      onRedirect: response => {\n        this.logger.error(\"Unregister redirected. Not currently supported.\");\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onRedirect) {\n          options.requestDelegate.onRedirect(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onReject: response => {\n        this.logger.error(`Unregister rejected with status code ${response.message.statusCode}`);\n        this.unregistered();\n\n        if (options.requestDelegate && options.requestDelegate.onReject) {\n          options.requestDelegate.onReject(response);\n        }\n\n        this.waitingToggle(false);\n      },\n      onTrying: response => {\n        if (options.requestDelegate && options.requestDelegate.onTrying) {\n          options.requestDelegate.onTrying(response);\n        }\n      }\n    });\n    return Promise.resolve(outgoingRegisterRequest);\n  }\n  /**\n   * Clear registration timers.\n   */\n\n\n  clearTimers() {\n    if (this.registrationTimer !== undefined) {\n      clearTimeout(this.registrationTimer);\n      this.registrationTimer = undefined;\n    }\n\n    if (this.registrationExpiredTimer !== undefined) {\n      clearTimeout(this.registrationExpiredTimer);\n      this.registrationExpiredTimer = undefined;\n    }\n  }\n  /**\n   * Generate Contact Header\n   */\n\n\n  generateContactHeader(expires) {\n    let contact = this.userAgent.contact.toString({\n      register: true\n    });\n\n    if (this.options.regId && this.options.instanceId) {\n      contact += \";reg-id=\" + this.options.regId;\n      contact += ';+sip.instance=\"<urn:uuid:' + this.options.instanceId + '>\"';\n    }\n\n    if (this.options.extraContactHeaderParams) {\n      this.options.extraContactHeaderParams.forEach(header => {\n        contact += \";\" + header;\n      });\n    }\n\n    contact += \";expires=\" + expires;\n    return contact;\n  }\n  /**\n   * Helper function, called when registered.\n   */\n\n\n  registered(expires) {\n    this.clearTimers(); // Re-Register before the expiration interval has elapsed.\n    // For that, calculate the delay as a percentage of the expiration time\n\n    this.registrationTimer = setTimeout(() => {\n      this.registrationTimer = undefined;\n      this.register();\n    }, this.refreshFrequency / 100 * expires * 1000); // We are unregistered if the registration expires.\n\n    this.registrationExpiredTimer = setTimeout(() => {\n      this.logger.warn(\"Registration expired\");\n      this.unregistered();\n    }, expires * 1000);\n\n    if (this._state !== RegistererState.Registered) {\n      this.stateTransition(RegistererState.Registered);\n    }\n  }\n  /**\n   * Helper function, called when unregistered.\n   */\n\n\n  unregistered() {\n    this.clearTimers();\n\n    if (this._state !== RegistererState.Unregistered) {\n      this.stateTransition(RegistererState.Unregistered);\n    }\n  }\n  /**\n   * Helper function, called when terminated.\n   */\n\n\n  terminated() {\n    this.clearTimers();\n\n    if (this._state !== RegistererState.Terminated) {\n      this.stateTransition(RegistererState.Terminated);\n    }\n  }\n  /**\n   * Transition registration state.\n   */\n\n\n  stateTransition(newState) {\n    const invalidTransition = () => {\n      throw new Error(`Invalid state transition from ${this._state} to ${newState}`);\n    }; // Validate transition\n\n\n    switch (this._state) {\n      case RegistererState.Initial:\n        if (newState !== RegistererState.Registered && newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Registered:\n        if (newState !== RegistererState.Unregistered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Unregistered:\n        if (newState !== RegistererState.Registered && newState !== RegistererState.Terminated) {\n          invalidTransition();\n        }\n\n        break;\n\n      case RegistererState.Terminated:\n        invalidTransition();\n        break;\n\n      default:\n        throw new Error(\"Unrecognized state.\");\n    } // Transition\n\n\n    this._state = newState;\n    this.logger.log(`Registration transitioned to state ${this._state}`);\n\n    this._stateEventEmitter.emit(this._state); // Dispose\n\n\n    if (newState === RegistererState.Terminated) {\n      this.dispose();\n    }\n  }\n  /** True if the registerer is currently waiting for final response to a REGISTER request. */\n\n\n  get waiting() {\n    return this._waiting;\n  }\n  /** Emits when the registerer waiting state changes. */\n\n\n  get waitingChange() {\n    return this._waitingEventEmitter;\n  }\n  /**\n   * Toggle waiting.\n   */\n\n\n  waitingToggle(waiting) {\n    if (this._waiting === waiting) {\n      throw new Error(`Invalid waiting transition from ${this._waiting} to ${waiting}`);\n    }\n\n    this._waiting = waiting;\n    this.logger.log(`Waiting toggled to ${this._waiting}`);\n\n    this._waitingEventEmitter.emit(this._waiting);\n  }\n  /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n\n  waitingWarning() {\n    let message = \"An attempt was made to send a REGISTER request while a prior one was still in progress.\";\n    message += \" RFC 3261 requires UAs MUST NOT send a new registration until they have received a final response\";\n    message += \" from the registrar for the previous one or the previous REGISTER request has timed out.\";\n    message += \" Note that if the transport disconnects, you still must wait for the prior request to time out before\";\n    message += \" sending a new REGISTER request or alternatively dispose of the current Registerer and create a new Registerer.\";\n    this.logger.warn(message);\n  }\n  /** Hopefully helpful as the standard behavior has been found to be unexpected. */\n\n\n  stateError() {\n    const reason = this.state === RegistererState.Terminated ? \"is in 'Terminated' state\" : \"has been disposed\";\n    let message = `An attempt was made to send a REGISTER request when the Registerer ${reason}.`;\n    message += \" The Registerer transitions to 'Terminated' when Registerer.dispose() is called.\";\n    message += \" Perhaps you called UserAgent.stop() which dipsoses of all Registerers?\";\n    this.logger.error(message);\n  }\n\n}\nRegisterer.defaultExpires = 600;\nRegisterer.defaultRefreshFrequency = 99;","map":null,"metadata":{},"sourceType":"module"}