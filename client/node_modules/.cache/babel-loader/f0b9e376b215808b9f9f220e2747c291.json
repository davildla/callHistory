{"ast":null,"code":"import { Timers } from \"../timers.js\";\nimport { ClientTransaction } from \"./client-transaction.js\";\nimport { TransactionState } from \"./transaction-state.js\";\n/**\n * Non-INVITE Client Transaction.\n * @remarks\n * Non-INVITE transactions do not make use of ACK.\n * They are simple request-response interactions.\n * https://tools.ietf.org/html/rfc3261#section-17.1.2\n * @public\n */\n\nexport class NonInviteClientTransaction extends ClientTransaction {\n  /**\n   * Constructor\n   * Upon construction, the outgoing request's Via header is updated by calling `setViaHeader`.\n   * Then `toString` is called on the outgoing request and the message is sent via the transport.\n   * After construction the transaction will be in the \"calling\" state and the transaction id\n   * will equal the branch parameter set in the Via header of the outgoing request.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.2\n   * @param request - The outgoing Non-INVITE request.\n   * @param transport - The transport.\n   * @param user - The transaction user.\n   */\n  constructor(request, transport, user) {\n    super(request, transport, user, TransactionState.Trying, \"sip.transaction.nict\"); // FIXME: Timer E for unreliable transports not implemented.\n    //\n    // The \"Trying\" state is entered when the TU initiates a new client\n    // transaction with a request.  When entering this state, the client\n    // transaction SHOULD set timer F to fire in 64*T1 seconds. The request\n    // MUST be passed to the transport layer for transmission.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n    this.F = setTimeout(() => this.timerF(), Timers.TIMER_F);\n    this.send(request.toString()).catch(error => {\n      this.logTransportError(error, \"Failed to send initial outgoing request.\");\n    });\n  }\n  /**\n   * Destructor.\n   */\n\n\n  dispose() {\n    if (this.F) {\n      clearTimeout(this.F);\n      this.F = undefined;\n    }\n\n    if (this.K) {\n      clearTimeout(this.K);\n      this.K = undefined;\n    }\n\n    super.dispose();\n  }\n  /** Transaction kind. Deprecated. */\n\n\n  get kind() {\n    return \"nict\";\n  }\n  /**\n   * Handler for incoming responses from the transport which match this transaction.\n   * @param response - The incoming response.\n   */\n\n\n  receiveResponse(response) {\n    const statusCode = response.statusCode;\n\n    if (!statusCode || statusCode < 100 || statusCode > 699) {\n      throw new Error(`Invalid status code ${statusCode}`);\n    }\n\n    switch (this.state) {\n      case TransactionState.Trying:\n        // If a provisional response is received while in the \"Trying\" state, the\n        // response MUST be passed to the TU, and then the client transaction\n        // SHOULD move to the \"Proceeding\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          this.stateTransition(TransactionState.Proceeding);\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        } // If a final response (status codes 200-699) is received while in the\n        // \"Trying\" state, the response MUST be passed to the TU, and the\n        // client transaction MUST transition to the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n        if (statusCode >= 200 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n\n          if (statusCode === 408) {\n            this.onRequestTimeout();\n            return;\n          }\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Proceeding:\n        // If a provisional response is received while in the \"Proceeding\" state,\n        // the response MUST be passed to the TU. (From Figure 6)\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        if (statusCode >= 100 && statusCode <= 199) {\n          if (this.user.receiveResponse) {\n            return this.user.receiveResponse(response);\n          }\n        } // If a final response (status codes 200-699) is received while in the\n        // \"Proceeding\" state, the response MUST be passed to the TU, and the\n        // client transaction MUST transition to the \"Completed\" state.\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n        if (statusCode >= 200 && statusCode <= 699) {\n          this.stateTransition(TransactionState.Completed);\n\n          if (statusCode === 408) {\n            this.onRequestTimeout();\n            return;\n          }\n\n          if (this.user.receiveResponse) {\n            this.user.receiveResponse(response);\n          }\n\n          return;\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        // The \"Completed\" state exists to buffer any additional response\n        // retransmissions that may be received (which is why the client\n        // transaction remains there only for unreliable transports).\n        // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n        return;\n\n      case TransactionState.Terminated:\n        // For good measure just absorb additional response retransmissions.\n        return;\n\n      default:\n        throw new Error(`Invalid state ${this.state}`);\n    }\n\n    const message = `Non-INVITE client transaction received unexpected ${statusCode} response while in state ${this.state}.`;\n    this.logger.warn(message);\n    return;\n  }\n  /**\n   * The client transaction SHOULD inform the TU that a transport failure has occurred,\n   * and the client transaction SHOULD transition directly to the \"Terminated\" state.\n   * The TU will handle the fail over mechanisms described in [4].\n   * https://tools.ietf.org/html/rfc3261#section-17.1.4\n   * @param error - Transport error\n   */\n\n\n  onTransportError(error) {\n    if (this.user.onTransportError) {\n      this.user.onTransportError(error);\n    }\n\n    this.stateTransition(TransactionState.Terminated, true);\n  }\n  /** For logging. */\n\n\n  typeToString() {\n    return \"non-INVITE client transaction\";\n  }\n  /**\n   * Execute a state transition.\n   * @param newState - New state.\n   */\n\n\n  stateTransition(newState) {\n    let dueToTransportError = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    // Assert valid state transitions.\n    const invalidStateTransition = () => {\n      throw new Error(`Invalid state transition from ${this.state} to ${newState}`);\n    };\n\n    switch (newState) {\n      case TransactionState.Trying:\n        invalidStateTransition();\n        break;\n\n      case TransactionState.Proceeding:\n        if (this.state !== TransactionState.Trying) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Completed:\n        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding) {\n          invalidStateTransition();\n        }\n\n        break;\n\n      case TransactionState.Terminated:\n        if (this.state !== TransactionState.Trying && this.state !== TransactionState.Proceeding && this.state !== TransactionState.Completed) {\n          if (!dueToTransportError) {\n            invalidStateTransition();\n          }\n        }\n\n        break;\n\n      default:\n        invalidStateTransition();\n    } // Once the client transaction enters the \"Completed\" state, it MUST set\n    // Timer K to fire in T4 seconds for unreliable transports, and zero\n    // seconds for reliable transports  The \"Completed\" state exists to\n    // buffer any additional response retransmissions that may be received\n    // (which is why the client transaction remains there only for unreliable transports).\n    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n    if (newState === TransactionState.Completed) {\n      if (this.F) {\n        clearTimeout(this.F);\n        this.F = undefined;\n      }\n\n      this.K = setTimeout(() => this.timerK(), Timers.TIMER_K);\n    } // Once the transaction is in the terminated state, it MUST be destroyed immediately.\n    // https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n\n\n    if (newState === TransactionState.Terminated) {\n      this.dispose();\n    } // Update state.\n\n\n    this.setState(newState);\n  }\n  /**\n   * If Timer F fires while the client transaction is still in the\n   * \"Trying\" state, the client transaction SHOULD inform the TU about the\n   * timeout, and then it SHOULD enter the \"Terminated\" state.\n   * If timer F fires while in the \"Proceeding\" state, the TU MUST be informed of\n   * a timeout, and the client transaction MUST transition to the terminated state.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n   */\n\n\n  timerF() {\n    this.logger.debug(`Timer F expired for non-INVITE client transaction ${this.id}.`);\n\n    if (this.state === TransactionState.Trying || this.state === TransactionState.Proceeding) {\n      this.onRequestTimeout();\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n  /**\n   * If Timer K fires while in this (COMPLETED) state, the client transaction\n   * MUST transition to the \"Terminated\" state.\n   * https://tools.ietf.org/html/rfc3261#section-17.1.2.2\n   */\n\n\n  timerK() {\n    if (this.state === TransactionState.Completed) {\n      this.stateTransition(TransactionState.Terminated);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}