{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\n\nvar events_1 = require(\"events\");\n\nvar loglevel_1 = require(\"loglevel\");\n\nvar audiohelper_1 = require(\"./audiohelper\");\n\nvar call_1 = require(\"./call\");\n\nvar dialtonePlayer_1 = require(\"./dialtonePlayer\");\n\nvar errors_1 = require(\"./errors\");\n\nvar log_1 = require(\"./log\");\n\nvar preflight_1 = require(\"./preflight/preflight\");\n\nvar regions_1 = require(\"./regions\");\n\nvar util_1 = require(\"./util\");\n\nvar C = require('./constants');\n\nvar Publisher = require('./eventpublisher');\n\nvar PStream = require('./pstream');\n\nvar rtc = require('./rtc');\n\nvar getUserMedia = require('./rtc/getusermedia');\n\nvar Sound = require('./sound');\n\nvar REGISTRATION_INTERVAL = 30000;\nvar RINGTONE_PLAY_TIMEOUT = 2000;\nvar PUBLISHER_PRODUCT_NAME = 'twilio-js-sdk';\nvar INVALID_TOKEN_MESSAGE = 'Parameter \"token\" must be of type \"string\".';\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\n\nvar Device =\n/** @class */\nfunction (_super) {\n  __extends(Device, _super);\n  /**\n   * Construct a {@link Device} instance. The {@link Device} can be registered\n   * to make and listen for calls using {@link Device.register}.\n   * @constructor\n   * @param options\n   */\n\n\n  function Device(token, options) {\n    var _a, _b;\n\n    if (options === void 0) {\n      options = {};\n    }\n\n    var _this = _super.call(this) || this;\n    /**\n     * The currently active {@link Call}, if there is one.\n     */\n\n\n    _this._activeCall = null;\n    /**\n     * The AudioHelper instance associated with this {@link Device}.\n     */\n\n    _this._audio = null;\n    /**\n     * An audio input MediaStream to pass to new {@link Call} instances.\n     */\n\n    _this._callInputStream = null;\n    /**\n     * An array of {@link Call}s. Though only one can be active, multiple may exist when there\n     * are multiple incoming, unanswered {@link Call}s.\n     */\n\n    _this._calls = [];\n    /**\n     * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n     * new {@link Call} instances.\n     */\n\n    _this._callSinkIds = ['default'];\n    /**\n     * The list of chunder URIs that will be passed to PStream\n     */\n\n    _this._chunderURIs = [];\n    /**\n     * Default options used by {@link Device}.\n     */\n\n    _this._defaultOptions = {\n      allowIncomingWhileBusy: false,\n      closeProtection: false,\n      codecPreferences: [call_1.default.Codec.PCMU, call_1.default.Codec.Opus],\n      dscp: true,\n      forceAggressiveIceNomination: false,\n      logLevel: loglevel_1.levels.ERROR,\n      maxCallSignalingTimeoutMs: 0,\n      preflight: false,\n      sounds: {},\n      tokenRefreshMs: 10000\n    };\n    /**\n     * The name of the edge the {@link Device} is connected to.\n     */\n\n    _this._edge = null;\n    /**\n     * Whether each sound is enabled.\n     */\n\n    _this._enabledSounds = (_a = {}, _a[Device.SoundName.Disconnect] = true, _a[Device.SoundName.Incoming] = true, _a[Device.SoundName.Outgoing] = true, _a);\n    /**\n     * The name of the home region the {@link Device} is connected to.\n     */\n\n    _this._home = null;\n    /**\n     * The identity associated with this Device.\n     */\n\n    _this._identity = null;\n    /**\n     * An instance of Logger to use.\n     */\n\n    _this._log = log_1.default.getInstance();\n    /**\n     * The options passed to {@link Device} constructor or {@link Device.updateOptions}.\n     */\n\n    _this._options = {};\n    /**\n     * The preferred URI to (re)-connect signaling to.\n     */\n\n    _this._preferredURI = null;\n    /**\n     * An Insights Event Publisher.\n     */\n\n    _this._publisher = null;\n    /**\n     * The region the {@link Device} is connected to.\n     */\n\n    _this._region = null;\n    /**\n     * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n     */\n\n    _this._regTimer = null;\n    /**\n     * Boolean representing whether or not the {@link Device} was registered when\n     * receiving a signaling `offline`. Determines if the {@link Device} attempts\n     * a `re-register` once signaling is re-established when receiving a\n     * `connected` event from the stream.\n     */\n\n    _this._shouldReRegister = false;\n    /**\n     * A Map of Sounds to play.\n     */\n\n    _this._soundcache = new Map();\n    /**\n     * The current status of the {@link Device}.\n     */\n\n    _this._state = Device.State.Unregistered;\n    /**\n     * A map from {@link Device.State} to {@link Device.EventName}.\n     */\n\n    _this._stateEventMapping = (_b = {}, _b[Device.State.Destroyed] = Device.EventName.Destroyed, _b[Device.State.Unregistered] = Device.EventName.Unregistered, _b[Device.State.Registering] = Device.EventName.Registering, _b[Device.State.Registered] = Device.EventName.Registered, _b);\n    /**\n     * The Signaling stream.\n     */\n\n    _this._stream = null;\n    /**\n     * A promise that will resolve when the Signaling stream is ready.\n     */\n\n    _this._streamConnectedPromise = null;\n    /**\n     * A timeout to track when the current AccessToken will expire.\n     */\n\n    _this._tokenWillExpireTimeout = null;\n    /**\n     * Create the default Insights payload\n     * @param call\n     */\n\n    _this._createDefaultPayload = function (call) {\n      var payload = {\n        aggressive_nomination: _this._options.forceAggressiveIceNomination,\n        browser_extension: _this._isBrowserExtension,\n        dscp: !!_this._options.dscp,\n        ice_restart_enabled: true,\n        platform: rtc.getMediaEngine(),\n        sdk_version: C.RELEASE_VERSION\n      };\n\n      function setIfDefined(propertyName, value) {\n        if (value) {\n          payload[propertyName] = value;\n        }\n      }\n\n      if (call) {\n        var callSid = call.parameters.CallSid;\n        setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n        setIfDefined('temp_call_sid', call.outboundConnectionId);\n        setIfDefined('audio_codec', call.codec);\n        payload.direction = call.direction;\n      }\n\n      setIfDefined('gateway', _this._stream && _this._stream.gateway);\n      setIfDefined('region', _this._stream && _this._stream.region);\n      return payload;\n    };\n    /**\n     * Called when a 'close' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingClose = function () {\n      _this._stream = null;\n      _this._streamConnectedPromise = null;\n    };\n    /**\n     * Called when a 'connected' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingConnected = function (payload) {\n      var _a;\n\n      var region = regions_1.getRegionShortcode(payload.region);\n      _this._edge = payload.edge || regions_1.regionToEdge[region] || payload.region;\n      _this._region = region || payload.region;\n      (_a = _this._publisher) === null || _a === void 0 ? void 0 : _a.setHost(regions_1.createEventGatewayURI(payload.home));\n\n      if (payload.token) {\n        _this._identity = payload.token.identity;\n\n        if (typeof payload.token.ttl === 'number' && typeof _this._options.tokenRefreshMs === 'number') {\n          var ttlMs = payload.token.ttl * 1000;\n          var timeoutMs = Math.max(0, ttlMs - _this._options.tokenRefreshMs);\n          _this._tokenWillExpireTimeout = setTimeout(function () {\n            _this.emit('tokenWillExpire', _this);\n\n            if (_this._tokenWillExpireTimeout) {\n              clearTimeout(_this._tokenWillExpireTimeout);\n              _this._tokenWillExpireTimeout = null;\n            }\n          }, timeoutMs);\n        }\n      }\n\n      _this._home = payload.home;\n      var preferredURIs = regions_1.getChunderURIs(_this._edge, undefined, _this._log.warn.bind(_this._log));\n\n      if (preferredURIs.length > 0) {\n        var preferredURI = preferredURIs[0];\n        _this._preferredURI = regions_1.createSignalingEndpointURL(preferredURI);\n      } else {\n        _this._log.info('Could not parse a preferred URI from the stream#connected event.');\n      } // The signaling stream emits a `connected` event after reconnection, if the\n      // device was registered before this, then register again.\n\n\n      if (_this._shouldReRegister) {\n        _this.register();\n      }\n    };\n    /**\n     * Called when an 'error' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingError = function (payload) {\n      if (typeof payload !== 'object') {\n        return;\n      }\n\n      var originalError = payload.error,\n          callsid = payload.callsid;\n\n      if (typeof originalError !== 'object') {\n        return;\n      }\n\n      var call = typeof callsid === 'string' && _this._findCall(callsid) || undefined;\n      var code = originalError.code,\n          customMessage = originalError.message;\n      var twilioError = originalError.twilioError;\n\n      if (typeof code === 'number') {\n        if (code === 31201) {\n          twilioError = new errors_1.AuthorizationErrors.AuthenticationFailed(originalError);\n        } else if (code === 31204) {\n          twilioError = new errors_1.AuthorizationErrors.AccessTokenInvalid(originalError);\n        } else if (code === 31205) {\n          // Stop trying to register presence after token expires\n          _this._stopRegistrationTimer();\n\n          twilioError = new errors_1.AuthorizationErrors.AccessTokenExpired(originalError);\n        } else if (errors_1.hasErrorByCode(code)) {\n          twilioError = new (errors_1.getErrorByCode(code))(originalError);\n        }\n      }\n\n      if (!twilioError) {\n        _this._log.error('Unknown signaling error: ', originalError);\n\n        twilioError = new errors_1.GeneralErrors.UnknownError(customMessage, originalError);\n      }\n\n      _this._log.info('Received error: ', twilioError);\n\n      _this.emit(Device.EventName.Error, twilioError, call);\n    };\n    /**\n     * Called when an 'invite' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingInvite = function (payload) {\n      return __awaiter(_this, void 0, void 0, function () {\n        var wasBusy, callParameters, customParameters, call, play;\n\n        var _this = this;\n\n        return __generator(this, function (_a) {\n          switch (_a.label) {\n            case 0:\n              wasBusy = !!this._activeCall;\n\n              if (wasBusy && !this._options.allowIncomingWhileBusy) {\n                this._log.info('Device busy; ignoring incoming invite');\n\n                return [2\n                /*return*/\n                ];\n              }\n\n              if (!payload.callsid || !payload.sdp) {\n                this.emit(Device.EventName.Error, new errors_1.ClientErrors.BadRequest('Malformed invite from gateway'));\n                return [2\n                /*return*/\n                ];\n              }\n\n              callParameters = payload.parameters || {};\n              callParameters.CallSid = callParameters.CallSid || payload.callsid;\n              customParameters = Object.assign({}, util_1.queryToJson(callParameters.Params));\n              return [4\n              /*yield*/\n              , this._makeCall(customParameters, {\n                callParameters: callParameters,\n                offerSdp: payload.sdp,\n                reconnectToken: payload.reconnect\n              })];\n\n            case 1:\n              call = _a.sent();\n\n              this._calls.push(call);\n\n              call.once('accept', function () {\n                _this._soundcache.get(Device.SoundName.Incoming).stop();\n\n                _this._publishNetworkChange();\n              });\n              play = this._enabledSounds.incoming && !wasBusy ? function () {\n                return _this._soundcache.get(Device.SoundName.Incoming).play();\n              } : function () {\n                return Promise.resolve();\n              };\n\n              this._showIncomingCall(call, play);\n\n              return [2\n              /*return*/\n              ];\n          }\n        });\n      });\n    };\n    /**\n     * Called when an 'offline' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingOffline = function () {\n      _this._log.info('Stream is offline');\n\n      _this._edge = null;\n      _this._region = null;\n      _this._shouldReRegister = _this.state !== Device.State.Unregistered;\n\n      _this._setState(Device.State.Unregistered);\n    };\n    /**\n     * Called when a 'ready' event is received from the signaling stream.\n     */\n\n\n    _this._onSignalingReady = function () {\n      _this._log.info('Stream is ready');\n\n      _this._setState(Device.State.Registered);\n    };\n    /**\n     * Publish a NetworkInformation#change event to Insights if there's an active {@link Call}.\n     */\n\n\n    _this._publishNetworkChange = function () {\n      if (!_this._activeCall) {\n        return;\n      }\n\n      if (_this._networkInformation) {\n        _this._publisher.info('network-information', 'network-change', {\n          connection_type: _this._networkInformation.type,\n          downlink: _this._networkInformation.downlink,\n          downlinkMax: _this._networkInformation.downlinkMax,\n          effective_type: _this._networkInformation.effectiveType,\n          rtt: _this._networkInformation.rtt\n        }, _this._activeCall);\n      }\n    };\n    /**\n     * Update the input stream being used for calls so that any current call and all future calls\n     * will use the new input stream.\n     * @param inputStream\n     */\n\n\n    _this._updateInputStream = function (inputStream) {\n      var call = _this._activeCall;\n\n      if (call && !inputStream) {\n        return Promise.reject(new errors_1.InvalidStateError('Cannot unset input device while a call is in progress.'));\n      }\n\n      _this._callInputStream = inputStream;\n      return call ? call._setInputTracksFromStream(inputStream) : Promise.resolve();\n    };\n    /**\n     * Update the device IDs of output devices being used to play sounds through.\n     * @param type - Whether to update ringtone or speaker sounds\n     * @param sinkIds - An array of device IDs\n     */\n\n\n    _this._updateSinkIds = function (type, sinkIds) {\n      var promise = type === 'ringtone' ? _this._updateRingtoneSinkIds(sinkIds) : _this._updateSpeakerSinkIds(sinkIds);\n      return promise.then(function () {\n        _this._publisher.info('audio', type + \"-devices-set\", {\n          audio_device_ids: sinkIds\n        }, _this._activeCall);\n      }, function (error) {\n        _this._publisher.error('audio', type + \"-devices-set-failed\", {\n          audio_device_ids: sinkIds,\n          message: error.message\n        }, _this._activeCall);\n\n        throw error;\n      });\n    };\n\n    _this.updateToken(token);\n\n    if (util_1.isLegacyEdge()) {\n      throw new errors_1.NotSupportedError('Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' + 'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' + 'Please see this documentation for a list of supported browsers ' + 'https://www.twilio.com/docs/voice/client/javascript#supported-browsers');\n    }\n\n    if (!Device.isSupported && options.ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new errors_1.NotSupportedError(\"twilio.js wasn't able to find WebRTC browser support.           This is most likely because this page is served over http rather than https,           which does not support WebRTC in many browsers. Please load this page over https and           try again.\");\n      }\n\n      throw new errors_1.NotSupportedError(\"twilio.js 1.3+ SDKs require WebRTC browser support.         For more information, see <https://www.twilio.com/docs/api/client/twilio-js>.         If you have any questions about this announcement, please contact         Twilio Support at <help@twilio.com>.\");\n    }\n\n    if (window) {\n      var root = window;\n      var browser = root.msBrowser || root.browser || root.chrome;\n      _this._isBrowserExtension = !!browser && !!browser.runtime && !!browser.runtime.id || !!root.safari && !!root.safari.extension;\n    }\n\n    if (_this._isBrowserExtension) {\n      _this._log.info('Running as browser extension.');\n    }\n\n    if (navigator) {\n      var n = navigator;\n      _this._networkInformation = n.connection || n.mozConnection || n.webkitConnection;\n    }\n\n    if (_this._networkInformation && typeof _this._networkInformation.addEventListener === 'function') {\n      _this._networkInformation.addEventListener('change', _this._publishNetworkChange);\n    }\n\n    Device._getOrCreateAudioContext();\n\n    if (Device._audioContext) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new dialtonePlayer_1.default(Device._audioContext);\n      }\n    }\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined' && typeof RTCPeerConnection !== 'undefined' && typeof RTCRtpTransceiver !== 'undefined' ? util_1.isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver) : false;\n    }\n\n    _this._boundDestroy = _this.destroy.bind(_this);\n    _this._boundConfirmClose = _this._confirmClose.bind(_this);\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', _this._boundDestroy);\n      window.addEventListener('pagehide', _this._boundDestroy);\n    }\n\n    _this.updateOptions(options);\n\n    return _this;\n  }\n\n  Object.defineProperty(Device, \"audioContext\", {\n    /**\n     * The AudioContext to be used by {@link Device} instances.\n     * @private\n     */\n    get: function () {\n      return Device._audioContext;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"extension\", {\n    /**\n     * Which sound file extension is supported.\n     * @private\n     */\n    get: function () {\n      // NOTE(mroberts): Node workaround.\n      var a = typeof document !== 'undefined' ? document.createElement('audio') : {\n        canPlayType: false\n      };\n      var canPlayMp3;\n\n      try {\n        canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n      } catch (e) {\n        canPlayMp3 = false;\n      }\n\n      var canPlayVorbis;\n\n      try {\n        canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n      } catch (e) {\n        canPlayVorbis = false;\n      }\n\n      return canPlayVorbis && !canPlayMp3 ? 'ogg' : 'mp3';\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"isSupported\", {\n    /**\n     * Whether or not this SDK is supported by the current browser.\n     */\n    get: function () {\n      return rtc.enabled();\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device, \"packageName\", {\n    /**\n     * Package name of the SDK.\n     */\n    get: function () {\n      return C.PACKAGE_NAME;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n\n  Device.runPreflight = function (token, options) {\n    return new preflight_1.PreflightTest(token, __assign({\n      audioContext: Device._getOrCreateAudioContext()\n    }, options));\n  };\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n\n\n  Device.toString = function () {\n    return '[Twilio.Device class]';\n  };\n\n  Object.defineProperty(Device, \"version\", {\n    /**\n     * Current SDK version.\n     */\n    get: function () {\n      return C.RELEASE_VERSION;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Initializes the AudioContext instance shared across the Voice SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n\n  Device._getOrCreateAudioContext = function () {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n\n    return Device._audioContext;\n  };\n\n  Object.defineProperty(Device.prototype, \"audio\", {\n    /**\n     * Return the {@link AudioHelper} used by this {@link Device}.\n     */\n    get: function () {\n      return this._audio;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Make an outgoing Call.\n   * @param options\n   */\n\n  Device.prototype.connect = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return __awaiter(this, void 0, void 0, function () {\n      var activeCall, _a;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            this._throwIfDestroyed();\n\n            if (this._activeCall) {\n              throw new errors_1.InvalidStateError('A Call is already active');\n            }\n\n            _a = this;\n            return [4\n            /*yield*/\n            , this._makeCall(options.params || {}, {\n              rtcConfiguration: options.rtcConfiguration\n            })];\n\n          case 1:\n            activeCall = _a._activeCall = _b.sent(); // Make sure any incoming calls are ignored\n\n            this._calls.splice(0).forEach(function (call) {\n              return call.ignore();\n            }); // Stop the incoming sound if it's playing\n\n\n            this._soundcache.get(Device.SoundName.Incoming).stop();\n\n            activeCall.accept({\n              rtcConstraints: options.rtcConstraints\n            });\n\n            this._publishNetworkChange();\n\n            return [2\n            /*return*/\n            , activeCall];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(Device.prototype, \"calls\", {\n    /**\n     * Return the calls that this {@link Device} is maintaining.\n     */\n    get: function () {\n      return this._calls;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Destroy the {@link Device}, freeing references to be garbage collected.\n   */\n\n  Device.prototype.destroy = function () {\n    this.disconnectAll();\n\n    this._stopRegistrationTimer();\n\n    if (this._audio) {\n      this._audio._unbind();\n    }\n\n    this._destroyStream();\n\n    this._destroyPublisher();\n\n    this._destroyAudioHelper();\n\n    if (this._networkInformation && typeof this._networkInformation.removeEventListener === 'function') {\n      this._networkInformation.removeEventListener('change', this._publishNetworkChange);\n    }\n\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.removeEventListener('unload', this._boundDestroy);\n      window.removeEventListener('pagehide', this._boundDestroy);\n    }\n\n    this._setState(Device.State.Destroyed);\n\n    events_1.EventEmitter.prototype.removeAllListeners.call(this);\n  };\n  /**\n   * Disconnect all {@link Call}s.\n   */\n\n\n  Device.prototype.disconnectAll = function () {\n    var calls = this._calls.splice(0);\n\n    calls.forEach(function (call) {\n      return call.disconnect();\n    });\n\n    if (this._activeCall) {\n      this._activeCall.disconnect();\n    }\n  };\n\n  Object.defineProperty(Device.prototype, \"edge\", {\n    /**\n     * Returns the {@link Edge} value the {@link Device} is currently connected\n     * to. The value will be `null` when the {@link Device} is offline.\n     */\n    get: function () {\n      return this._edge;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"home\", {\n    /**\n     * Returns the home value the {@link Device} is currently connected\n     * to. The value will be `null` when the {@link Device} is offline.\n     */\n    get: function () {\n      return this._home;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"identity\", {\n    /**\n     * Returns the identity associated with the {@link Device} for incoming calls. Only\n     * populated when registered.\n     */\n    get: function () {\n      return this._identity;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"isBusy\", {\n    /**\n     * Whether the Device is currently on an active Call.\n     */\n    get: function () {\n      return !!this._activeCall;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * Register the `Device` to the Twilio backend, allowing it to receive calls.\n   */\n\n  Device.prototype.register = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var stream, streamReadyPromise;\n\n      var _this = this;\n\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.state !== Device.State.Unregistered) {\n              throw new errors_1.InvalidStateError(\"Attempt to register when device is in state \\\"\" + this.state + \"\\\". \" + (\"Must be \\\"\" + Device.State.Unregistered + \"\\\".\"));\n            }\n\n            this._setState(Device.State.Registering);\n\n            return [4\n            /*yield*/\n            , this._streamConnectedPromise || this._setupStream()];\n\n          case 1:\n            stream = _a.sent();\n            streamReadyPromise = new Promise(function (resolve) {\n              _this.once(Device.State.Registered, resolve);\n            });\n            return [4\n            /*yield*/\n            , this._sendPresence(true)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , streamReadyPromise];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  Object.defineProperty(Device.prototype, \"state\", {\n    /**\n     * Get the state of this {@link Device} instance\n     */\n    get: function () {\n      return this._state;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(Device.prototype, \"token\", {\n    /**\n     * Get the token used by this {@link Device}.\n     */\n    get: function () {\n      return this._token;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n\n  Device.prototype.toString = function () {\n    return '[Twilio.Device instance]';\n  };\n  /**\n   * Unregister the `Device` to the Twilio backend, disallowing it to receive\n   * calls.\n   */\n\n\n  Device.prototype.unregister = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var stream, streamOfflinePromise;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (this.state !== Device.State.Registered) {\n              throw new errors_1.InvalidStateError(\"Attempt to unregister when device is in state \\\"\" + this.state + \"\\\". \" + (\"Must be \\\"\" + Device.State.Registered + \"\\\".\"));\n            }\n\n            this._shouldReRegister = false;\n            return [4\n            /*yield*/\n            , this._streamConnectedPromise];\n\n          case 1:\n            stream = _a.sent();\n            streamOfflinePromise = new Promise(function (resolve) {\n              stream.on('offline', resolve);\n            });\n            return [4\n            /*yield*/\n            , this._sendPresence(false)];\n\n          case 2:\n            _a.sent();\n\n            return [4\n            /*yield*/\n            , streamOfflinePromise];\n\n          case 3:\n            _a.sent();\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Set the options used within the {@link Device}.\n   * @param options\n   */\n\n\n  Device.prototype.updateOptions = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError(\"Attempt to \\\"updateOptions\\\" when device is in state \\\"\" + this.state + \"\\\".\");\n    }\n\n    this._options = __assign(__assign(__assign({}, this._defaultOptions), this._options), options);\n    var originalChunderURIs = new Set(this._chunderURIs);\n    var chunderw = typeof this._options.chunderw === 'string' ? [this._options.chunderw] : Array.isArray(this._options.chunderw) && this._options.chunderw;\n    var newChunderURIs = this._chunderURIs = (chunderw || regions_1.getChunderURIs(this._options.edge, undefined, this._log.warn.bind(this._log))).map(regions_1.createSignalingEndpointURL);\n    var hasChunderURIsChanged = originalChunderURIs.size !== newChunderURIs.length;\n\n    if (!hasChunderURIsChanged) {\n      for (var _i = 0, newChunderURIs_1 = newChunderURIs; _i < newChunderURIs_1.length; _i++) {\n        var uri = newChunderURIs_1[_i];\n\n        if (!originalChunderURIs.has(uri)) {\n          hasChunderURIsChanged = true;\n          break;\n        }\n      }\n    }\n\n    if (this.isBusy && hasChunderURIsChanged) {\n      throw new errors_1.InvalidStateError('Cannot change Edge while on an active Call');\n    }\n\n    this._log.setDefaultLevel(typeof this._options.logLevel === 'number' ? this._options.logLevel : loglevel_1.levels.ERROR);\n\n    if (this._options.dscp) {\n      if (!this._options.rtcConstraints) {\n        this._options.rtcConstraints = {};\n      }\n\n      this._options.rtcConstraints.optional = [{\n        googDscp: true\n      }];\n    }\n\n    for (var _a = 0, _b = Object.keys(Device._defaultSounds); _a < _b.length; _a++) {\n      var name_1 = _b[_a];\n      var soundDef = Device._defaultSounds[name_1];\n      var defaultUrl = C.SOUNDS_BASE_URL + \"/\" + soundDef.filename + \".\" + Device.extension + (\"?cache=\" + C.RELEASE_VERSION);\n      var soundUrl = this._options.sounds && this._options.sounds[name_1] || defaultUrl;\n      var sound = new (this._options.Sound || Sound)(name_1, soundUrl, {\n        audioContext: this._options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop\n      });\n\n      this._soundcache.set(name_1, sound);\n    }\n\n    this._setupAudioHelper();\n\n    this._setupPublisher();\n\n    if (hasChunderURIsChanged && this._streamConnectedPromise) {\n      this._setupStream();\n    } // Setup close protection and make sure we clean up ongoing calls on unload.\n\n\n    if (typeof window !== 'undefined' && typeof window.addEventListener === 'function' && this._options.closeProtection) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.addEventListener('beforeunload', this._boundConfirmClose);\n    }\n  };\n  /**\n   * Update the token used by this {@link Device} to connect to Twilio.\n   * @param token\n   */\n\n\n  Device.prototype.updateToken = function (token) {\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError(\"Attempt to \\\"updateToken\\\" when device is in state \\\"\" + this.state + \"\\\".\");\n    }\n\n    if (typeof token !== 'string') {\n      throw new errors_1.InvalidArgumentError(INVALID_TOKEN_MESSAGE);\n    }\n\n    this._token = token;\n\n    if (this._stream) {\n      this._stream.setToken(this._token);\n    }\n\n    if (this._publisher) {\n      this._publisher.setToken(this._token);\n    }\n  };\n  /**\n   * Called on window's beforeunload event if closeProtection is enabled,\n   * preventing users from accidentally navigating away from an active call.\n   * @param event\n   */\n\n\n  Device.prototype._confirmClose = function (event) {\n    if (!this._activeCall) {\n      return '';\n    }\n\n    var closeProtection = this._options.closeProtection || false;\n    var confirmationMsg = typeof closeProtection !== 'string' ? 'A call is currently in-progress. Leaving or reloading this page will end the call.' : closeProtection;\n    (event || window.event).returnValue = confirmationMsg;\n    return confirmationMsg;\n  };\n  /**\n   * Destroy the AudioHelper.\n   */\n\n\n  Device.prototype._destroyAudioHelper = function () {\n    if (!this._audio) {\n      return;\n    }\n\n    this._audio.removeAllListeners();\n\n    this._audio = null;\n  };\n  /**\n   * Destroy the publisher.\n   */\n\n\n  Device.prototype._destroyPublisher = function () {\n    // Attempt to destroy non-existent publisher.\n    if (!this._publisher) {\n      return;\n    }\n\n    this._publisher = null;\n  };\n  /**\n   * Destroy the connection to the signaling server.\n   */\n\n\n  Device.prototype._destroyStream = function () {\n    if (this._stream) {\n      this._stream.removeListener('close', this._onSignalingClose);\n\n      this._stream.removeListener('connected', this._onSignalingConnected);\n\n      this._stream.removeListener('error', this._onSignalingError);\n\n      this._stream.removeListener('invite', this._onSignalingInvite);\n\n      this._stream.removeListener('offline', this._onSignalingOffline);\n\n      this._stream.removeListener('ready', this._onSignalingReady);\n\n      this._stream.destroy();\n\n      this._stream = null;\n    }\n\n    this._onSignalingOffline();\n\n    this._streamConnectedPromise = null;\n  };\n  /**\n   * Find a {@link Call} by its CallSid.\n   * @param callSid\n   */\n\n\n  Device.prototype._findCall = function (callSid) {\n    return this._calls.find(function (call) {\n      return call.parameters.CallSid === callSid || call.outboundConnectionId === callSid;\n    }) || null;\n  };\n  /**\n   * Create a new {@link Call}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param options - Options to be used to instantiate the {@link Call}.\n   */\n\n\n  Device.prototype._makeCall = function (twimlParams, options) {\n    return __awaiter(this, void 0, void 0, function () {\n      var config, _a, maybeUnsetPreferredUri, call;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n              throw new errors_1.InvalidStateError('Device has not been initialized.');\n            }\n\n            _a = {\n              audioHelper: this._audio,\n              getUserMedia: getUserMedia,\n              isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n              onIgnore: function () {\n                _this._soundcache.get(Device.SoundName.Incoming).stop();\n              }\n            };\n            return [4\n            /*yield*/\n            , this._streamConnectedPromise || this._setupStream()];\n\n          case 1:\n            config = (_a.pstream = _b.sent(), _a.publisher = this._publisher, _a.soundcache = this._soundcache, _a);\n            options = Object.assign({\n              MediaStream: this._options.MediaStream || rtc.PeerConnection,\n              beforeAccept: function (currentCall) {\n                if (!_this._activeCall || _this._activeCall === currentCall) {\n                  return;\n                }\n\n                _this._activeCall.disconnect();\n\n                _this._removeCall(_this._activeCall);\n              },\n              codecPreferences: this._options.codecPreferences,\n              dialtonePlayer: Device._dialtonePlayer,\n              dscp: this._options.dscp,\n              forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n              getInputStream: function () {\n                return _this._options.fileInputStream || _this._callInputStream;\n              },\n              getSinkIds: function () {\n                return _this._callSinkIds;\n              },\n              maxAverageBitrate: this._options.maxAverageBitrate,\n              preflight: this._options.preflight,\n              rtcConstraints: this._options.rtcConstraints,\n              shouldPlayDisconnect: function () {\n                return _this._enabledSounds.disconnect;\n              },\n              twimlParams: twimlParams\n            }, options);\n\n            maybeUnsetPreferredUri = function () {\n              if (_this._activeCall === null && _this._calls.length === 0) {\n                _this._stream.updatePreferredURI(null);\n              }\n            };\n\n            call = new (this._options.Call || call_1.default)(config, options);\n            call.once('accept', function () {\n              _this._stream.updatePreferredURI(_this._preferredURI);\n\n              _this._removeCall(call);\n\n              _this._activeCall = call;\n\n              if (_this._audio) {\n                _this._audio._maybeStartPollingVolume();\n              }\n\n              if (call.direction === call_1.default.CallDirection.Outgoing && _this._enabledSounds.outgoing) {\n                _this._soundcache.get(Device.SoundName.Outgoing).play();\n              }\n\n              var data = {\n                edge: _this._edge || _this._region\n              };\n\n              if (_this._options.edge) {\n                data['selected_edge'] = Array.isArray(_this._options.edge) ? _this._options.edge : [_this._options.edge];\n              }\n\n              _this._publisher.info('settings', 'edge', data, call);\n            });\n            call.addListener('error', function (error) {\n              if (call.status() === 'closed') {\n                _this._removeCall(call);\n\n                maybeUnsetPreferredUri();\n              }\n\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n\n              _this._maybeStopIncomingSound();\n            });\n            call.once('cancel', function () {\n              _this._log.info(\"Canceled: \" + call.parameters.CallSid);\n\n              _this._removeCall(call);\n\n              maybeUnsetPreferredUri();\n\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n\n              _this._maybeStopIncomingSound();\n            });\n            call.once('disconnect', function () {\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n\n              _this._removeCall(call);\n\n              maybeUnsetPreferredUri();\n            });\n            call.once('reject', function () {\n              _this._log.info(\"Rejected: \" + call.parameters.CallSid);\n\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n\n              _this._removeCall(call);\n\n              maybeUnsetPreferredUri();\n\n              _this._maybeStopIncomingSound();\n            });\n            call.on('transportClose', function () {\n              if (call.status() !== call_1.default.State.Pending) {\n                return;\n              }\n\n              if (_this._audio) {\n                _this._audio._maybeStopPollingVolume();\n              }\n\n              _this._removeCall(call);\n              /**\n               * NOTE(mhuynh): We don't want to call `maybeUnsetPreferredUri` because\n               * a `transportClose` will happen during signaling reconnection.\n               */\n\n\n              _this._maybeStopIncomingSound();\n            });\n            return [2\n            /*return*/\n            , call];\n        }\n      });\n    });\n  };\n  /**\n   * Stop the incoming sound if no {@link Call}s remain.\n   */\n\n\n  Device.prototype._maybeStopIncomingSound = function () {\n    if (!this._calls.length) {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  };\n  /**\n   * Remove a {@link Call} from device.calls by reference\n   * @param call\n   */\n\n\n  Device.prototype._removeCall = function (call) {\n    if (this._activeCall === call) {\n      this._activeCall = null;\n    }\n\n    for (var i = this._calls.length - 1; i >= 0; i--) {\n      if (call === this._calls[i]) {\n        this._calls.splice(i, 1);\n      }\n    }\n  };\n  /**\n   * Register with the signaling server.\n   */\n\n\n  Device.prototype._sendPresence = function (presence) {\n    return __awaiter(this, void 0, void 0, function () {\n      var stream;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this._streamConnectedPromise];\n\n          case 1:\n            stream = _a.sent();\n\n            if (!stream) {\n              return [2\n              /*return*/\n              ];\n            }\n\n            stream.register({\n              audio: presence\n            });\n\n            if (presence) {\n              this._startRegistrationTimer();\n            } else {\n              this._stopRegistrationTimer();\n            }\n\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * Helper function that sets and emits the state of the device.\n   * @param state The new state of the device.\n   */\n\n\n  Device.prototype._setState = function (state) {\n    if (state === this.state) {\n      return;\n    }\n\n    this._state = state;\n    this.emit(this._stateEventMapping[state]);\n  };\n  /**\n   * Set up an audio helper for usage by this {@link Device}.\n   */\n\n\n  Device.prototype._setupAudioHelper = function () {\n    var _this = this;\n\n    if (this._audio) {\n      this._log.info('Found existing audio helper; destroying...');\n\n      this._destroyAudioHelper();\n    }\n\n    this._audio = new (this._options.AudioHelper || audiohelper_1.default)(this._updateSinkIds, this._updateInputStream, getUserMedia, {\n      audioContext: Device.audioContext,\n      enabledSounds: this._enabledSounds\n    });\n\n    this._audio.on('deviceChange', function (lostActiveDevices) {\n      var activeCall = _this._activeCall;\n      var deviceIds = lostActiveDevices.map(function (device) {\n        return device.deviceId;\n      });\n\n      _this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds\n      }, activeCall);\n\n      if (activeCall) {\n        activeCall['_mediaHandler']._onInputDevicesChanged();\n      }\n    });\n  };\n  /**\n   * Create and set a publisher for the {@link Device} to use.\n   */\n\n\n  Device.prototype._setupPublisher = function () {\n    var _this = this;\n\n    if (this._publisher) {\n      this._log.info('Found existing publisher; destroying...');\n\n      this._destroyPublisher();\n    }\n\n    var publisherOptions = {\n      defaultPayload: this._createDefaultPayload,\n      log: this._log,\n      metadata: {\n        app_name: this._options.appName,\n        app_version: this._options.appVersion\n      }\n    };\n\n    if (this._options.eventgw) {\n      publisherOptions.host = this._options.eventgw;\n    }\n\n    this._publisher = new (this._options.Publisher || Publisher)(PUBLISHER_PRODUCT_NAME, this.token, publisherOptions);\n\n    if (this._options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', function (error) {\n        _this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n\n    return this._publisher;\n  };\n  /**\n   * Set up the connection to the signaling server. Tears down an existing\n   * stream if called while a stream exists.\n   */\n\n\n  Device.prototype._setupStream = function () {\n    var _this = this;\n\n    if (this._stream) {\n      this._log.info('Found existing stream; destroying...');\n\n      this._destroyStream();\n    }\n\n    this._log.info('Setting up VSP');\n\n    this._stream = new (this._options.PStream || PStream)(this.token, this._chunderURIs, {\n      backoffMaxMs: this._options.backoffMaxMs,\n      maxPreferredDurationMs: this._options.maxCallSignalingTimeoutMs\n    });\n\n    this._stream.addListener('close', this._onSignalingClose);\n\n    this._stream.addListener('connected', this._onSignalingConnected);\n\n    this._stream.addListener('error', this._onSignalingError);\n\n    this._stream.addListener('invite', this._onSignalingInvite);\n\n    this._stream.addListener('offline', this._onSignalingOffline);\n\n    this._stream.addListener('ready', this._onSignalingReady);\n\n    return this._streamConnectedPromise = new Promise(function (resolve) {\n      return _this._stream.once('connected', function () {\n        resolve(_this._stream);\n      });\n    });\n  };\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param call\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n\n\n  Device.prototype._showIncomingCall = function (call, play) {\n    var _this = this;\n\n    var timeout;\n    return Promise.race([play(), new Promise(function (resolve, reject) {\n      timeout = setTimeout(function () {\n        var msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n        reject(new Error(msg));\n      }, RINGTONE_PLAY_TIMEOUT);\n    })]).catch(function (reason) {\n      _this._log.info(reason.message);\n    }).then(function () {\n      clearTimeout(timeout);\n\n      _this.emit(Device.EventName.Incoming, call);\n    });\n  };\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n\n\n  Device.prototype._startRegistrationTimer = function () {\n    var _this = this;\n\n    this._stopRegistrationTimer();\n\n    this._regTimer = setTimeout(function () {\n      _this._sendPresence(true);\n    }, REGISTRATION_INTERVAL);\n  };\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n\n\n  Device.prototype._stopRegistrationTimer = function () {\n    if (this._regTimer) {\n      clearTimeout(this._regTimer);\n    }\n  };\n  /**\n   * Throw an error if the {@link Device} is destroyed.\n   */\n\n\n  Device.prototype._throwIfDestroyed = function () {\n    if (this.state === Device.State.Destroyed) {\n      throw new errors_1.InvalidStateError('Device has been destroyed.');\n    }\n  };\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n\n\n  Device.prototype._updateRingtoneSinkIds = function (sinkIds) {\n    return Promise.resolve(this._soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  };\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n\n\n  Device.prototype._updateSpeakerSinkIds = function (sinkIds) {\n    Array.from(this._soundcache.entries()).filter(function (entry) {\n      return entry[0] !== Device.SoundName.Incoming;\n    }).forEach(function (entry) {\n      return entry[1].setSinkIds(sinkIds);\n    });\n    this._callSinkIds = sinkIds;\n    var call = this._activeCall;\n    return call ? call._setSinkIds(sinkIds) : Promise.resolve();\n  };\n\n  Device._defaultSounds = {\n    disconnect: {\n      filename: 'disconnect',\n      maxDuration: 3000\n    },\n    dtmf0: {\n      filename: 'dtmf-0',\n      maxDuration: 1000\n    },\n    dtmf1: {\n      filename: 'dtmf-1',\n      maxDuration: 1000\n    },\n    dtmf2: {\n      filename: 'dtmf-2',\n      maxDuration: 1000\n    },\n    dtmf3: {\n      filename: 'dtmf-3',\n      maxDuration: 1000\n    },\n    dtmf4: {\n      filename: 'dtmf-4',\n      maxDuration: 1000\n    },\n    dtmf5: {\n      filename: 'dtmf-5',\n      maxDuration: 1000\n    },\n    dtmf6: {\n      filename: 'dtmf-6',\n      maxDuration: 1000\n    },\n    dtmf7: {\n      filename: 'dtmf-7',\n      maxDuration: 1000\n    },\n    dtmf8: {\n      filename: 'dtmf-8',\n      maxDuration: 1000\n    },\n    dtmf9: {\n      filename: 'dtmf-9',\n      maxDuration: 1000\n    },\n    dtmfh: {\n      filename: 'dtmf-hash',\n      maxDuration: 1000\n    },\n    dtmfs: {\n      filename: 'dtmf-star',\n      maxDuration: 1000\n    },\n    incoming: {\n      filename: 'incoming',\n      shouldLoop: true\n    },\n    outgoing: {\n      filename: 'outgoing',\n      maxDuration: 3000\n    }\n  };\n  return Device;\n}(events_1.EventEmitter);\n\n(function (Device) {\n  /**\n   * All valid {@link Device} event names.\n   */\n  var EventName;\n\n  (function (EventName) {\n    EventName[\"Error\"] = \"error\";\n    EventName[\"Incoming\"] = \"incoming\";\n    EventName[\"Destroyed\"] = \"destroyed\";\n    EventName[\"Unregistered\"] = \"unregistered\";\n    EventName[\"Registering\"] = \"registering\";\n    EventName[\"Registered\"] = \"registered\";\n    EventName[\"TokenWillExpire\"] = \"tokenWillExpire\";\n  })(EventName = Device.EventName || (Device.EventName = {}));\n  /**\n   * All possible {@link Device} states.\n   */\n\n\n  var State;\n\n  (function (State) {\n    State[\"Destroyed\"] = \"destroyed\";\n    State[\"Unregistered\"] = \"unregistered\";\n    State[\"Registering\"] = \"registering\";\n    State[\"Registered\"] = \"registered\";\n  })(State = Device.State || (Device.State = {}));\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n\n\n  var SoundName;\n\n  (function (SoundName) {\n    SoundName[\"Incoming\"] = \"incoming\";\n    SoundName[\"Outgoing\"] = \"outgoing\";\n    SoundName[\"Disconnect\"] = \"disconnect\";\n    SoundName[\"Dtmf0\"] = \"dtmf0\";\n    SoundName[\"Dtmf1\"] = \"dtmf1\";\n    SoundName[\"Dtmf2\"] = \"dtmf2\";\n    SoundName[\"Dtmf3\"] = \"dtmf3\";\n    SoundName[\"Dtmf4\"] = \"dtmf4\";\n    SoundName[\"Dtmf5\"] = \"dtmf5\";\n    SoundName[\"Dtmf6\"] = \"dtmf6\";\n    SoundName[\"Dtmf7\"] = \"dtmf7\";\n    SoundName[\"Dtmf8\"] = \"dtmf8\";\n    SoundName[\"Dtmf9\"] = \"dtmf9\";\n    SoundName[\"DtmfS\"] = \"dtmfs\";\n    SoundName[\"DtmfH\"] = \"dtmfh\";\n  })(SoundName = Device.SoundName || (Device.SoundName = {}));\n})(Device || (Device = {}));\n\nexports.default = Device;","map":{"version":3,"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;;;;;;;AAMA;;AACA;;AACA;;AACA;;AACA;;AACA;;AAWA;;AACA;;AACA;;AASA;;AAMA,IAAMA,CAAC,GAAGC,OAAO,CAAC,aAAD,CAAjB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,kBAAD,CAAzB;;AACA,IAAME,OAAO,GAAGF,OAAO,CAAC,WAAD,CAAvB;;AACA,IAAMG,GAAG,GAAGH,OAAO,CAAC,OAAD,CAAnB;;AACA,IAAMI,YAAY,GAAGJ,OAAO,CAAC,oBAAD,CAA5B;;AACA,IAAMK,KAAK,GAAGL,OAAO,CAAC,SAAD,CAArB;;AAgBA,IAAMM,qBAAqB,GAAG,KAA9B;AACA,IAAMC,qBAAqB,GAAG,IAA9B;AACA,IAAMC,sBAAsB,GAAG,eAA/B;AACA,IAAMC,qBAAqB,GAAG,6CAA9B;AAwGA;;;;;AAIA;AAAA;AAAA;EAAqBC;EA8RnB;;;;;;;;EAMA,gBAAYC,KAAZ,EAA2BC,OAA3B,EAAwD;;;IAA7B;MAAAA;IAA6B;;IAAxD,YACEC,qBAAO,IADT;IAjLA;;;;;IAGQC,oBAA2B,IAA3B;IAER;;;;IAGQA,eAA6B,IAA7B;IAYR;;;;IAGQA,yBAAuC,IAAvC;IAER;;;;;IAIQA,eAAiB,EAAjB;IAER;;;;;IAIQA,qBAAyB,CAAC,SAAD,CAAzB;IAER;;;;IAGQA,qBAAyB,EAAzB;IAER;;;;IAGiBA,wBAA0C;MACzDC,sBAAsB,EAAE,KADiC;MAEzDC,eAAe,EAAE,KAFwC;MAGzDC,gBAAgB,EAAE,CAACC,eAAKC,KAAL,CAAWC,IAAZ,EAAkBF,eAAKC,KAAL,CAAWE,IAA7B,CAHuC;MAIzDC,IAAI,EAAE,IAJmD;MAKzDC,4BAA4B,EAAE,KAL2B;MAMzDC,QAAQ,EAAEC,kBAAUC,KANqC;MAOzDC,yBAAyB,EAAE,CAP8B;MAQzDC,SAAS,EAAE,KAR8C;MASzDC,MAAM,EAAE,EATiD;MAUzDC,cAAc,EAAE;IAVyC,CAA1C;IAajB;;;;IAGQhB,cAAuB,IAAvB;IAER;;;;IAGQA,wBAAciB,SACpBA,GAACC,MAAM,CAACC,SAAP,CAAiBC,UAAlB,IAA+B,IADX,EAEpBH,GAACC,MAAM,CAACC,SAAP,CAAiBE,QAAlB,IAA6B,IAFT,EAGpBJ,GAACC,MAAM,CAACC,SAAP,CAAiBG,QAAlB,IAA6B,IAHT,IAAd;IAMR;;;;IAGQtB,cAAuB,IAAvB;IAER;;;;IAGQA,kBAA2B,IAA3B;IAOR;;;;IAGQA,aAAYuB,cAAIC,WAAJ,EAAZ;IAQR;;;;IAGQxB,iBAAmC,EAAnC;IAER;;;;IAGQA,sBAA+B,IAA/B;IAER;;;;IAGQA,mBAAgC,IAAhC;IAER;;;;IAGQA,gBAAyB,IAAzB;IAER;;;;IAGQA,kBAAiC,IAAjC;IAER;;;;;;;IAMQA,0BAA6B,KAA7B;IAER;;;;IAGQA,oBAA6C,IAAIyB,GAAJ,EAA7C;IAER;;;;IAGQzB,eAAuBkB,MAAM,CAACQ,KAAP,CAAaC,YAApC;IAER;;;;IAGiB3B,4BAAkB4B,SACjCA,GAACV,MAAM,CAACQ,KAAP,CAAaG,SAAd,IAA0BX,MAAM,CAACY,SAAP,CAAiBD,SADV,EAEjCD,GAACV,MAAM,CAACQ,KAAP,CAAaC,YAAd,IAA6BT,MAAM,CAACY,SAAP,CAAiBH,YAFb,EAGjCC,GAACV,MAAM,CAACQ,KAAP,CAAaK,WAAd,IAA4Bb,MAAM,CAACY,SAAP,CAAiBC,WAHZ,EAIjCH,GAACV,MAAM,CAACQ,KAAP,CAAaM,UAAd,IAA2Bd,MAAM,CAACY,SAAP,CAAiBE,UAJX,IAAlB;IAOjB;;;;IAGQhC,gBAA2B,IAA3B;IAER;;;;IAGQA,gCAAoD,IAApD;IAOR;;;;IAGQA,gCAA+C,IAA/C;IA4YR;;;;;IAIQA,8BAAwB,UAACiC,IAAD,EAAY;MAC1C,IAAMC,OAAO,GAAwB;QACnCC,qBAAqB,EAAEnC,KAAI,CAACoC,QAAL,CAAc3B,4BADF;QAEnC4B,iBAAiB,EAAErC,KAAI,CAACsC,mBAFW;QAGnC9B,IAAI,EAAE,CAAC,CAACR,KAAI,CAACoC,QAAL,CAAc5B,IAHa;QAInC+B,mBAAmB,EAAE,IAJc;QAKnCC,QAAQ,EAAEnD,GAAG,CAACoD,cAAJ,EALyB;QAMnCC,WAAW,EAAEzD,CAAC,CAAC0D;MANoB,CAArC;;MASA,SAASC,YAAT,CAAsBC,YAAtB,EAA4CC,KAA5C,EAA4E;QAC1E,IAAIA,KAAJ,EAAW;UAAEZ,OAAO,CAACW,YAAD,CAAP,GAAwBC,KAAxB;QAAgC;MAC9C;;MAED,IAAIb,IAAJ,EAAU;QACR,IAAMc,OAAO,GAAGd,IAAI,CAACe,UAAL,CAAgBC,OAAhC;QACAL,YAAY,CAAC,UAAD,EAAa,MAAMM,IAAN,CAAWH,OAAX,IAAsBI,SAAtB,GAAkCJ,OAA/C,CAAZ;QACAH,YAAY,CAAC,eAAD,EAAkBX,IAAI,CAACmB,oBAAvB,CAAZ;QACAR,YAAY,CAAC,aAAD,EAAgBX,IAAI,CAACoB,KAArB,CAAZ;QACAnB,OAAO,CAACoB,SAAR,GAAoBrB,IAAI,CAACqB,SAAzB;MACD;;MAEDV,YAAY,CAAC,SAAD,EAAY5C,KAAI,CAACuD,OAAL,IAAgBvD,KAAI,CAACuD,OAAL,CAAaC,OAAzC,CAAZ;MACAZ,YAAY,CAAC,QAAD,EAAW5C,KAAI,CAACuD,OAAL,IAAgBvD,KAAI,CAACuD,OAAL,CAAaE,MAAxC,CAAZ;MAEA,OAAOvB,OAAP;IACD,CA1BO;IA2NR;;;;;IAGSlC,0BAAoB;MAC3BA,KAAI,CAACuD,OAAL,GAAe,IAAf;MACAvD,KAAI,CAAC0D,uBAAL,GAA+B,IAA/B;IACD,CAHQ;IAKT;;;;;IAGQ1D,8BAAwB,UAACkC,OAAD,EAA6B;;;MAC3D,IAAMuB,MAAM,GAAGE,6BAAmBzB,OAAO,CAACuB,MAA3B,CAAf;MACAzD,KAAI,CAAC4D,KAAL,GAAa1B,OAAO,CAAC2B,IAAR,IAAgBF,uBAAaF,MAAb,CAAhB,IAAkDvB,OAAO,CAACuB,MAAvE;MACAzD,KAAI,CAAC8D,OAAL,GAAeL,MAAM,IAAIvB,OAAO,CAACuB,MAAjC;MACA,WAAI,CAACM,UAAL,MAAe,IAAf,IAAe9C,aAAf,GAAe,MAAf,GAAeA,GAAE+C,OAAF,CAAUL,gCAAsBzB,OAAO,CAAC+B,IAA9B,CAAV,CAAf;;MACA,IAAI/B,OAAO,CAACrC,KAAZ,EAAmB;QACjBG,KAAI,CAACkE,SAAL,GAAiBhC,OAAO,CAACrC,KAAR,CAAcsE,QAA/B;;QACA,IACE,OAAOjC,OAAO,CAACrC,KAAR,CAAcuE,GAArB,KAA6B,QAA7B,IACA,OAAOpE,KAAI,CAACoC,QAAL,CAAcpB,cAArB,KAAwC,QAF1C,EAGE;UACA,IAAMqD,KAAK,GAAWnC,OAAO,CAACrC,KAAR,CAAcuE,GAAd,GAAoB,IAA1C;UACA,IAAME,SAAS,GAAWC,IAAI,CAACC,GAAL,CAAS,CAAT,EAAYH,KAAK,GAAGrE,KAAI,CAACoC,QAAL,CAAcpB,cAAlC,CAA1B;UACAhB,KAAI,CAACyE,uBAAL,GAA+BC,UAAU,CAAC;YACxC1E,KAAI,CAAC2E,IAAL,CAAU,iBAAV,EAA6B3E,KAA7B;;YACA,IAAIA,KAAI,CAACyE,uBAAT,EAAkC;cAChCG,YAAY,CAAC5E,KAAI,CAACyE,uBAAN,CAAZ;cACAzE,KAAI,CAACyE,uBAAL,GAA+B,IAA/B;YACD;UACF,CANwC,EAMtCH,SANsC,CAAzC;QAOD;MACF;;MACDtE,KAAI,CAAC6E,KAAL,GAAa3C,OAAO,CAAC+B,IAArB;MAEA,IAAMa,aAAa,GAAGnB,yBACpB3D,KAAI,CAAC4D,KADe,EAEpBT,SAFoB,EAGpBnD,KAAI,CAAC+E,IAAL,CAAUC,IAAV,CAAeC,IAAf,CAAoBjF,KAAI,CAAC+E,IAAzB,CAHoB,CAAtB;;MAKA,IAAID,aAAa,CAACI,MAAd,GAAuB,CAA3B,EAA8B;QACrB;QACPlF,KAAI,CAACmF,aAAL,GAAqBxB,qCAA2ByB,YAA3B,CAArB;MACD,CAHD,MAGO;QACLpF,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,kEAAf;MACD,CAlC0D,CAoC3D;MACA;;;MACA,IAAIrF,KAAI,CAACsF,iBAAT,EAA4B;QAC1BtF,KAAI,CAACuF,QAAL;MACD;IACF,CAzCO;IA2CR;;;;;IAGQvF,0BAAoB,UAACkC,OAAD,EAA6B;MACvD,IAAI,OAAOA,OAAP,KAAmB,QAAvB,EAAiC;QAAE;MAAS;;MAEpC;MAAA,IAAsBsD,yBAAtB;;MAER,IAAI,OAAOC,aAAP,KAAyB,QAA7B,EAAuC;QAAE;MAAS;;MAElD,IAAMxD,IAAI,GACP,OAAOuD,OAAP,KAAmB,QAAnB,IAA+BxF,KAAI,CAAC0F,SAAL,CAAeF,OAAf,CAAhC,IAA4DrC,SAD9D;MAGQ;MAAA,IAAMwC,qCAAN;MACF;;MAEN,IAAI,OAAOC,IAAP,KAAgB,QAApB,EAA8B;QAC5B,IAAIA,IAAI,KAAK,KAAb,EAAoB;UAClBC,WAAW,GAAG,IAAIC,6BAAoBC,oBAAxB,CAA6CN,aAA7C,CAAd;QACD,CAFD,MAEO,IAAIG,IAAI,KAAK,KAAb,EAAoB;UACzBC,WAAW,GAAG,IAAIC,6BAAoBE,kBAAxB,CAA2CP,aAA3C,CAAd;QACD,CAFM,MAEA,IAAIG,IAAI,KAAK,KAAb,EAAoB;UACzB;UACA5F,KAAI,CAACiG,sBAAL;;UACAJ,WAAW,GAAG,IAAIC,6BAAoBI,kBAAxB,CAA2CT,aAA3C,CAAd;QACD,CAJM,MAIA,IAAIK,wBAAeF,IAAf,CAAJ,EAA0B;UAC/BC,WAAW,GAAG,KAAKC,wBAAeF,IAAf,CAAL,EAA2BH,aAA3B,CAAd;QACD;MACF;;MAED,IAAI,CAACI,WAAL,EAAkB;QAChB7F,KAAI,CAAC+E,IAAL,CAAUoB,KAAV,CAAgB,2BAAhB,EAA6CV,aAA7C;;QACAI,WAAW,GAAG,IAAIC,uBAAcM,YAAlB,CAA+BT,aAA/B,EAA8CF,aAA9C,CAAd;MACD;;MAEDzF,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,kBAAf,EAAmCQ,WAAnC;;MACA7F,KAAI,CAAC2E,IAAL,CAAUzD,MAAM,CAACY,SAAP,CAAiBuE,KAA3B,EAAkCR,WAAlC,EAA+C5D,IAA/C;IACD,CAlCO;IAoCR;;;;;IAGQjC,2BAAqB,UAAOkC,OAAP,EAAmC;MAAA;;;;;;;;cACxDoE,OAAO,GAAG,CAAC,CAAC,KAAKC,WAAjB;;cACN,IAAID,OAAO,IAAI,CAAC,KAAKlE,QAAL,CAAcnC,sBAA9B,EAAsD;gBACpD,KAAK8E,IAAL,CAAUM,IAAV,CAAe,uCAAf;;gBACA;gBAAA;gBAAA;cACD;;cAED,IAAI,CAACnD,OAAO,CAACsD,OAAT,IAAoB,CAACtD,OAAO,CAACsE,GAAjC,EAAsC;gBACpC,KAAK7B,IAAL,CAAUzD,MAAM,CAACY,SAAP,CAAiBuE,KAA3B,EAAkC,IAAIP,sBAAaW,UAAjB,CAA4B,+BAA5B,CAAlC;gBACA;gBAAA;gBAAA;cACD;;cAEKC,cAAc,GAAGxE,OAAO,CAACc,UAAR,IAAsB,EAAvC;cACN0D,cAAc,CAACzD,OAAf,GAAyByD,cAAc,CAACzD,OAAf,IAA0Bf,OAAO,CAACsD,OAA3D;cAEMmB,gBAAgB,GAAGC,MAAM,CAACC,MAAP,CAAc,EAAd,EAAmBC,mBAAYJ,cAAc,CAACK,MAA3B,CAAnB,CAAnB;cAEO;cAAA;cAAA,EAAM,KAAKC,SAAL,CAAeL,gBAAf,EAAiC;gBAClDD,cAAc,gBADoC;gBAElDO,QAAQ,EAAE/E,OAAO,CAACsE,GAFgC;gBAGlDU,cAAc,EAAEhF,OAAO,CAACiF;cAH0B,CAAjC,CAAN;;;cAAPlF,IAAI,GAAGhB,SAAP;;cAMN,KAAKmG,MAAL,CAAYC,IAAZ,CAAiBpF,IAAjB;;cAEAA,IAAI,CAACqF,IAAL,CAAU,QAAV,EAAoB;gBAClBtH,KAAI,CAACuH,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgDoG,IAAhD;;gBACAzH,KAAI,CAAC0H,qBAAL;cACD,CAHD;cAKMC,IAAI,GAAI,KAAKC,cAAL,CAAoBC,QAApB,IAAgC,CAACvB,OAAlC,GACT;gBAAM,YAAI,CAACiB,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgDsG,IAAhD;cAAsD,CADnD,GAET;gBAAM,cAAO,CAACG,OAAR;cAAiB,CAFrB;;cAIN,KAAKC,iBAAL,CAAuB9F,IAAvB,EAA6B0F,IAA7B;;;;;;;OAlC8D;IAmC/D,CAnCO;IAqCR;;;;;IAGQ3H,4BAAsB;MAC5BA,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,mBAAf;;MAEArF,KAAI,CAAC4D,KAAL,GAAa,IAAb;MACA5D,KAAI,CAAC8D,OAAL,GAAe,IAAf;MAEA9D,KAAI,CAACsF,iBAAL,GAAyBtF,KAAI,CAACgI,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaC,YAArD;;MAEA3B,KAAI,CAACiI,SAAL,CAAe/G,MAAM,CAACQ,KAAP,CAAaC,YAA5B;IACD,CATO;IAWR;;;;;IAGQ3B,0BAAoB;MAC1BA,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,iBAAf;;MAEArF,KAAI,CAACiI,SAAL,CAAe/G,MAAM,CAACQ,KAAP,CAAaM,UAA5B;IACD,CAJO;IAMR;;;;;IAGQhC,8BAAwB;MAC9B,IAAI,CAACA,KAAI,CAACuG,WAAV,EAAuB;QACrB;MACD;;MAED,IAAIvG,KAAI,CAACkI,mBAAT,EAA8B;QAC5BlI,KAAI,CAAC+D,UAAL,CAAgBsB,IAAhB,CAAqB,qBAArB,EAA4C,gBAA5C,EAA8D;UAC5D8C,eAAe,EAAEnI,KAAI,CAACkI,mBAAL,CAAyBE,IADkB;UAE5DC,QAAQ,EAAErI,KAAI,CAACkI,mBAAL,CAAyBG,QAFyB;UAG5DC,WAAW,EAAEtI,KAAI,CAACkI,mBAAL,CAAyBI,WAHsB;UAI5DC,cAAc,EAAEvI,KAAI,CAACkI,mBAAL,CAAyBM,aAJmB;UAK5DC,GAAG,EAAEzI,KAAI,CAACkI,mBAAL,CAAyBO;QAL8B,CAA9D,EAMGzI,KAAI,CAACuG,WANR;MAOD;IACF,CAdO;IAsNR;;;;;;;IAKQvG,2BAAqB,UAAC0I,WAAD,EAAgC;MAC3D,IAAMzG,IAAI,GAAgBjC,KAAI,CAACuG,WAA/B;;MAEA,IAAItE,IAAI,IAAI,CAACyG,WAAb,EAA0B;QACxB,OAAOC,OAAO,CAACC,MAAR,CAAe,IAAI9C,0BAAJ,CAAsB,wDAAtB,CAAf,CAAP;MACD;;MAED9F,KAAI,CAAC6I,gBAAL,GAAwBH,WAAxB;MACA,OAAOzG,IAAI,GACPA,IAAI,CAAC6G,yBAAL,CAA+BJ,WAA/B,CADO,GAEPC,OAAO,CAACb,OAAR,EAFJ;IAGD,CAXO;IAqBR;;;;;;;IAKQ9H,uBAAiB,UAACoI,IAAD,EAA+BW,OAA/B,EAAgD;MACvE,IAAMC,OAAO,GAAkBZ,IAAI,KAAK,UAAT,GAC3BpI,KAAI,CAACiJ,sBAAL,CAA4BF,OAA5B,CAD2B,GAE3B/I,KAAI,CAACkJ,qBAAL,CAA2BH,OAA3B,CAFJ;MAIA,OAAOC,OAAO,CAACG,IAAR,CAAa;QAClBnJ,KAAI,CAAC+D,UAAL,CAAgBsB,IAAhB,CAAqB,OAArB,EAAiC+C,IAAI,iBAArC,EAAqD;UACnDgB,gBAAgB,EAAEL;QADiC,CAArD,EAEG/I,KAAI,CAACuG,WAFR;MAGD,CAJM,EAIJ,iBAAK;QACNvG,KAAI,CAAC+D,UAAL,CAAgBoC,KAAhB,CAAsB,OAAtB,EAAkCiC,IAAI,wBAAtC,EAA6D;UAC3DgB,gBAAgB,EAAEL,OADyC;UAE3DM,OAAO,EAAElD,KAAK,CAACkD;QAF4C,CAA7D,EAGGrJ,KAAI,CAACuG,WAHR;;QAKA,MAAMJ,KAAN;MACD,CAXM,CAAP;IAYD,CAjBO;;IAp/BNnG,KAAI,CAACsJ,WAAL,CAAiBzJ,KAAjB;;IAEA,IAAIiH,qBAAJ,EAAoB;MAClB,MAAM,IAAIhB,0BAAJ,CACJ,4GACA,8GADA,GAEA,iEAFA,GAGA,wEAJI,CAAN;IAMD;;IAED,IAAI,CAAC5E,MAAM,CAACqI,WAAR,IAAwBzJ,OAAkC,CAAC0J,oBAA/D,EAAqF;MACnF,IAAIC,MAAM,IAAIA,MAAM,CAACC,QAAjB,IAA6BD,MAAM,CAACC,QAAP,CAAgBC,QAAhB,KAA6B,OAA9D,EAAuE;QACrE,MAAM,IAAI7D,0BAAJ,CAAsB,kQAAtB,CAAN;MAID;;MAED,MAAM,IAAIA,0BAAJ,CAAsB,kQAAtB,CAAN;IAID;;IAED,IAAI2D,MAAJ,EAAY;MACV,IAAMG,IAAI,GAAQH,MAAlB;MACA,IAAMI,OAAO,GAAQD,IAAI,CAACE,SAAL,IAAkBF,IAAI,CAACC,OAAvB,IAAkCD,IAAI,CAACG,MAA5D;MAEA/J,KAAI,CAACsC,mBAAL,GAA4B,CAAC,CAACuH,OAAF,IAAa,CAAC,CAACA,OAAO,CAACG,OAAvB,IAAkC,CAAC,CAACH,OAAO,CAACG,OAAR,CAAgBC,EAArD,IACrB,CAAC,CAACL,IAAI,CAACM,MAAP,IAAiB,CAAC,CAACN,IAAI,CAACM,MAAL,CAAYC,SADrC;IAED;;IAED,IAAInK,KAAI,CAACsC,mBAAT,EAA8B;MAC5BtC,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,+BAAf;IACD;;IAED,IAAI+E,SAAJ,EAAe;MACb,IAAMC,CAAC,GAAGD,SAAV;MACApK,KAAI,CAACkI,mBAAL,GAA2BmC,CAAC,CAACC,UAAF,IACtBD,CAAC,CAACE,aADoB,IAEtBF,CAAC,CAACG,gBAFP;IAGD;;IAED,IAAIxK,KAAI,CAACkI,mBAAL,IAA4B,OAAOlI,KAAI,CAACkI,mBAAL,CAAyBuC,gBAAhC,KAAqD,UAArF,EAAiG;MAC/FzK,KAAI,CAACkI,mBAAL,CAAyBuC,gBAAzB,CAA0C,QAA1C,EAAoDzK,KAAI,CAAC0H,qBAAzD;IACD;;IAEDxG,MAAM,CAACwJ,wBAAP;;IAEA,IAAIxJ,MAAM,CAACyJ,aAAX,EAA0B;MACxB,IAAI,CAACzJ,MAAM,CAAC0J,eAAZ,EAA6B;QAC3B1J,MAAM,CAAC0J,eAAP,GAAyB,IAAIC,wBAAJ,CAAmB3J,MAAM,CAACyJ,aAA1B,CAAzB;MACD;IACF;;IAED,IAAI,OAAOzJ,MAAM,CAAC4J,qBAAd,KAAwC,WAA5C,EAAyD;MACvD5J,MAAM,CAAC4J,qBAAP,GAA+B,OAAOrB,MAAP,KAAkB,WAAlB,IAC1B,OAAOsB,iBAAP,KAA6B,WADH,IAE1B,OAAOC,iBAAP,KAA6B,WAFH,GAG7BlE,4BAAqB2C,MAArB,EAA6BA,MAAM,CAACW,SAApC,EAA+CW,iBAA/C,EAAkEC,iBAAlE,CAH6B,GAI7B,KAJF;IAKD;;IAEDhL,KAAI,CAACiL,aAAL,GAAqBjL,KAAI,CAACkL,OAAL,CAAajG,IAAb,CAAkBjF,KAAlB,CAArB;IACAA,KAAI,CAACmL,kBAAL,GAA0BnL,KAAI,CAACoL,aAAL,CAAmBnG,IAAnB,CAAwBjF,KAAxB,CAA1B;;IAEA,IAAI,OAAOyJ,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACgB,gBAA5C,EAA8D;MAC5DhB,MAAM,CAACgB,gBAAP,CAAwB,QAAxB,EAAkCzK,KAAI,CAACiL,aAAvC;MACAxB,MAAM,CAACgB,gBAAP,CAAwB,UAAxB,EAAoCzK,KAAI,CAACiL,aAAzC;IACD;;IAEDjL,KAAI,CAACqL,aAAL,CAAmBvL,OAAnB;;;EACD;;EA3WD8G,sBAAW1F,MAAX,EAAW,cAAX,EAAuB;IAJvB;;;;SAIA;MACE,OAAOA,MAAM,CAACyJ,aAAd;IACD,CAFsB;oBAAA;;EAAA,CAAvB;EAQA/D,sBAAW1F,MAAX,EAAW,WAAX,EAAoB;IAJpB;;;;SAIA;MACE;MACA,IAAMoK,CAAC,GAAQ,OAAOC,QAAP,KAAoB,WAApB,GACXA,QAAQ,CAACC,aAAT,CAAuB,OAAvB,CADW,GACuB;QAAEC,WAAW,EAAE;MAAf,CADtC;MAGA,IAAIC,UAAJ;;MACA,IAAI;QACFA,UAAU,GAAGJ,CAAC,CAACG,WAAF,IAAiB,CAAC,CAACH,CAAC,CAACG,WAAF,CAAc,YAAd,EAA4BE,OAA5B,CAAoC,IAApC,EAA0C,EAA1C,CAAhC;MACD,CAFD,CAEE,OAAOC,CAAP,EAAU;QACVF,UAAU,GAAG,KAAb;MACD;;MAED,IAAIG,aAAJ;;MACA,IAAI;QACFA,aAAa,GAAGP,CAAC,CAACG,WAAF,IAAiB,CAAC,CAACH,CAAC,CAACG,WAAF,CAAc,6BAAd,EAA6CE,OAA7C,CAAqD,IAArD,EAA2D,EAA3D,CAAnC;MACD,CAFD,CAEE,OAAOC,CAAP,EAAU;QACVC,aAAa,GAAG,KAAhB;MACD;;MAED,OAAQA,aAAa,IAAI,CAACH,UAAnB,GAAiC,KAAjC,GAAyC,KAAhD;IACD,CApBmB;oBAAA;;EAAA,CAApB;EAyBA9E,sBAAW1F,MAAX,EAAW,aAAX,EAAsB;IAHtB;;;SAGA;MAAoC,OAAO7B,GAAG,CAACyM,OAAJ,EAAP;IAAuB,CAArC;oBAAA;;EAAA,CAAtB;EAKAlF,sBAAW1F,MAAX,EAAW,aAAX,EAAsB;IAHtB;;;SAGA;MAAmC,OAAOjC,CAAC,CAAC8M,YAAT;IAAwB,CAArC;oBAAA;;EAAA,CAAtB;EAEA;;;;;;EAKO7K,sBAAP,UAAoBrB,KAApB,EAAmCC,OAAnC,EAAkE;IAChE,OAAO,IAAIkM,yBAAJ,CAAkBnM,KAAlB,EAAuBoM;MAAIC,YAAY,EAAEhL,MAAM,CAACwJ,wBAAP;IAAlB,GAAwD5K,OAAxD,CAAvB,CAAP;EACD,CAFM;EAIP;;;;;;EAIOoB,kBAAP;IACE,OAAO,uBAAP;EACD,CAFM;;EAOP0F,sBAAW1F,MAAX,EAAW,SAAX,EAAkB;IAHlB;;;SAGA;MAA+B,OAAOjC,CAAC,CAAC0D,eAAT;IAA2B,CAAxC;oBAAA;;EAAA,CAAlB;EAmCA;;;;;EAIezB,kCAAf;IACE,IAAI,CAACA,MAAM,CAACyJ,aAAZ,EAA2B;MACzB,IAAI,OAAOwB,YAAP,KAAwB,WAA5B,EAAyC;QACvCjL,MAAM,CAACyJ,aAAP,GAAuB,IAAIwB,YAAJ,EAAvB;MACD,CAFD,MAEO,IAAI,OAAOC,kBAAP,KAA8B,WAAlC,EAA+C;QACpDlL,MAAM,CAACyJ,aAAP,GAAuB,IAAIyB,kBAAJ,EAAvB;MACD;IACF;;IACD,OAAOlL,MAAM,CAACyJ,aAAd;EACD,CATc;;EA6Qf/D,sBAAI1F,gBAAJ,EAAI,OAAJ,EAAS;IAHT;;;SAGA;MACE,OAAO,KAAKmL,MAAZ;IACD,CAFQ;oBAAA;;EAAA,CAAT;EAIA;;;;;EAIMnL,2BAAN,UAAcpB,OAAd,EAAkD;IAApC;MAAAA;IAAoC;;;;;;;;YAChD,KAAKwM,iBAAL;;YAEA,IAAI,KAAK/F,WAAT,EAAsB;cACpB,MAAM,IAAIT,0BAAJ,CAAsB,0BAAtB,CAAN;YACD;;YAEkB7E;YAAmB;YAAA;YAAA,EAAM,KAAK+F,SAAL,CAAelH,OAAO,CAACyM,MAAR,IAAkB,EAAjC,EAAsC;cAChFC,gBAAgB,EAAE1M,OAAO,CAAC0M;YADsD,CAAtC,CAAN;;;YAAhCC,UAAU,GAAGxL,GAAKsF,WAAL,GAAmB3E,SAAhC,EAIN;;YACA,KAAKwF,MAAL,CAAYsF,MAAZ,CAAmB,CAAnB,EAAsBC,OAAtB,CAA8B,gBAAI;cAAI,WAAI,CAACC,MAAL;YAAa,CAAnD,GAEA;;;YACA,KAAKrF,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgDoG,IAAhD;;YAEAgF,UAAU,CAACI,MAAX,CAAkB;cAAEC,cAAc,EAAEhN,OAAO,CAACgN;YAA1B,CAAlB;;YACA,KAAKpF,qBAAL;;YACA;YAAA;YAAA,EAAO+E,UAAP;;;;EACD,CApBK;;EAyBN7F,sBAAI1F,gBAAJ,EAAI,OAAJ,EAAS;IAHT;;;SAGA;MACE,OAAO,KAAKkG,MAAZ;IACD,CAFQ;oBAAA;;EAAA,CAAT;EAIA;;;;EAGAlG;IACE,KAAK6L,aAAL;;IACA,KAAK9G,sBAAL;;IAEA,IAAI,KAAKoG,MAAT,EAAiB;MACf,KAAKA,MAAL,CAAYW,OAAZ;IACD;;IAED,KAAKC,cAAL;;IACA,KAAKC,iBAAL;;IACA,KAAKC,mBAAL;;IAEA,IAAI,KAAKjF,mBAAL,IAA4B,OAAO,KAAKA,mBAAL,CAAyBkF,mBAAhC,KAAwD,UAAxF,EAAoG;MAClG,KAAKlF,mBAAL,CAAyBkF,mBAAzB,CAA6C,QAA7C,EAAuD,KAAK1F,qBAA5D;IACD;;IAED,IAAI,OAAO+B,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAAC2D,mBAA5C,EAAiE;MAC/D3D,MAAM,CAAC2D,mBAAP,CAA2B,cAA3B,EAA2C,KAAKjC,kBAAhD;MACA1B,MAAM,CAAC2D,mBAAP,CAA2B,QAA3B,EAAqC,KAAKnC,aAA1C;MACAxB,MAAM,CAAC2D,mBAAP,CAA2B,UAA3B,EAAuC,KAAKnC,aAA5C;IACD;;IAED,KAAKhD,SAAL,CAAe/G,MAAM,CAACQ,KAAP,CAAaG,SAA5B;;IACAwL,sBAAaC,SAAb,CAAuBC,kBAAvB,CAA0CtL,IAA1C,CAA+C,IAA/C;EACD,CAxBD;EA0BA;;;;;EAGAf;IACE,IAAMsM,KAAK,GAAG,KAAKpG,MAAL,CAAYsF,MAAZ,CAAmB,CAAnB,CAAd;;IACAc,KAAK,CAACb,OAAN,CAAc,UAAC1K,IAAD,EAAW;MAAK,WAAI,CAACwL,UAAL;IAAiB,CAA/C;;IAEA,IAAI,KAAKlH,WAAT,EAAsB;MACpB,KAAKA,WAAL,CAAiBkH,UAAjB;IACD;EACF,CAPD;;EAaA7G,sBAAI1F,gBAAJ,EAAI,MAAJ,EAAQ;IAJR;;;;SAIA;MACE,OAAO,KAAK0C,KAAZ;IACD,CAFO;oBAAA;;EAAA,CAAR;EAQAgD,sBAAI1F,gBAAJ,EAAI,MAAJ,EAAQ;IAJR;;;;SAIA;MACE,OAAO,KAAK2D,KAAZ;IACD,CAFO;oBAAA;;EAAA,CAAR;EAQA+B,sBAAI1F,gBAAJ,EAAI,UAAJ,EAAY;IAJZ;;;;SAIA;MACE,OAAO,KAAKgD,SAAZ;IACD,CAFW;oBAAA;;EAAA,CAAZ;EAOA0C,sBAAI1F,gBAAJ,EAAI,QAAJ,EAAU;IAHV;;;SAGA;MACE,OAAO,CAAC,CAAC,KAAKqF,WAAd;IACD,CAFS;oBAAA;;EAAA,CAAV;EAIA;;;;EAGMrF,4BAAN;;;;;;;;;YACE,IAAI,KAAK8G,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaC,YAAhC,EAA8C;cAC5C,MAAM,IAAImE,0BAAJ,CACJ,mDAAgD,KAAKkC,KAArD,GAA0D,MAA1D,IACA,eAAY9G,MAAM,CAACQ,KAAP,CAAaC,YAAzB,GAAqC,KADrC,CADI,CAAN;YAID;;YAED,KAAKsG,SAAL,CAAe/G,MAAM,CAACQ,KAAP,CAAaK,WAA5B;;YAEe;YAAA;YAAA,EAAO,KAAK2B,uBAAL,IAAgC,KAAKgK,YAAL,EAAvC;;;YAATC,MAAM,GAAG1M,SAAT;YACA2M,kBAAkB,GAAG,IAAIjF,OAAJ,CAAY,mBAAO;cAC5C3I,KAAI,CAACsH,IAAL,CAAUpG,MAAM,CAACQ,KAAP,CAAaM,UAAvB,EAAmC8F,OAAnC;YACD,CAF0B,CAArB;YAGN;YAAA;YAAA,EAAM,KAAK+F,aAAL,CAAmB,IAAnB,CAAN;;;YAAA5M;;YACA;YAAA;YAAA,EAAM2M,kBAAN;;;YAAA3M;;;;;;;;EACD,CAhBK;;EAqBN2F,sBAAI1F,gBAAJ,EAAI,OAAJ,EAAS;IAHT;;;SAGA;MACE,OAAO,KAAK4M,MAAZ;IACD,CAFQ;oBAAA;;EAAA,CAAT;EAOAlH,sBAAI1F,gBAAJ,EAAI,OAAJ,EAAS;IAHT;;;SAGA;MACE,OAAO,KAAK6M,MAAZ;IACD,CAFQ;oBAAA;;EAAA,CAAT;EAIA;;;;;EAIA7M;IACE,OAAO,0BAAP;EACD,CAFD;EAIA;;;;;;EAIMA,8BAAN;;;;;;YACE,IAAI,KAAK8G,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaM,UAAhC,EAA4C;cAC1C,MAAM,IAAI8D,0BAAJ,CACJ,qDAAkD,KAAKkC,KAAvD,GAA4D,MAA5D,IACA,eAAY9G,MAAM,CAACQ,KAAP,CAAaM,UAAzB,GAAmC,KADnC,CADI,CAAN;YAID;;YAED,KAAKsD,iBAAL,GAAyB,KAAzB;YAEe;YAAA;YAAA,EAAM,KAAK5B,uBAAX;;;YAATiK,MAAM,GAAG1M,SAAT;YACA+M,oBAAoB,GAAG,IAAIrF,OAAJ,CAAY,mBAAO;cAC9CgF,MAAM,CAACM,EAAP,CAAU,SAAV,EAAqBnG,OAArB;YACD,CAF4B,CAAvB;YAGN;YAAA;YAAA,EAAM,KAAK+F,aAAL,CAAmB,KAAnB,CAAN;;;YAAA5M;;YACA;YAAA;YAAA,EAAM+M,oBAAN;;;YAAA/M;;;;;;;;EACD,CAhBK;EAkBN;;;;;;EAIAC,2CAAcpB,OAAd,EAA2C;IAA7B;MAAAA;IAA6B;;IACzC,IAAI,KAAKkI,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaG,SAAhC,EAA2C;MACzC,MAAM,IAAIiE,0BAAJ,CACJ,4DAAuD,KAAKkC,KAA5D,GAAiE,KAD7D,CAAN;IAGD;;IAED,KAAK5F,QAAL,GAAa6J,+BAAQ,KAAKiC,eAAb,GAAiC,KAAK9L,QAAtC,GAAmDtC,OAAnD,CAAb;IAEA,IAAMqO,mBAAmB,GAAgB,IAAIC,GAAJ,CAAQ,KAAKC,YAAb,CAAzC;IAEA,IAAMC,QAAQ,GAAG,OAAO,KAAKlM,QAAL,CAAckM,QAArB,KAAkC,QAAlC,GACb,CAAC,KAAKlM,QAAL,CAAckM,QAAf,CADa,GAEbC,KAAK,CAACC,OAAN,CAAc,KAAKpM,QAAL,CAAckM,QAA5B,KAAyC,KAAKlM,QAAL,CAAckM,QAF3D;IAIA,IAAMG,cAAc,GAAG,KAAKJ,YAAL,GAAoB,CACzCC,QAAQ,IAAI3K,yBACV,KAAKvB,QAAL,CAAcyB,IADJ,EAEVV,SAFU,EAGV,KAAK4B,IAAL,CAAUC,IAAV,CAAeC,IAAf,CAAoB,KAAKF,IAAzB,CAHU,CAD6B,EAMzC2J,GANyC,CAMrC/K,oCANqC,CAA3C;IAQA,IAAIgL,qBAAqB,GACvBR,mBAAmB,CAACS,IAApB,KAA6BH,cAAc,CAACvJ,MAD9C;;IAGA,IAAI,CAACyJ,qBAAL,EAA4B;MAC1B,KAAkB,6CAAlB,EAAkBE,4BAAlB,EAAkBA,IAAlB,EAAkC;QAA7B,IAAMC,GAAG,uBAAT;;QACH,IAAI,CAACX,mBAAmB,CAACY,GAApB,CAAwBD,GAAxB,CAAL,EAAmC;UACjCH,qBAAqB,GAAG,IAAxB;UACA;QACD;MACF;IACF;;IAED,IAAI,KAAKK,MAAL,IAAeL,qBAAnB,EAA0C;MACxC,MAAM,IAAI7I,0BAAJ,CAAsB,4CAAtB,CAAN;IACD;;IAED,KAAKf,IAAL,CAAUkK,eAAV,CACE,OAAO,KAAK7M,QAAL,CAAc1B,QAArB,KAAkC,QAAlC,GACI,KAAK0B,QAAL,CAAc1B,QADlB,GAEIC,kBAAUC,KAHhB;;IAMA,IAAI,KAAKwB,QAAL,CAAc5B,IAAlB,EAAwB;MACtB,IAAI,CAAC,KAAK4B,QAAL,CAAc0K,cAAnB,EAAmC;QACjC,KAAK1K,QAAL,CAAc0K,cAAd,GAA+B,EAA/B;MACD;;MACA,KAAK1K,QAAL,CAAc0K,cAAd,CAAqCoC,QAArC,GAAgD,CAAC;QAAEC,QAAQ,EAAE;MAAZ,CAAD,CAAhD;IACF;;IAED,KAAmB,uBAAM,CAACC,IAAP,CAAYlO,MAAM,CAACmO,cAAnB,CAAnB,EAAmBpO,cAAnB,EAAmBA,IAAnB,EAAuD;MAAlD,IAAMqO,MAAI,SAAV;MACH,IAAMC,QAAQ,GAAqBrO,MAAM,CAACmO,cAAP,CAAsBC,MAAtB,CAAnC;MAEA,IAAME,UAAU,GAAcvQ,CAAC,CAACwQ,eAAF,GAAiB,GAAjB,GAAqBF,QAAQ,CAACG,QAA9B,GAAsC,GAAtC,GAA0CxO,MAAM,CAACiJ,SAAjD,IAC1B,YAAUlL,CAAC,CAAC0D,eADc,CAA9B;MAGA,IAAMgN,QAAQ,GAAW,KAAKvN,QAAL,CAAcrB,MAAd,IAAwB,KAAKqB,QAAL,CAAcrB,MAAd,CAAqBuO,MAArB,CAAxB,IAA0EE,UAAnG;MACA,IAAMI,KAAK,GAAQ,KAAK,KAAKxN,QAAL,CAAc7C,KAAd,IAAuBA,KAA5B,EAAmC+P,MAAnC,EAAyCK,QAAzC,EAAmD;QACpEzD,YAAY,EAAE,KAAK9J,QAAL,CAAcyN,yBAAd,GAA0C,IAA1C,GAAiD3O,MAAM,CAACgL,YADF;QAEpE4D,WAAW,EAAEP,QAAQ,CAACO,WAF8C;QAGpEC,UAAU,EAAER,QAAQ,CAACQ;MAH+C,CAAnD,CAAnB;;MAMA,KAAKxI,WAAL,CAAiByI,GAAjB,CAAqBV,MAArB,EAA+CM,KAA/C;IACD;;IAED,KAAKK,iBAAL;;IACA,KAAKC,eAAL;;IAEA,IAAIvB,qBAAqB,IAAI,KAAKjL,uBAAlC,EAA2D;MACzD,KAAKgK,YAAL;IACD,CAzEwC,CA2EzC;;;IACA,IACE,OAAOjE,MAAP,KAAkB,WAAlB,IACA,OAAOA,MAAM,CAACgB,gBAAd,KAAmC,UADnC,IAEA,KAAKrI,QAAL,CAAclC,eAHhB,EAIE;MACAuJ,MAAM,CAAC2D,mBAAP,CAA2B,cAA3B,EAA2C,KAAKjC,kBAAhD;MACA1B,MAAM,CAACgB,gBAAP,CAAwB,cAAxB,EAAwC,KAAKU,kBAA7C;IACD;EACF,CApFD;EAsFA;;;;;;EAIAjK,yCAAYrB,KAAZ,EAAyB;IACvB,IAAI,KAAKmI,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaG,SAAhC,EAA2C;MACzC,MAAM,IAAIiE,0BAAJ,CACJ,0DAAqD,KAAKkC,KAA1D,GAA+D,KAD3D,CAAN;IAGD;;IAED,IAAI,OAAOnI,KAAP,KAAiB,QAArB,EAA+B;MAC7B,MAAM,IAAIiG,6BAAJ,CAAyBnG,qBAAzB,CAAN;IACD;;IAED,KAAKoO,MAAL,GAAclO,KAAd;;IAEA,IAAI,KAAK0D,OAAT,EAAkB;MAChB,KAAKA,OAAL,CAAa4M,QAAb,CAAsB,KAAKpC,MAA3B;IACD;;IAED,IAAI,KAAKhK,UAAT,EAAqB;MACnB,KAAKA,UAAL,CAAgBoM,QAAhB,CAAyB,KAAKpC,MAA9B;IACD;EACF,CApBD;EAsBA;;;;;;;EAKQ7M,iCAAR,UAAsBkP,KAAtB,EAAgC;IAC9B,IAAI,CAAC,KAAK7J,WAAV,EAAuB;MAAE,OAAO,EAAP;IAAY;;IAErC,IAAMrG,eAAe,GAAqB,KAAKkC,QAAL,CAAclC,eAAd,IAAiC,KAA3E;IACA,IAAMmQ,eAAe,GAAW,OAAOnQ,eAAP,KAA2B,QAA3B,GAC5B,oFAD4B,GAE5BA,eAFJ;IAIA,CAACkQ,KAAK,IAAI3G,MAAM,CAAC2G,KAAjB,EAAwBE,WAAxB,GAAsCD,eAAtC;IACA,OAAOA,eAAP;EACD,CAVO;EA4CR;;;;;EAGQnP,uCAAR;IACE,IAAI,CAAC,KAAKmL,MAAV,EAAkB;MAAE;IAAS;;IAE7B,KAAKA,MAAL,CAAYkB,kBAAZ;;IACA,KAAKlB,MAAL,GAAc,IAAd;EACD,CALO;EAOR;;;;;EAGQnL,qCAAR;IACE;IACA,IAAI,CAAC,KAAK6C,UAAV,EAAsB;MAAE;IAAS;;IAEjC,KAAKA,UAAL,GAAkB,IAAlB;EACD,CALO;EAOR;;;;;EAGQ7C,kCAAR;IACE,IAAI,KAAKqC,OAAT,EAAkB;MAChB,KAAKA,OAAL,CAAagN,cAAb,CAA4B,OAA5B,EAAqC,KAAKC,iBAA1C;;MACA,KAAKjN,OAAL,CAAagN,cAAb,CAA4B,WAA5B,EAAyC,KAAKE,qBAA9C;;MACA,KAAKlN,OAAL,CAAagN,cAAb,CAA4B,OAA5B,EAAqC,KAAKG,iBAA1C;;MACA,KAAKnN,OAAL,CAAagN,cAAb,CAA4B,QAA5B,EAAsC,KAAKI,kBAA3C;;MACA,KAAKpN,OAAL,CAAagN,cAAb,CAA4B,SAA5B,EAAuC,KAAKK,mBAA5C;;MACA,KAAKrN,OAAL,CAAagN,cAAb,CAA4B,OAA5B,EAAqC,KAAKM,iBAA1C;;MAEA,KAAKtN,OAAL,CAAa2H,OAAb;;MACA,KAAK3H,OAAL,GAAe,IAAf;IACD;;IAED,KAAKqN,mBAAL;;IAEA,KAAKlN,uBAAL,GAA+B,IAA/B;EACD,CAhBO;EAkBR;;;;;;EAIQxC,6BAAR,UAAkB6B,OAAlB,EAAiC;IAC/B,OAAO,KAAKqE,MAAL,CAAY0J,IAAZ,CAAiB,gBAAI;MAAI,WAAI,CAAC9N,UAAL,CAAgBC,OAAhB,KAA4BF,OAA5B,IAC3Bd,IAAI,CAACmB,oBAAL,KAA8BL,OADH;IACU,CADnC,KACwC,IAD/C;EAED,CAHO;EAKR;;;;;;;EAKc7B,6BAAd,UAAwB6P,WAAxB,EAA6DjR,OAA7D,EAAmF;;;;;;;;;YACjF,IAAI,OAAOoB,MAAM,CAAC4J,qBAAd,KAAwC,WAA5C,EAAyD;cACvD,MAAM,IAAIhF,0BAAJ,CAAsB,kCAAtB,CAAN;YACD;;;cAGCkL,WAAW,EAAE,KAAK3E;cAClB/M,YAAY;cACZ2R,oBAAoB,EAAE/P,MAAM,CAAC4J;cAC7BoG,QAAQ,EAAE;gBACRlR,KAAI,CAACuH,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgDoG,IAAhD;cACD;;YACQ;YAAA;YAAA,EAAO,KAAK/D,uBAAL,IAAgC,KAAKgK,YAAL,EAAvC;;;YAPLyD,MAAM,IAOVlQ,aAASW,SAAT,EACAX,eAAW,KAAK8C,UADhB,EAEA9C,gBAAY,KAAKsG,WAFjB,IAPU,CAAN;YAYNzH,OAAO,GAAG8G,MAAM,CAACC,MAAP,CAAc;cACtBuK,WAAW,EAAE,KAAKhP,QAAL,CAAcgP,WAAd,IAA6B/R,GAAG,CAACgS,cADxB;cAEtBC,YAAY,EAAE,UAACC,WAAD,EAAkB;gBAC9B,IAAI,CAACvR,KAAI,CAACuG,WAAN,IAAqBvG,KAAI,CAACuG,WAAL,KAAqBgL,WAA9C,EAA2D;kBACzD;gBACD;;gBAEDvR,KAAI,CAACuG,WAAL,CAAiBkH,UAAjB;;gBACAzN,KAAI,CAACwR,WAAL,CAAiBxR,KAAI,CAACuG,WAAtB;cACD,CATqB;cAUtBpG,gBAAgB,EAAE,KAAKiC,QAAL,CAAcjC,gBAVV;cAWtBsR,cAAc,EAAEvQ,MAAM,CAAC0J,eAXD;cAYtBpK,IAAI,EAAE,KAAK4B,QAAL,CAAc5B,IAZE;cAatBC,4BAA4B,EAAE,KAAK2B,QAAL,CAAc3B,4BAbtB;cActBiR,cAAc,EAAE;gBAA0B,YAAI,CAACtP,QAAL,CAAcuP,eAAd,IAAiC3R,KAAI,CAAC6I,gBAAtC;cAAsD,CAd1E;cAetB+I,UAAU,EAAE;gBAAgB,YAAI,CAACC,YAAL;cAAiB,CAfvB;cAgBtBC,iBAAiB,EAAE,KAAK1P,QAAL,CAAc0P,iBAhBX;cAiBtBhR,SAAS,EAAE,KAAKsB,QAAL,CAActB,SAjBH;cAkBtBgM,cAAc,EAAE,KAAK1K,QAAL,CAAc0K,cAlBR;cAmBtBiF,oBAAoB,EAAE;gBAAM,YAAI,CAACnK,cAAL,CAAoB6F,UAApB;cAA8B,CAnBpC;cAoBtBsD,WAAW;YApBW,CAAd,EAqBPjR,OArBO,CAAV;;YAuBMkS,sBAAsB,GAAG;cAC7B,IAAIhS,KAAI,CAACuG,WAAL,KAAqB,IAArB,IAA6BvG,KAAI,CAACoH,MAAL,CAAYlC,MAAZ,KAAuB,CAAxD,EAA2D;gBACzDlF,KAAI,CAACuD,OAAL,CAAa0O,kBAAb,CAAgC,IAAhC;cACD;YACF,CAJK;;YAMAhQ,IAAI,GAAG,KAAK,KAAKG,QAAL,CAAc8P,IAAd,IAAsB9R,cAA3B,EAAiC+Q,MAAjC,EAAyCrR,OAAzC,CAAP;YAENmC,IAAI,CAACqF,IAAL,CAAU,QAAV,EAAoB;cAClBtH,KAAI,CAACuD,OAAL,CAAa0O,kBAAb,CAAgCjS,KAAI,CAACmF,aAArC;;cACAnF,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;;cACAjC,KAAI,CAACuG,WAAL,GAAmBtE,IAAnB;;cACA,IAAIjC,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAY8F,wBAAZ;cACD;;cAED,IAAIlQ,IAAI,CAACqB,SAAL,KAAmBlD,eAAKgS,aAAL,CAAmB9Q,QAAtC,IAAkDtB,KAAI,CAAC4H,cAAL,CAAoByK,QAA1E,EAAoF;gBAClFrS,KAAI,CAACuH,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBG,QAAtC,EAAgDqG,IAAhD;cACD;;cAED,IAAM2K,IAAI,GAAQ;gBAAEzO,IAAI,EAAE7D,KAAI,CAAC4D,KAAL,IAAc5D,KAAI,CAAC8D;cAA3B,CAAlB;;cACA,IAAI9D,KAAI,CAACoC,QAAL,CAAcyB,IAAlB,EAAwB;gBACtByO,IAAI,CAAC,eAAD,CAAJ,GAAwB/D,KAAK,CAACC,OAAN,CAAcxO,KAAI,CAACoC,QAAL,CAAcyB,IAA5B,IACpB7D,KAAI,CAACoC,QAAL,CAAcyB,IADM,GAEpB,CAAC7D,KAAI,CAACoC,QAAL,CAAcyB,IAAf,CAFJ;cAGD;;cAED7D,KAAI,CAAC+D,UAAL,CAAgBsB,IAAhB,CAAqB,UAArB,EAAiC,MAAjC,EAAyCiN,IAAzC,EAA+CrQ,IAA/C;YACD,CApBD;YAsBAA,IAAI,CAACsQ,WAAL,CAAiB,OAAjB,EAA0B,UAACpM,KAAD,EAAmB;cAC3C,IAAIlE,IAAI,CAACuQ,MAAL,OAAkB,QAAtB,EAAgC;gBAC9BxS,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;;gBACA+P,sBAAsB;cACvB;;cACD,IAAIhS,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAYoG,uBAAZ;cACD;;cACDzS,KAAI,CAAC0S,uBAAL;YACD,CATD;YAWAzQ,IAAI,CAACqF,IAAL,CAAU,QAAV,EAAoB;cAClBtH,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,eAAapD,IAAI,CAACe,UAAL,CAAgBC,OAA5C;;cACAjD,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;;cACA+P,sBAAsB;;cACtB,IAAIhS,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAYoG,uBAAZ;cACD;;cACDzS,KAAI,CAAC0S,uBAAL;YACD,CARD;YAUAzQ,IAAI,CAACqF,IAAL,CAAU,YAAV,EAAwB;cACtB,IAAItH,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAYoG,uBAAZ;cACD;;cACDzS,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;;cACA+P,sBAAsB;YACvB,CAND;YAQA/P,IAAI,CAACqF,IAAL,CAAU,QAAV,EAAoB;cAClBtH,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe,eAAapD,IAAI,CAACe,UAAL,CAAgBC,OAA5C;;cACA,IAAIjD,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAYoG,uBAAZ;cACD;;cACDzS,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;;cACA+P,sBAAsB;;cACtBhS,KAAI,CAAC0S,uBAAL;YACD,CARD;YAUAzQ,IAAI,CAACgM,EAAL,CAAQ,gBAAR,EAA0B;cACxB,IAAIhM,IAAI,CAACuQ,MAAL,OAAkBpS,eAAKsB,KAAL,CAAWiR,OAAjC,EAA0C;gBACxC;cACD;;cACD,IAAI3S,KAAI,CAACqM,MAAT,EAAiB;gBACfrM,KAAI,CAACqM,MAAL,CAAYoG,uBAAZ;cACD;;cACDzS,KAAI,CAACwR,WAAL,CAAiBvP,IAAjB;cACA;;;;;;cAIAjC,KAAI,CAAC0S,uBAAL;YACD,CAbD;YAeA;YAAA;YAAA,EAAOzQ,IAAP;;;;EACD,CA7Ha;EA+Hd;;;;;EAGQf,2CAAR;IACE,IAAI,CAAC,KAAKkG,MAAL,CAAYlC,MAAjB,EAAyB;MACvB,KAAKqC,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgDoG,IAAhD;IACD;EACF,CAJO;EAqLR;;;;;;EAIQvG,+BAAR,UAAoBe,IAApB,EAA8B;IAC5B,IAAI,KAAKsE,WAAL,KAAqBtE,IAAzB,EAA+B;MAC7B,KAAKsE,WAAL,GAAmB,IAAnB;IACD;;IAED,KAAK,IAAIqM,CAAC,GAAG,KAAKxL,MAAL,CAAYlC,MAAZ,GAAqB,CAAlC,EAAqC0N,CAAC,IAAI,CAA1C,EAA6CA,CAAC,EAA9C,EAAkD;MAChD,IAAI3Q,IAAI,KAAK,KAAKmF,MAAL,CAAYwL,CAAZ,CAAb,EAA6B;QAC3B,KAAKxL,MAAL,CAAYsF,MAAZ,CAAmBkG,CAAnB,EAAsB,CAAtB;MACD;IACF;EACF,CAVO;EAYR;;;;;EAGc1R,iCAAd,UAA4B2R,QAA5B,EAA6C;;;;;;YAC5B;YAAA;YAAA,EAAM,KAAKnP,uBAAX;;;YAATiK,MAAM,GAAG1M,SAAT;;YAEN,IAAI,CAAC0M,MAAL,EAAa;cAAE;cAAA;cAAA;YAAS;;YAExBA,MAAM,CAACpI,QAAP,CAAgB;cAAEuN,KAAK,EAAED;YAAT,CAAhB;;YACA,IAAIA,QAAJ,EAAc;cACZ,KAAKE,uBAAL;YACD,CAFD,MAEO;cACL,KAAK9M,sBAAL;YACD;;;;;;;;EACF,CAXa;EAad;;;;;;EAIS/E,6BAAR,UAAkB8G,KAAlB,EAAqC;IACpC,IAAIA,KAAK,KAAK,KAAKA,KAAnB,EAA0B;MACxB;IACD;;IAED,KAAK8F,MAAL,GAAc9F,KAAd;IACA,KAAKrD,IAAL,CAAU,KAAKqO,kBAAL,CAAwBhL,KAAxB,CAAV;EACD,CAPQ;EAST;;;;;EAGQ9G,qCAAR;IAAA;;IACE,IAAI,KAAKmL,MAAT,EAAiB;MACf,KAAKtH,IAAL,CAAUM,IAAV,CAAe,4CAAf;;MACA,KAAK8H,mBAAL;IACD;;IAED,KAAKd,MAAL,GAAc,KAAK,KAAKjK,QAAL,CAAc6Q,WAAd,IAA6BC,qBAAlC,EACZ,KAAKC,cADO,EAEZ,KAAKC,kBAFO,EAGZ9T,YAHY,EAIZ;MACE4M,YAAY,EAAEhL,MAAM,CAACgL,YADvB;MAEEmH,aAAa,EAAE,KAAKzL;IAFtB,CAJY,CAAd;;IAUA,KAAKyE,MAAL,CAAY4B,EAAZ,CAAe,cAAf,EAA+B,UAACqF,iBAAD,EAAqC;MAClE,IAAM7G,UAAU,GAAgBzM,KAAI,CAACuG,WAArC;MACA,IAAMgN,SAAS,GAAaD,iBAAiB,CAAC5E,GAAlB,CAAsB,UAAC8E,MAAD,EAAwB;QAAK,aAAM,CAACC,QAAP;MAAe,CAAlE,CAA5B;;MAEAzT,KAAI,CAAC+D,UAAL,CAAgBsB,IAAhB,CAAqB,OAArB,EAA8B,eAA9B,EAA+C;QAC7CqO,sBAAsB,EAAEH;MADqB,CAA/C,EAEG9G,UAFH;;MAIA,IAAIA,UAAJ,EAAgB;QACdA,UAAU,CAAC,eAAD,CAAV,CAA4BkH,sBAA5B;MACD;IACF,CAXD;EAYD,CA5BO;EA8BR;;;;;EAGQzS,mCAAR;IAAA;;IACE,IAAI,KAAK6C,UAAT,EAAqB;MACnB,KAAKgB,IAAL,CAAUM,IAAV,CAAe,yCAAf;;MACA,KAAK6H,iBAAL;IACD;;IAED,IAAM0G,gBAAgB,GAAG;MACvBC,cAAc,EAAE,KAAKC,qBADE;MAEvBC,GAAG,EAAE,KAAKhP,IAFa;MAGvBiP,QAAQ,EAAE;QACRC,QAAQ,EAAE,KAAK7R,QAAL,CAAc8R,OADhB;QAERC,WAAW,EAAE,KAAK/R,QAAL,CAAcgS;MAFnB;IAHa,CAAzB;;IASA,IAAI,KAAKhS,QAAL,CAAciS,OAAlB,EAA2B;MACzBT,gBAAgB,CAACU,IAAjB,GAAwB,KAAKlS,QAAL,CAAciS,OAAtC;IACD;;IAED,KAAKtQ,UAAL,GAAkB,KAAK,KAAK3B,QAAL,CAAcjD,SAAd,IAA2BA,SAAhC,EAA2CO,sBAA3C,EAAmE,KAAKG,KAAxE,EAA+E+T,gBAA/E,CAAlB;;IAEA,IAAI,KAAKxR,QAAL,CAAcmS,aAAd,KAAgC,KAApC,EAA2C;MACzC,KAAKxQ,UAAL,CAAgByQ,OAAhB;IACD,CAFD,MAEO;MACL,KAAKzQ,UAAL,CAAgBkK,EAAhB,CAAmB,OAAnB,EAA4B,UAAC9H,KAAD,EAAa;QACvCnG,KAAI,CAAC+E,IAAL,CAAUC,IAAV,CAAe,6BAAf,EAA8CmB,KAA9C;MACD,CAFD;IAGD;;IAED,OAAO,KAAKpC,UAAZ;EACD,CA9BO;EAgCR;;;;;;EAIQ7C,gCAAR;IAAA;;IACE,IAAI,KAAKqC,OAAT,EAAkB;MAChB,KAAKwB,IAAL,CAAUM,IAAV,CAAe,sCAAf;;MACA,KAAK4H,cAAL;IACD;;IAED,KAAKlI,IAAL,CAAUM,IAAV,CAAe,gBAAf;;IACA,KAAK9B,OAAL,GAAe,KAAK,KAAKnB,QAAL,CAAchD,OAAd,IAAyBA,OAA9B,EACb,KAAKS,KADQ,EAEb,KAAKwO,YAFQ,EAGb;MACEoG,YAAY,EAAE,KAAKrS,QAAL,CAAcqS,YAD9B;MAEEC,sBAAsB,EAAE,KAAKtS,QAAL,CAAcvB;IAFxC,CAHa,CAAf;;IASA,KAAK0C,OAAL,CAAagP,WAAb,CAAyB,OAAzB,EAAkC,KAAK/B,iBAAvC;;IACA,KAAKjN,OAAL,CAAagP,WAAb,CAAyB,WAAzB,EAAsC,KAAK9B,qBAA3C;;IACA,KAAKlN,OAAL,CAAagP,WAAb,CAAyB,OAAzB,EAAkC,KAAK7B,iBAAvC;;IACA,KAAKnN,OAAL,CAAagP,WAAb,CAAyB,QAAzB,EAAmC,KAAK5B,kBAAxC;;IACA,KAAKpN,OAAL,CAAagP,WAAb,CAAyB,SAAzB,EAAoC,KAAK3B,mBAAzC;;IACA,KAAKrN,OAAL,CAAagP,WAAb,CAAyB,OAAzB,EAAkC,KAAK1B,iBAAvC;;IAEA,OAAO,KAAKnN,uBAAL,GAA+B,IAAIiF,OAAJ,CAAsB,mBAAO;MACjE,YAAI,CAACpF,OAAL,CAAa+D,IAAb,CAAkB,WAAlB,EAA+B;QAC7BQ,OAAO,CAAC9H,KAAI,CAACuD,OAAN,CAAP;MACD,CAFD;IAEE,CAHkC,CAAtC;EAKD,CA5BO;EA8BR;;;;;;;EAKQrC,qCAAR,UAA0Be,IAA1B,EAAsC0F,IAAtC,EAAoD;IAApD;;IACE,IAAIgN,OAAJ;IACA,OAAOhM,OAAO,CAACiM,IAAR,CAAa,CAClBjN,IAAI,EADc,EAElB,IAAIgB,OAAJ,CAAY,UAACb,OAAD,EAAUc,MAAV,EAAgB;MAC1B+L,OAAO,GAAGjQ,UAAU,CAAC;QACnB,IAAMmQ,GAAG,GAAG,qFAAZ;QACAjM,MAAM,CAAC,IAAIvC,KAAJ,CAAUwO,GAAV,CAAD,CAAN;MACD,CAHmB,EAGjBpV,qBAHiB,CAApB;IAID,CALD,CAFkB,CAAb,EAQJqV,KARI,CAQE,kBAAM;MACb9U,KAAI,CAAC+E,IAAL,CAAUM,IAAV,CAAe0P,MAAM,CAAC1L,OAAtB;IACD,CAVM,EAUJF,IAVI,CAUC;MACNvE,YAAY,CAAC+P,OAAD,CAAZ;;MACA3U,KAAI,CAAC2E,IAAL,CAAUzD,MAAM,CAACY,SAAP,CAAiBT,QAA3B,EAAqCY,IAArC;IACD,CAbM,CAAP;EAcD,CAhBO;EAkBR;;;;;EAGQf,2CAAR;IAAA;;IACE,KAAK+E,sBAAL;;IACA,KAAK+O,SAAL,GAAiBtQ,UAAU,CAAC;MAC1B1E,KAAI,CAAC6N,aAAL,CAAmB,IAAnB;IACD,CAF0B,EAExBrO,qBAFwB,CAA3B;EAGD,CALO;EAOR;;;;;EAGQ0B,0CAAR;IACE,IAAI,KAAK8T,SAAT,EAAoB;MAClBpQ,YAAY,CAAC,KAAKoQ,SAAN,CAAZ;IACD;EACF,CAJO;EAMR;;;;;EAGQ9T,qCAAR;IACE,IAAI,KAAK8G,KAAL,KAAe9G,MAAM,CAACQ,KAAP,CAAaG,SAAhC,EAA2C;MACzC,MAAM,IAAIiE,0BAAJ,CAAsB,4BAAtB,CAAN;IACD;EACF,CAJO;EAwBR;;;;;;EAIQ5E,0CAAR,UAA+B6H,OAA/B,EAAgD;IAC9C,OAAOJ,OAAO,CAACb,OAAR,CAAgB,KAAKP,WAAL,CAAiBC,GAAjB,CAAqBtG,MAAM,CAACC,SAAP,CAAiBE,QAAtC,EAAgD4T,UAAhD,CAA2DlM,OAA3D,CAAhB,CAAP;EACD,CAFO;EA4BR;;;;;;;EAKQ7H,yCAAR,UAA8B6H,OAA9B,EAA+C;IAC7CwF,KAAK,CAAC2G,IAAN,CAAW,KAAK3N,WAAL,CAAiB4N,OAAjB,EAAX,EACGC,MADH,CACU,iBAAK;MAAI,YAAK,CAAC,CAAD,CAAL,KAAalU,MAAM,CAACC,SAAP,CAAiBE,QAA9B;IAAsC,CADzD,EAEGsL,OAFH,CAEW,iBAAK;MAAI,YAAK,CAAC,CAAD,CAAL,CAASsI,UAAT,CAAoBlM,OAApB;IAA4B,CAFhD;IAIA,KAAK8I,YAAL,GAAoB9I,OAApB;IACA,IAAM9G,IAAI,GAAG,KAAKsE,WAAlB;IACA,OAAOtE,IAAI,GACPA,IAAI,CAACoT,WAAL,CAAiBtM,OAAjB,CADO,GAEPJ,OAAO,CAACb,OAAR,EAFJ;EAGD,CAVO;;EA3uCO5G,wBAAmD;IAChEuM,UAAU,EAAE;MAAEiC,QAAQ,EAAE,YAAZ;MAA0BI,WAAW,EAAE;IAAvC,CADoD;IAEhEwF,KAAK,EAAE;MAAE5F,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAFyD;IAGhEyF,KAAK,EAAE;MAAE7F,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAHyD;IAIhE0F,KAAK,EAAE;MAAE9F,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAJyD;IAKhE2F,KAAK,EAAE;MAAE/F,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CALyD;IAMhE4F,KAAK,EAAE;MAAEhG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CANyD;IAOhE6F,KAAK,EAAE;MAAEjG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAPyD;IAQhE8F,KAAK,EAAE;MAAElG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CARyD;IAShE+F,KAAK,EAAE;MAAEnG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CATyD;IAUhEgG,KAAK,EAAE;MAAEpG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAVyD;IAWhEiG,KAAK,EAAE;MAAErG,QAAQ,EAAE,QAAZ;MAAsBI,WAAW,EAAE;IAAnC,CAXyD;IAYhEkG,KAAK,EAAE;MAAEtG,QAAQ,EAAE,WAAZ;MAAyBI,WAAW,EAAE;IAAtC,CAZyD;IAahEmG,KAAK,EAAE;MAAEvG,QAAQ,EAAE,WAAZ;MAAyBI,WAAW,EAAE;IAAtC,CAbyD;IAchEjI,QAAQ,EAAE;MAAE6H,QAAQ,EAAE,UAAZ;MAAwBK,UAAU,EAAE;IAApC,CAdsD;IAehEsC,QAAQ,EAAE;MAAE3C,QAAQ,EAAE,UAAZ;MAAwBI,WAAW,EAAE;IAArC;EAfsD,CAAnD;EAsvCjB;AAAC,CA9zCD,CAAqBzC,qBAArB;;AAg0CA,WAAUnM,MAAV,EAAgB;EAoDd;;;EAGA,IAAYY,SAAZ;;EAAA,WAAYA,SAAZ,EAAqB;IACnBA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;EACD,CARD,EAAYA,SAAS,GAATZ,wCAAS,EAAT,CAAZ;EAUA;;;;;EAGA,IAAYQ,KAAZ;;EAAA,WAAYA,KAAZ,EAAiB;IACfA;IACAA;IACAA;IACAA;EACD,CALD,EAAYA,KAAK,GAALR,gCAAK,EAAL,CAAZ;EAOA;;;;;EAGA,IAAYC,SAAZ;;EAAA,WAAYA,SAAZ,EAAqB;IACnBA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;IACAA;EACD,CAhBD,EAAYA,SAAS,GAATD,wCAAS,EAAT,CAAZ;AAyID,CAvND,EAAUA,MAAM,KAANA,MAAM,MAAhB;;AAyNAgV,kBAAehV,MAAf","names":["C","require","Publisher","PStream","rtc","getUserMedia","Sound","REGISTRATION_INTERVAL","RINGTONE_PLAY_TIMEOUT","PUBLISHER_PRODUCT_NAME","INVALID_TOKEN_MESSAGE","__extends","token","options","_super","_this","allowIncomingWhileBusy","closeProtection","codecPreferences","call_1","Codec","PCMU","Opus","dscp","forceAggressiveIceNomination","logLevel","loglevel_1","ERROR","maxCallSignalingTimeoutMs","preflight","sounds","tokenRefreshMs","_a","Device","SoundName","Disconnect","Incoming","Outgoing","log_1","getInstance","Map","State","Unregistered","_b","Destroyed","EventName","Registering","Registered","call","payload","aggressive_nomination","_options","browser_extension","_isBrowserExtension","ice_restart_enabled","platform","getMediaEngine","sdk_version","RELEASE_VERSION","setIfDefined","propertyName","value","callSid","parameters","CallSid","test","undefined","outboundConnectionId","codec","direction","_stream","gateway","region","_streamConnectedPromise","regions_1","_edge","edge","_region","_publisher","setHost","home","_identity","identity","ttl","ttlMs","timeoutMs","Math","max","_tokenWillExpireTimeout","setTimeout","emit","clearTimeout","_home","preferredURIs","_log","warn","bind","length","_preferredURI","preferredURI","info","_shouldReRegister","register","callsid","originalError","_findCall","customMessage","code","twilioError","errors_1","AuthenticationFailed","AccessTokenInvalid","_stopRegistrationTimer","AccessTokenExpired","error","UnknownError","Error","wasBusy","_activeCall","sdp","BadRequest","callParameters","customParameters","Object","assign","util_1","Params","_makeCall","offerSdp","reconnectToken","reconnect","_calls","push","once","_soundcache","get","stop","_publishNetworkChange","play","_enabledSounds","incoming","resolve","_showIncomingCall","state","_setState","_networkInformation","connection_type","type","downlink","downlinkMax","effective_type","effectiveType","rtt","inputStream","Promise","reject","_callInputStream","_setInputTracksFromStream","sinkIds","promise","_updateRingtoneSinkIds","_updateSpeakerSinkIds","then","audio_device_ids","message","updateToken","isSupported","ignoreBrowserSupport","window","location","protocol","root","browser","msBrowser","chrome","runtime","id","safari","extension","navigator","n","connection","mozConnection","webkitConnection","addEventListener","_getOrCreateAudioContext","_audioContext","_dialtonePlayer","dialtonePlayer_1","_isUnifiedPlanDefault","RTCPeerConnection","RTCRtpTransceiver","_boundDestroy","destroy","_boundConfirmClose","_confirmClose","updateOptions","a","document","createElement","canPlayType","canPlayMp3","replace","e","canPlayVorbis","enabled","PACKAGE_NAME","preflight_1","__assign","audioContext","AudioContext","webkitAudioContext","_audio","_throwIfDestroyed","params","rtcConfiguration","activeCall","splice","forEach","ignore","accept","rtcConstraints","disconnectAll","_unbind","_destroyStream","_destroyPublisher","_destroyAudioHelper","removeEventListener","events_1","prototype","removeAllListeners","calls","disconnect","_setupStream","stream","streamReadyPromise","_sendPresence","_state","_token","streamOfflinePromise","on","_defaultOptions","originalChunderURIs","Set","_chunderURIs","chunderw","Array","isArray","newChunderURIs","map","hasChunderURIsChanged","size","_i","uri","has","isBusy","setDefaultLevel","optional","googDscp","keys","_defaultSounds","name_1","soundDef","defaultUrl","SOUNDS_BASE_URL","filename","soundUrl","sound","disableAudioContextSounds","maxDuration","shouldLoop","set","_setupAudioHelper","_setupPublisher","setToken","event","confirmationMsg","returnValue","removeListener","_onSignalingClose","_onSignalingConnected","_onSignalingError","_onSignalingInvite","_onSignalingOffline","_onSignalingReady","find","twimlParams","audioHelper","isUnifiedPlanDefault","onIgnore","config","MediaStream","PeerConnection","beforeAccept","currentCall","_removeCall","dialtonePlayer","getInputStream","fileInputStream","getSinkIds","_callSinkIds","maxAverageBitrate","shouldPlayDisconnect","maybeUnsetPreferredUri","updatePreferredURI","Call","_maybeStartPollingVolume","CallDirection","outgoing","data","addListener","status","_maybeStopPollingVolume","_maybeStopIncomingSound","Pending","i","presence","audio","_startRegistrationTimer","_stateEventMapping","AudioHelper","audiohelper_1","_updateSinkIds","_updateInputStream","enabledSounds","lostActiveDevices","deviceIds","device","deviceId","lost_active_device_ids","_onInputDevicesChanged","publisherOptions","defaultPayload","_createDefaultPayload","log","metadata","app_name","appName","app_version","appVersion","eventgw","host","publishEvents","disable","backoffMaxMs","maxPreferredDurationMs","timeout","race","msg","catch","reason","_regTimer","setSinkIds","from","entries","filter","_setSinkIds","dtmf0","dtmf1","dtmf2","dtmf3","dtmf4","dtmf5","dtmf6","dtmf7","dtmf8","dtmf9","dtmfh","dtmfs","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/device.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n * @preferred\n * @publicapi\n */\nimport { EventEmitter } from 'events';\nimport { levels as LogLevels, LogLevelDesc } from 'loglevel';\nimport AudioHelper from './audiohelper';\nimport Call from './call';\nimport DialtonePlayer from './dialtonePlayer';\nimport {\n  AuthorizationErrors,\n  ClientErrors,\n  GeneralErrors,\n  getErrorByCode,\n  hasErrorByCode,\n  InvalidArgumentError,\n  InvalidStateError,\n  NotSupportedError,\n  TwilioError,\n} from './errors';\nimport Log from './log';\nimport { PreflightTest } from './preflight/preflight';\nimport {\n  createEventGatewayURI,\n  createSignalingEndpointURL,\n  Edge,\n  getChunderURIs,\n  getRegionShortcode,\n  Region,\n  regionToEdge,\n} from './regions';\nimport {\n  isLegacyEdge,\n  isUnifiedPlanDefault,\n  queryToJson,\n} from './util';\n\nconst C = require('./constants');\nconst Publisher = require('./eventpublisher');\nconst PStream = require('./pstream');\nconst rtc = require('./rtc');\nconst getUserMedia = require('./rtc/getusermedia');\nconst Sound = require('./sound');\n\n// Placeholders until we convert the respective files to TypeScript.\n/**\n * @private\n */\nexport type IPStream = any;\n/**\n * @private\n */\nexport type IPublisher = any;\n/**\n * @private\n */\nexport type ISound = any;\n\nconst REGISTRATION_INTERVAL = 30000;\nconst RINGTONE_PLAY_TIMEOUT = 2000;\nconst PUBLISHER_PRODUCT_NAME = 'twilio-js-sdk';\nconst INVALID_TOKEN_MESSAGE = 'Parameter \"token\" must be of type \"string\".';\n\ndeclare const RTCRtpTransceiver: any;\ndeclare const webkitAudioContext: typeof AudioContext;\n\n/**\n * Options that may be passed to the {@link Device} constructor for internal testing.\n * @private\n */\nexport interface IExtendedDeviceOptions extends Device.Options {\n  /**\n   * Custom {@link AudioHelper} constructor\n   */\n  AudioHelper?: typeof AudioHelper;\n\n  /**\n   * The max amount of time in milliseconds to allow stream (re)-connect\n   * backoffs.\n   */\n  backoffMaxMs?: number;\n\n  /**\n   * Custom {@link Call} constructor\n   */\n  Call?: typeof Call;\n\n  /**\n   * Hostname of the signaling gateway to connect to.\n   */\n  chunderw?: string | string[];\n\n  /**\n   * Hostname of the event gateway to connect to.\n   */\n  eventgw?: string;\n\n  /**\n   * File input stream to use instead of reading from mic\n   */\n  fileInputStream?: MediaStream;\n\n  /**\n   * Ignore browser support, disabling the exception that is thrown when neither WebRTC nor\n   * ORTC are supported.\n   */\n  ignoreBrowserSupport?: boolean;\n\n  /**\n   * MediaStream constructor.\n   */\n  MediaStream?: typeof MediaStream;\n\n  /**\n   * Whether this is a preflight call or not\n   */\n  preflight?: boolean;\n\n  /**\n   * Custom PStream constructor\n   */\n  PStream?: IPStream;\n\n  /**\n   * Custom Publisher constructor\n   */\n  Publisher?: IPublisher;\n\n  /**\n   * Whether or not to publish events to insights using {@link Device._publisher}.\n   */\n  publishEvents?: boolean;\n\n  /**\n   * MediaStreamConstraints to pass to getUserMedia when making or accepting a Call.\n   */\n  rtcConstraints?: Call.AcceptOptions['rtcConstraints'];\n\n  /**\n   * Custom Sound constructor\n   */\n  Sound?: ISound;\n}\n\n/**\n * A sound definition used to initialize a Sound file.\n * @private\n */\nexport interface ISoundDefinition {\n  /**\n   * Name of the sound file.\n   */\n  filename: string;\n\n  /**\n   * The amount of time this sound file should play before being stopped automatically.\n   */\n  maxDuration?: number;\n\n  /**\n   * Whether or not this sound should loop after playthrough finishes.\n   */\n  shouldLoop?: boolean;\n}\n\n/**\n * Twilio Device. Allows registration for incoming calls, and placing outgoing calls.\n * @publicapi\n */\nclass Device extends EventEmitter {\n  /**\n   * The AudioContext to be used by {@link Device} instances.\n   * @private\n   */\n  static get audioContext(): AudioContext | undefined {\n    return Device._audioContext;\n  }\n\n  /**\n   * Which sound file extension is supported.\n   * @private\n   */\n  static get extension(): 'mp3' | 'ogg' {\n    // NOTE(mroberts): Node workaround.\n    const a: any = typeof document !== 'undefined'\n      ? document.createElement('audio') : { canPlayType: false };\n\n    let canPlayMp3;\n    try {\n      canPlayMp3 = a.canPlayType && !!a.canPlayType('audio/mpeg').replace(/no/, '');\n    } catch (e) {\n      canPlayMp3 = false;\n    }\n\n    let canPlayVorbis;\n    try {\n      canPlayVorbis = a.canPlayType && !!a.canPlayType('audio/ogg;codecs=\\'vorbis\\'').replace(/no/, '');\n    } catch (e) {\n      canPlayVorbis = false;\n    }\n\n    return (canPlayVorbis && !canPlayMp3) ? 'ogg' : 'mp3';\n  }\n\n  /**\n   * Whether or not this SDK is supported by the current browser.\n   */\n  static get isSupported(): boolean { return rtc.enabled(); }\n\n  /**\n   * Package name of the SDK.\n   */\n  static get packageName(): string { return C.PACKAGE_NAME; }\n\n  /**\n   * Run some tests to identify issues, if any, prohibiting successful calling.\n   * @param token - A Twilio JWT token string\n   * @param options\n   */\n  static runPreflight(token: string, options?: PreflightTest.Options): PreflightTest {\n    return new PreflightTest(token, { audioContext: Device._getOrCreateAudioContext(), ...options });\n  }\n\n  /**\n   * String representation of {@link Device} class.\n   * @private\n   */\n  static toString(): string {\n    return '[Twilio.Device class]';\n  }\n\n  /**\n   * Current SDK version.\n   */\n  static get version(): string { return C.RELEASE_VERSION; }\n\n  /**\n   * An AudioContext to share between {@link Device}s.\n   */\n  private static _audioContext?: AudioContext;\n\n  private static _defaultSounds: Record<string, ISoundDefinition> = {\n    disconnect: { filename: 'disconnect', maxDuration: 3000 },\n    dtmf0: { filename: 'dtmf-0', maxDuration: 1000 },\n    dtmf1: { filename: 'dtmf-1', maxDuration: 1000 },\n    dtmf2: { filename: 'dtmf-2', maxDuration: 1000 },\n    dtmf3: { filename: 'dtmf-3', maxDuration: 1000 },\n    dtmf4: { filename: 'dtmf-4', maxDuration: 1000 },\n    dtmf5: { filename: 'dtmf-5', maxDuration: 1000 },\n    dtmf6: { filename: 'dtmf-6', maxDuration: 1000 },\n    dtmf7: { filename: 'dtmf-7', maxDuration: 1000 },\n    dtmf8: { filename: 'dtmf-8', maxDuration: 1000 },\n    dtmf9: { filename: 'dtmf-9', maxDuration: 1000 },\n    dtmfh: { filename: 'dtmf-hash', maxDuration: 1000 },\n    dtmfs: { filename: 'dtmf-star', maxDuration: 1000 },\n    incoming: { filename: 'incoming', shouldLoop: true },\n    outgoing: { filename: 'outgoing', maxDuration: 3000 },\n  };\n\n  /**\n   * A DialtonePlayer to play mock DTMF sounds through.\n   */\n  private static _dialtonePlayer?: DialtonePlayer;\n\n  /**\n   * Whether or not the browser uses unified-plan SDP by default.\n   */\n  private static _isUnifiedPlanDefault: boolean | undefined;\n\n  /**\n   * Initializes the AudioContext instance shared across the Voice SDK,\n   * or returns the existing instance if one has already been initialized.\n   */\n  private static _getOrCreateAudioContext(): AudioContext | undefined {\n    if (!Device._audioContext) {\n      if (typeof AudioContext !== 'undefined') {\n        Device._audioContext = new AudioContext();\n      } else if (typeof webkitAudioContext !== 'undefined') {\n        Device._audioContext = new webkitAudioContext();\n      }\n    }\n    return Device._audioContext;\n  }\n\n  /**\n   * The currently active {@link Call}, if there is one.\n   */\n  private _activeCall: Call | null = null;\n\n  /**\n   * The AudioHelper instance associated with this {@link Device}.\n   */\n  private _audio: AudioHelper | null = null;\n\n  /**\n   * {@link Device._confirmClose} bound to the specific {@link Device} instance.\n   */\n  private _boundConfirmClose: typeof Device.prototype._confirmClose;\n\n  /**\n   * {@link Device.destroy} bound to the specific {@link Device} instance.\n   */\n  private _boundDestroy: typeof Device.prototype.destroy;\n\n  /**\n   * An audio input MediaStream to pass to new {@link Call} instances.\n   */\n  private _callInputStream: MediaStream | null = null;\n\n  /**\n   * An array of {@link Call}s. Though only one can be active, multiple may exist when there\n   * are multiple incoming, unanswered {@link Call}s.\n   */\n  private _calls: Call[] = [];\n\n  /**\n   * An array of {@link Device} IDs to be used to play sounds through, to be passed to\n   * new {@link Call} instances.\n   */\n  private _callSinkIds: string[] = ['default'];\n\n  /**\n   * The list of chunder URIs that will be passed to PStream\n   */\n  private _chunderURIs: string[] = [];\n\n  /**\n   * Default options used by {@link Device}.\n   */\n  private readonly _defaultOptions: IExtendedDeviceOptions = {\n    allowIncomingWhileBusy: false,\n    closeProtection: false,\n    codecPreferences: [Call.Codec.PCMU, Call.Codec.Opus],\n    dscp: true,\n    forceAggressiveIceNomination: false,\n    logLevel: LogLevels.ERROR,\n    maxCallSignalingTimeoutMs: 0,\n    preflight: false,\n    sounds: { },\n    tokenRefreshMs: 10000,\n  };\n\n  /**\n   * The name of the edge the {@link Device} is connected to.\n   */\n  private _edge: string | null = null;\n\n  /**\n   * Whether each sound is enabled.\n   */\n  private _enabledSounds: Record<Device.ToggleableSound, boolean> = {\n    [Device.SoundName.Disconnect]: true,\n    [Device.SoundName.Incoming]: true,\n    [Device.SoundName.Outgoing]: true,\n  };\n\n  /**\n   * The name of the home region the {@link Device} is connected to.\n   */\n  private _home: string | null = null;\n\n  /**\n   * The identity associated with this Device.\n   */\n  private _identity: string | null = null;\n\n  /**\n   * Whether SDK is run as a browser extension\n   */\n  private _isBrowserExtension: boolean;\n\n  /**\n   * An instance of Logger to use.\n   */\n  private _log: Log = Log.getInstance();\n\n  /**\n   * Network related information\n   * See https://developer.mozilla.org/en-US/docs/Web/API/Network_Information_API\n   */\n  private _networkInformation: any;\n\n  /**\n   * The options passed to {@link Device} constructor or {@link Device.updateOptions}.\n   */\n  private _options: IExtendedDeviceOptions = { };\n\n  /**\n   * The preferred URI to (re)-connect signaling to.\n   */\n  private _preferredURI: string | null = null;\n\n  /**\n   * An Insights Event Publisher.\n   */\n  private _publisher: IPublisher | null = null;\n\n  /**\n   * The region the {@link Device} is connected to.\n   */\n  private _region: string | null = null;\n\n  /**\n   * A timeout ID for a setTimeout schedule to re-register the {@link Device}.\n   */\n  private _regTimer: NodeJS.Timer | null = null;\n\n  /**\n   * Boolean representing whether or not the {@link Device} was registered when\n   * receiving a signaling `offline`. Determines if the {@link Device} attempts\n   * a `re-register` once signaling is re-established when receiving a\n   * `connected` event from the stream.\n   */\n  private _shouldReRegister: boolean = false;\n\n  /**\n   * A Map of Sounds to play.\n   */\n  private _soundcache: Map<Device.SoundName, ISound> = new Map();\n\n  /**\n   * The current status of the {@link Device}.\n   */\n  private _state: Device.State = Device.State.Unregistered;\n\n  /**\n   * A map from {@link Device.State} to {@link Device.EventName}.\n   */\n  private readonly _stateEventMapping: Record<Device.State, Device.EventName> = {\n    [Device.State.Destroyed]: Device.EventName.Destroyed,\n    [Device.State.Unregistered]: Device.EventName.Unregistered,\n    [Device.State.Registering]: Device.EventName.Registering,\n    [Device.State.Registered]: Device.EventName.Registered,\n  };\n\n  /**\n   * The Signaling stream.\n   */\n  private _stream: IPStream | null = null;\n\n  /**\n   * A promise that will resolve when the Signaling stream is ready.\n   */\n  private _streamConnectedPromise: Promise<IPStream> | null = null;\n\n  /**\n   * The JWT string currently being used to authenticate this {@link Device}.\n   */\n  private _token: string;\n\n  /**\n   * A timeout to track when the current AccessToken will expire.\n   */\n  private _tokenWillExpireTimeout: NodeJS.Timer | null = null;\n\n  /**\n   * Construct a {@link Device} instance. The {@link Device} can be registered\n   * to make and listen for calls using {@link Device.register}.\n   * @constructor\n   * @param options\n   */\n  constructor(token: string, options: Device.Options = { }) {\n    super();\n\n    this.updateToken(token);\n\n    if (isLegacyEdge()) {\n      throw new NotSupportedError(\n        'Microsoft Edge Legacy (https://support.microsoft.com/en-us/help/4533505/what-is-microsoft-edge-legacy) ' +\n        'is deprecated and will not be able to connect to Twilio to make or receive calls after September 1st, 2020. ' +\n        'Please see this documentation for a list of supported browsers ' +\n        'https://www.twilio.com/docs/voice/client/javascript#supported-browsers',\n      );\n    }\n\n    if (!Device.isSupported && (options as IExtendedDeviceOptions).ignoreBrowserSupport) {\n      if (window && window.location && window.location.protocol === 'http:') {\n        throw new NotSupportedError(`twilio.js wasn't able to find WebRTC browser support. \\\n          This is most likely because this page is served over http rather than https, \\\n          which does not support WebRTC in many browsers. Please load this page over https and \\\n          try again.`);\n      }\n\n      throw new NotSupportedError(`twilio.js 1.3+ SDKs require WebRTC browser support. \\\n        For more information, see <https://www.twilio.com/docs/api/client/twilio-js>. \\\n        If you have any questions about this announcement, please contact \\\n        Twilio Support at <help@twilio.com>.`);\n    }\n\n    if (window) {\n      const root: any = window as any;\n      const browser: any = root.msBrowser || root.browser || root.chrome;\n\n      this._isBrowserExtension = (!!browser && !!browser.runtime && !!browser.runtime.id)\n        || (!!root.safari && !!root.safari.extension);\n    }\n\n    if (this._isBrowserExtension) {\n      this._log.info('Running as browser extension.');\n    }\n\n    if (navigator) {\n      const n = navigator as any;\n      this._networkInformation = n.connection\n        || n.mozConnection\n        || n.webkitConnection;\n    }\n\n    if (this._networkInformation && typeof this._networkInformation.addEventListener === 'function') {\n      this._networkInformation.addEventListener('change', this._publishNetworkChange);\n    }\n\n    Device._getOrCreateAudioContext();\n\n    if (Device._audioContext) {\n      if (!Device._dialtonePlayer) {\n        Device._dialtonePlayer = new DialtonePlayer(Device._audioContext);\n      }\n    }\n\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      Device._isUnifiedPlanDefault = typeof window !== 'undefined'\n        && typeof RTCPeerConnection !== 'undefined'\n        && typeof RTCRtpTransceiver !== 'undefined'\n      ? isUnifiedPlanDefault(window, window.navigator, RTCPeerConnection, RTCRtpTransceiver)\n      : false;\n    }\n\n    this._boundDestroy = this.destroy.bind(this);\n    this._boundConfirmClose = this._confirmClose.bind(this);\n\n    if (typeof window !== 'undefined' && window.addEventListener) {\n      window.addEventListener('unload', this._boundDestroy);\n      window.addEventListener('pagehide', this._boundDestroy);\n    }\n\n    this.updateOptions(options);\n  }\n\n  /**\n   * Return the {@link AudioHelper} used by this {@link Device}.\n   */\n  get audio(): AudioHelper | null {\n    return this._audio;\n  }\n\n  /**\n   * Make an outgoing Call.\n   * @param options\n   */\n  async connect(options: Device.ConnectOptions = { }): Promise<Call> {\n    this._throwIfDestroyed();\n\n    if (this._activeCall) {\n      throw new InvalidStateError('A Call is already active');\n    }\n\n    const activeCall = this._activeCall = await this._makeCall(options.params || { }, {\n      rtcConfiguration: options.rtcConfiguration,\n    });\n\n    // Make sure any incoming calls are ignored\n    this._calls.splice(0).forEach(call => call.ignore());\n\n    // Stop the incoming sound if it's playing\n    this._soundcache.get(Device.SoundName.Incoming).stop();\n\n    activeCall.accept({ rtcConstraints: options.rtcConstraints });\n    this._publishNetworkChange();\n    return activeCall;\n  }\n\n  /**\n   * Return the calls that this {@link Device} is maintaining.\n   */\n  get calls(): Call[] {\n    return this._calls;\n  }\n\n  /**\n   * Destroy the {@link Device}, freeing references to be garbage collected.\n   */\n  destroy(): void {\n    this.disconnectAll();\n    this._stopRegistrationTimer();\n\n    if (this._audio) {\n      this._audio._unbind();\n    }\n\n    this._destroyStream();\n    this._destroyPublisher();\n    this._destroyAudioHelper();\n\n    if (this._networkInformation && typeof this._networkInformation.removeEventListener === 'function') {\n      this._networkInformation.removeEventListener('change', this._publishNetworkChange);\n    }\n\n    if (typeof window !== 'undefined' && window.removeEventListener) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.removeEventListener('unload', this._boundDestroy);\n      window.removeEventListener('pagehide', this._boundDestroy);\n    }\n\n    this._setState(Device.State.Destroyed);\n    EventEmitter.prototype.removeAllListeners.call(this);\n  }\n\n  /**\n   * Disconnect all {@link Call}s.\n   */\n  disconnectAll(): void {\n    const calls = this._calls.splice(0);\n    calls.forEach((call: Call) => call.disconnect());\n\n    if (this._activeCall) {\n      this._activeCall.disconnect();\n    }\n  }\n\n  /**\n   * Returns the {@link Edge} value the {@link Device} is currently connected\n   * to. The value will be `null` when the {@link Device} is offline.\n   */\n  get edge(): string | null {\n    return this._edge;\n  }\n\n  /**\n   * Returns the home value the {@link Device} is currently connected\n   * to. The value will be `null` when the {@link Device} is offline.\n   */\n  get home(): string | null {\n    return this._home;\n  }\n\n  /**\n   * Returns the identity associated with the {@link Device} for incoming calls. Only\n   * populated when registered.\n   */\n  get identity(): string | null {\n    return this._identity;\n  }\n\n  /**\n   * Whether the Device is currently on an active Call.\n   */\n  get isBusy(): boolean {\n    return !!this._activeCall;\n  }\n\n  /**\n   * Register the `Device` to the Twilio backend, allowing it to receive calls.\n   */\n  async register(): Promise<void> {\n    if (this.state !== Device.State.Unregistered) {\n      throw new InvalidStateError(\n        `Attempt to register when device is in state \"${this.state}\". ` +\n        `Must be \"${Device.State.Unregistered}\".`,\n      );\n    }\n\n    this._setState(Device.State.Registering);\n\n    const stream = await (this._streamConnectedPromise || this._setupStream());\n    const streamReadyPromise = new Promise(resolve => {\n      this.once(Device.State.Registered, resolve);\n    });\n    await this._sendPresence(true);\n    await streamReadyPromise;\n  }\n\n  /**\n   * Get the state of this {@link Device} instance\n   */\n  get state(): Device.State {\n    return this._state;\n  }\n\n  /**\n   * Get the token used by this {@link Device}.\n   */\n  get token(): string | null {\n    return this._token;\n  }\n\n  /**\n   * String representation of {@link Device} instance.\n   * @private\n   */\n  toString() {\n    return '[Twilio.Device instance]';\n  }\n\n  /**\n   * Unregister the `Device` to the Twilio backend, disallowing it to receive\n   * calls.\n   */\n  async unregister(): Promise<void> {\n    if (this.state !== Device.State.Registered) {\n      throw new InvalidStateError(\n        `Attempt to unregister when device is in state \"${this.state}\". ` +\n        `Must be \"${Device.State.Registered}\".`,\n      );\n    }\n\n    this._shouldReRegister = false;\n\n    const stream = await this._streamConnectedPromise;\n    const streamOfflinePromise = new Promise(resolve => {\n      stream.on('offline', resolve);\n    });\n    await this._sendPresence(false);\n    await streamOfflinePromise;\n  }\n\n  /**\n   * Set the options used within the {@link Device}.\n   * @param options\n   */\n  updateOptions(options: Device.Options = { }): void {\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError(\n        `Attempt to \"updateOptions\" when device is in state \"${this.state}\".`,\n      );\n    }\n\n    this._options = { ...this._defaultOptions, ...this._options, ...options };\n\n    const originalChunderURIs: Set<string> = new Set(this._chunderURIs);\n\n    const chunderw = typeof this._options.chunderw === 'string'\n      ? [this._options.chunderw]\n      : Array.isArray(this._options.chunderw) && this._options.chunderw;\n\n    const newChunderURIs = this._chunderURIs = (\n      chunderw || getChunderURIs(\n        this._options.edge,\n        undefined,\n        this._log.warn.bind(this._log),\n      )\n    ).map(createSignalingEndpointURL);\n\n    let hasChunderURIsChanged =\n      originalChunderURIs.size !== newChunderURIs.length;\n\n    if (!hasChunderURIsChanged) {\n      for (const uri of newChunderURIs) {\n        if (!originalChunderURIs.has(uri)) {\n          hasChunderURIsChanged = true;\n          break;\n        }\n      }\n    }\n\n    if (this.isBusy && hasChunderURIsChanged) {\n      throw new InvalidStateError('Cannot change Edge while on an active Call');\n    }\n\n    this._log.setDefaultLevel(\n      typeof this._options.logLevel === 'number'\n        ? this._options.logLevel\n        : LogLevels.ERROR,\n    );\n\n    if (this._options.dscp) {\n      if (!this._options.rtcConstraints) {\n        this._options.rtcConstraints = { };\n      }\n      (this._options.rtcConstraints as any).optional = [{ googDscp: true }];\n    }\n\n    for (const name of Object.keys(Device._defaultSounds)) {\n      const soundDef: ISoundDefinition = Device._defaultSounds[name];\n\n      const defaultUrl: string = `${C.SOUNDS_BASE_URL}/${soundDef.filename}.${Device.extension}`\n        + `?cache=${C.RELEASE_VERSION}`;\n\n      const soundUrl: string = this._options.sounds && this._options.sounds[name as Device.SoundName] || defaultUrl;\n      const sound: any = new (this._options.Sound || Sound)(name, soundUrl, {\n        audioContext: this._options.disableAudioContextSounds ? null : Device.audioContext,\n        maxDuration: soundDef.maxDuration,\n        shouldLoop: soundDef.shouldLoop,\n      });\n\n      this._soundcache.set(name as Device.SoundName, sound);\n    }\n\n    this._setupAudioHelper();\n    this._setupPublisher();\n\n    if (hasChunderURIsChanged && this._streamConnectedPromise) {\n      this._setupStream();\n    }\n\n    // Setup close protection and make sure we clean up ongoing calls on unload.\n    if (\n      typeof window !== 'undefined' &&\n      typeof window.addEventListener === 'function' &&\n      this._options.closeProtection\n    ) {\n      window.removeEventListener('beforeunload', this._boundConfirmClose);\n      window.addEventListener('beforeunload', this._boundConfirmClose);\n    }\n  }\n\n  /**\n   * Update the token used by this {@link Device} to connect to Twilio.\n   * @param token\n   */\n  updateToken(token: string) {\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError(\n        `Attempt to \"updateToken\" when device is in state \"${this.state}\".`,\n      );\n    }\n\n    if (typeof token !== 'string') {\n      throw new InvalidArgumentError(INVALID_TOKEN_MESSAGE);\n    }\n\n    this._token = token;\n\n    if (this._stream) {\n      this._stream.setToken(this._token);\n    }\n\n    if (this._publisher) {\n      this._publisher.setToken(this._token);\n    }\n  }\n\n  /**\n   * Called on window's beforeunload event if closeProtection is enabled,\n   * preventing users from accidentally navigating away from an active call.\n   * @param event\n   */\n  private _confirmClose(event: any): string {\n    if (!this._activeCall) { return ''; }\n\n    const closeProtection: boolean | string = this._options.closeProtection || false;\n    const confirmationMsg: string = typeof closeProtection !== 'string'\n      ? 'A call is currently in-progress. Leaving or reloading this page will end the call.'\n      : closeProtection;\n\n    (event || window.event).returnValue = confirmationMsg;\n    return confirmationMsg;\n  }\n\n  /**\n   * Create the default Insights payload\n   * @param call\n   */\n  private _createDefaultPayload = (call?: Call): Record<string, any> => {\n    const payload: Record<string, any> = {\n      aggressive_nomination: this._options.forceAggressiveIceNomination,\n      browser_extension: this._isBrowserExtension,\n      dscp: !!this._options.dscp,\n      ice_restart_enabled: true,\n      platform: rtc.getMediaEngine(),\n      sdk_version: C.RELEASE_VERSION,\n    };\n\n    function setIfDefined(propertyName: string, value: string | undefined | null) {\n      if (value) { payload[propertyName] = value; }\n    }\n\n    if (call) {\n      const callSid = call.parameters.CallSid;\n      setIfDefined('call_sid', /^TJ/.test(callSid) ? undefined : callSid);\n      setIfDefined('temp_call_sid', call.outboundConnectionId);\n      setIfDefined('audio_codec', call.codec);\n      payload.direction = call.direction;\n    }\n\n    setIfDefined('gateway', this._stream && this._stream.gateway);\n    setIfDefined('region', this._stream && this._stream.region);\n\n    return payload;\n  }\n\n  /**\n   * Destroy the AudioHelper.\n   */\n  private _destroyAudioHelper() {\n    if (!this._audio) { return; }\n\n    this._audio.removeAllListeners();\n    this._audio = null;\n  }\n\n  /**\n   * Destroy the publisher.\n   */\n  private _destroyPublisher() {\n    // Attempt to destroy non-existent publisher.\n    if (!this._publisher) { return; }\n\n    this._publisher = null;\n  }\n\n  /**\n   * Destroy the connection to the signaling server.\n   */\n  private _destroyStream() {\n    if (this._stream) {\n      this._stream.removeListener('close', this._onSignalingClose);\n      this._stream.removeListener('connected', this._onSignalingConnected);\n      this._stream.removeListener('error', this._onSignalingError);\n      this._stream.removeListener('invite', this._onSignalingInvite);\n      this._stream.removeListener('offline', this._onSignalingOffline);\n      this._stream.removeListener('ready', this._onSignalingReady);\n\n      this._stream.destroy();\n      this._stream = null;\n    }\n\n    this._onSignalingOffline();\n\n    this._streamConnectedPromise = null;\n  }\n\n  /**\n   * Find a {@link Call} by its CallSid.\n   * @param callSid\n   */\n  private _findCall(callSid: string): Call | null {\n    return this._calls.find(call => call.parameters.CallSid === callSid\n      || call.outboundConnectionId === callSid) || null;\n  }\n\n  /**\n   * Create a new {@link Call}.\n   * @param twimlParams - A flat object containing key:value pairs to be sent to the TwiML app.\n   * @param options - Options to be used to instantiate the {@link Call}.\n   */\n  private async _makeCall(twimlParams: Record<string, string>, options?: Call.Options): Promise<Call> {\n    if (typeof Device._isUnifiedPlanDefault === 'undefined') {\n      throw new InvalidStateError('Device has not been initialized.');\n    }\n\n    const config: Call.Config = {\n      audioHelper: this._audio,\n      getUserMedia,\n      isUnifiedPlanDefault: Device._isUnifiedPlanDefault,\n      onIgnore: (): void => {\n        this._soundcache.get(Device.SoundName.Incoming).stop();\n      },\n      pstream: await (this._streamConnectedPromise || this._setupStream()),\n      publisher: this._publisher,\n      soundcache: this._soundcache,\n    };\n\n    options = Object.assign({\n      MediaStream: this._options.MediaStream || rtc.PeerConnection,\n      beforeAccept: (currentCall: Call) => {\n        if (!this._activeCall || this._activeCall === currentCall) {\n          return;\n        }\n\n        this._activeCall.disconnect();\n        this._removeCall(this._activeCall);\n      },\n      codecPreferences: this._options.codecPreferences,\n      dialtonePlayer: Device._dialtonePlayer,\n      dscp: this._options.dscp,\n      forceAggressiveIceNomination: this._options.forceAggressiveIceNomination,\n      getInputStream: (): MediaStream | null => this._options.fileInputStream || this._callInputStream,\n      getSinkIds: (): string[] => this._callSinkIds,\n      maxAverageBitrate: this._options.maxAverageBitrate,\n      preflight: this._options.preflight,\n      rtcConstraints: this._options.rtcConstraints,\n      shouldPlayDisconnect: () => this._enabledSounds.disconnect,\n      twimlParams,\n    }, options);\n\n    const maybeUnsetPreferredUri = () => {\n      if (this._activeCall === null && this._calls.length === 0) {\n        this._stream.updatePreferredURI(null);\n      }\n    };\n\n    const call = new (this._options.Call || Call)(config, options);\n\n    call.once('accept', () => {\n      this._stream.updatePreferredURI(this._preferredURI);\n      this._removeCall(call);\n      this._activeCall = call;\n      if (this._audio) {\n        this._audio._maybeStartPollingVolume();\n      }\n\n      if (call.direction === Call.CallDirection.Outgoing && this._enabledSounds.outgoing) {\n        this._soundcache.get(Device.SoundName.Outgoing).play();\n      }\n\n      const data: any = { edge: this._edge || this._region };\n      if (this._options.edge) {\n        data['selected_edge'] = Array.isArray(this._options.edge)\n          ? this._options.edge\n          : [this._options.edge];\n      }\n\n      this._publisher.info('settings', 'edge', data, call);\n    });\n\n    call.addListener('error', (error: TwilioError) => {\n      if (call.status() === 'closed') {\n        this._removeCall(call);\n        maybeUnsetPreferredUri();\n      }\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n    });\n\n    call.once('cancel', () => {\n      this._log.info(`Canceled: ${call.parameters.CallSid}`);\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._maybeStopIncomingSound();\n    });\n\n    call.once('disconnect', () => {\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n    });\n\n    call.once('reject', () => {\n      this._log.info(`Rejected: ${call.parameters.CallSid}`);\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      maybeUnsetPreferredUri();\n      this._maybeStopIncomingSound();\n    });\n\n    call.on('transportClose', () => {\n      if (call.status() !== Call.State.Pending) {\n        return;\n      }\n      if (this._audio) {\n        this._audio._maybeStopPollingVolume();\n      }\n      this._removeCall(call);\n      /**\n       * NOTE(mhuynh): We don't want to call `maybeUnsetPreferredUri` because\n       * a `transportClose` will happen during signaling reconnection.\n       */\n      this._maybeStopIncomingSound();\n    });\n\n    return call;\n  }\n\n  /**\n   * Stop the incoming sound if no {@link Call}s remain.\n   */\n  private _maybeStopIncomingSound(): void {\n    if (!this._calls.length) {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n    }\n  }\n\n  /**\n   * Called when a 'close' event is received from the signaling stream.\n   */\n   private _onSignalingClose = () => {\n    this._stream = null;\n    this._streamConnectedPromise = null;\n  }\n\n  /**\n   * Called when a 'connected' event is received from the signaling stream.\n   */\n  private _onSignalingConnected = (payload: Record<string, any>) => {\n    const region = getRegionShortcode(payload.region);\n    this._edge = payload.edge || regionToEdge[region as Region] || payload.region;\n    this._region = region || payload.region;\n    this._publisher?.setHost(createEventGatewayURI(payload.home));\n    if (payload.token) {\n      this._identity = payload.token.identity;\n      if (\n        typeof payload.token.ttl === 'number' &&\n        typeof this._options.tokenRefreshMs === 'number'\n      ) {\n        const ttlMs: number = payload.token.ttl * 1000;\n        const timeoutMs: number = Math.max(0, ttlMs - this._options.tokenRefreshMs);\n        this._tokenWillExpireTimeout = setTimeout(() => {\n          this.emit('tokenWillExpire', this);\n          if (this._tokenWillExpireTimeout) {\n            clearTimeout(this._tokenWillExpireTimeout);\n            this._tokenWillExpireTimeout = null;\n          }\n        }, timeoutMs);\n      }\n    }\n    this._home = payload.home;\n\n    const preferredURIs = getChunderURIs(\n      this._edge as Edge,\n      undefined,\n      this._log.warn.bind(this._log),\n    );\n    if (preferredURIs.length > 0) {\n      const [preferredURI] = preferredURIs;\n      this._preferredURI = createSignalingEndpointURL(preferredURI);\n    } else {\n      this._log.info('Could not parse a preferred URI from the stream#connected event.');\n    }\n\n    // The signaling stream emits a `connected` event after reconnection, if the\n    // device was registered before this, then register again.\n    if (this._shouldReRegister) {\n      this.register();\n    }\n  }\n\n  /**\n   * Called when an 'error' event is received from the signaling stream.\n   */\n  private _onSignalingError = (payload: Record<string, any>) => {\n    if (typeof payload !== 'object') { return; }\n\n    const { error: originalError, callsid } = payload;\n\n    if (typeof originalError !== 'object') { return; }\n\n    const call: Call | undefined =\n      (typeof callsid === 'string' && this._findCall(callsid)) || undefined;\n\n    const { code, message: customMessage } = originalError;\n    let { twilioError } = originalError;\n\n    if (typeof code === 'number') {\n      if (code === 31201) {\n        twilioError = new AuthorizationErrors.AuthenticationFailed(originalError);\n      } else if (code === 31204) {\n        twilioError = new AuthorizationErrors.AccessTokenInvalid(originalError);\n      } else if (code === 31205) {\n        // Stop trying to register presence after token expires\n        this._stopRegistrationTimer();\n        twilioError = new AuthorizationErrors.AccessTokenExpired(originalError);\n      } else if (hasErrorByCode(code)) {\n        twilioError = new (getErrorByCode(code))(originalError);\n      }\n    }\n\n    if (!twilioError) {\n      this._log.error('Unknown signaling error: ', originalError);\n      twilioError = new GeneralErrors.UnknownError(customMessage, originalError);\n    }\n\n    this._log.info('Received error: ', twilioError);\n    this.emit(Device.EventName.Error, twilioError, call);\n  }\n\n  /**\n   * Called when an 'invite' event is received from the signaling stream.\n   */\n  private _onSignalingInvite = async (payload: Record<string, any>) => {\n    const wasBusy = !!this._activeCall;\n    if (wasBusy && !this._options.allowIncomingWhileBusy) {\n      this._log.info('Device busy; ignoring incoming invite');\n      return;\n    }\n\n    if (!payload.callsid || !payload.sdp) {\n      this.emit(Device.EventName.Error, new ClientErrors.BadRequest('Malformed invite from gateway'));\n      return;\n    }\n\n    const callParameters = payload.parameters || { };\n    callParameters.CallSid = callParameters.CallSid || payload.callsid;\n\n    const customParameters = Object.assign({ }, queryToJson(callParameters.Params));\n\n    const call = await this._makeCall(customParameters, {\n      callParameters,\n      offerSdp: payload.sdp,\n      reconnectToken: payload.reconnect,\n    });\n\n    this._calls.push(call);\n\n    call.once('accept', () => {\n      this._soundcache.get(Device.SoundName.Incoming).stop();\n      this._publishNetworkChange();\n    });\n\n    const play = (this._enabledSounds.incoming && !wasBusy)\n      ? () => this._soundcache.get(Device.SoundName.Incoming).play()\n      : () => Promise.resolve();\n\n    this._showIncomingCall(call, play);\n  }\n\n  /**\n   * Called when an 'offline' event is received from the signaling stream.\n   */\n  private _onSignalingOffline = () => {\n    this._log.info('Stream is offline');\n\n    this._edge = null;\n    this._region = null;\n\n    this._shouldReRegister = this.state !== Device.State.Unregistered;\n\n    this._setState(Device.State.Unregistered);\n  }\n\n  /**\n   * Called when a 'ready' event is received from the signaling stream.\n   */\n  private _onSignalingReady = () => {\n    this._log.info('Stream is ready');\n\n    this._setState(Device.State.Registered);\n  }\n\n  /**\n   * Publish a NetworkInformation#change event to Insights if there's an active {@link Call}.\n   */\n  private _publishNetworkChange = () => {\n    if (!this._activeCall) {\n      return;\n    }\n\n    if (this._networkInformation) {\n      this._publisher.info('network-information', 'network-change', {\n        connection_type: this._networkInformation.type,\n        downlink: this._networkInformation.downlink,\n        downlinkMax: this._networkInformation.downlinkMax,\n        effective_type: this._networkInformation.effectiveType,\n        rtt: this._networkInformation.rtt,\n      }, this._activeCall);\n    }\n  }\n\n  /**\n   * Remove a {@link Call} from device.calls by reference\n   * @param call\n   */\n  private _removeCall(call: Call): void {\n    if (this._activeCall === call) {\n      this._activeCall = null;\n    }\n\n    for (let i = this._calls.length - 1; i >= 0; i--) {\n      if (call === this._calls[i]) {\n        this._calls.splice(i, 1);\n      }\n    }\n  }\n\n  /**\n   * Register with the signaling server.\n   */\n  private async _sendPresence(presence: boolean): Promise<void> {\n    const stream = await this._streamConnectedPromise;\n\n    if (!stream) { return; }\n\n    stream.register({ audio: presence });\n    if (presence) {\n      this._startRegistrationTimer();\n    } else {\n      this._stopRegistrationTimer();\n    }\n  }\n\n  /**\n   * Helper function that sets and emits the state of the device.\n   * @param state The new state of the device.\n   */\n   private _setState(state: Device.State): void {\n    if (state === this.state) {\n      return;\n    }\n\n    this._state = state;\n    this.emit(this._stateEventMapping[state]);\n  }\n\n  /**\n   * Set up an audio helper for usage by this {@link Device}.\n   */\n  private _setupAudioHelper(): void {\n    if (this._audio) {\n      this._log.info('Found existing audio helper; destroying...');\n      this._destroyAudioHelper();\n    }\n\n    this._audio = new (this._options.AudioHelper || AudioHelper)(\n      this._updateSinkIds,\n      this._updateInputStream,\n      getUserMedia,\n      {\n        audioContext: Device.audioContext,\n        enabledSounds: this._enabledSounds,\n      },\n    );\n\n    this._audio.on('deviceChange', (lostActiveDevices: MediaDeviceInfo[]) => {\n      const activeCall: Call | null = this._activeCall;\n      const deviceIds: string[] = lostActiveDevices.map((device: MediaDeviceInfo) => device.deviceId);\n\n      this._publisher.info('audio', 'device-change', {\n        lost_active_device_ids: deviceIds,\n      }, activeCall);\n\n      if (activeCall) {\n        activeCall['_mediaHandler']._onInputDevicesChanged();\n      }\n    });\n  }\n\n  /**\n   * Create and set a publisher for the {@link Device} to use.\n   */\n  private _setupPublisher(): IPublisher {\n    if (this._publisher) {\n      this._log.info('Found existing publisher; destroying...');\n      this._destroyPublisher();\n    }\n\n    const publisherOptions = {\n      defaultPayload: this._createDefaultPayload,\n      log: this._log,\n      metadata: {\n        app_name: this._options.appName,\n        app_version: this._options.appVersion,\n      },\n    } as any;\n\n    if (this._options.eventgw) {\n      publisherOptions.host = this._options.eventgw;\n    }\n\n    this._publisher = new (this._options.Publisher || Publisher)(PUBLISHER_PRODUCT_NAME, this.token, publisherOptions);\n\n    if (this._options.publishEvents === false) {\n      this._publisher.disable();\n    } else {\n      this._publisher.on('error', (error: Error) => {\n        this._log.warn('Cannot connect to insights.', error);\n      });\n    }\n\n    return this._publisher;\n  }\n\n  /**\n   * Set up the connection to the signaling server. Tears down an existing\n   * stream if called while a stream exists.\n   */\n  private _setupStream(): Promise<IPStream> {\n    if (this._stream) {\n      this._log.info('Found existing stream; destroying...');\n      this._destroyStream();\n    }\n\n    this._log.info('Setting up VSP');\n    this._stream = new (this._options.PStream || PStream)(\n      this.token,\n      this._chunderURIs,\n      {\n        backoffMaxMs: this._options.backoffMaxMs,\n        maxPreferredDurationMs: this._options.maxCallSignalingTimeoutMs,\n      },\n    );\n\n    this._stream.addListener('close', this._onSignalingClose);\n    this._stream.addListener('connected', this._onSignalingConnected);\n    this._stream.addListener('error', this._onSignalingError);\n    this._stream.addListener('invite', this._onSignalingInvite);\n    this._stream.addListener('offline', this._onSignalingOffline);\n    this._stream.addListener('ready', this._onSignalingReady);\n\n    return this._streamConnectedPromise = new Promise<IPStream>(resolve =>\n      this._stream.once('connected', () => {\n        resolve(this._stream);\n      }),\n    );\n  }\n\n  /**\n   * Start playing the incoming ringtone, and subsequently emit the incoming event.\n   * @param call\n   * @param play - The function to be used to play the sound. Must return a Promise.\n   */\n  private _showIncomingCall(call: Call, play: Function): Promise<void> {\n    let timeout: NodeJS.Timer;\n    return Promise.race([\n      play(),\n      new Promise((resolve, reject) => {\n        timeout = setTimeout(() => {\n          const msg = 'Playing incoming ringtone took too long; it might not play. Continuing execution...';\n          reject(new Error(msg));\n        }, RINGTONE_PLAY_TIMEOUT);\n      }),\n    ]).catch(reason => {\n      this._log.info(reason.message);\n    }).then(() => {\n      clearTimeout(timeout);\n      this.emit(Device.EventName.Incoming, call);\n    });\n  }\n\n  /**\n   * Set a timeout to send another register message to the signaling server.\n   */\n  private _startRegistrationTimer(): void {\n    this._stopRegistrationTimer();\n    this._regTimer = setTimeout(() => {\n      this._sendPresence(true);\n    }, REGISTRATION_INTERVAL);\n  }\n\n  /**\n   * Stop sending registration messages to the signaling server.\n   */\n  private _stopRegistrationTimer(): void {\n    if (this._regTimer) {\n      clearTimeout(this._regTimer);\n    }\n  }\n\n  /**\n   * Throw an error if the {@link Device} is destroyed.\n   */\n  private _throwIfDestroyed(): void {\n    if (this.state === Device.State.Destroyed) {\n      throw new InvalidStateError('Device has been destroyed.');\n    }\n  }\n\n  /**\n   * Update the input stream being used for calls so that any current call and all future calls\n   * will use the new input stream.\n   * @param inputStream\n   */\n  private _updateInputStream = (inputStream: MediaStream | null): Promise<void> => {\n    const call: Call | null = this._activeCall;\n\n    if (call && !inputStream) {\n      return Promise.reject(new InvalidStateError('Cannot unset input device while a call is in progress.'));\n    }\n\n    this._callInputStream = inputStream;\n    return call\n      ? call._setInputTracksFromStream(inputStream)\n      : Promise.resolve();\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the incoming ringtone through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateRingtoneSinkIds(sinkIds: string[]): Promise<void> {\n    return Promise.resolve(this._soundcache.get(Device.SoundName.Incoming).setSinkIds(sinkIds));\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play sounds through.\n   * @param type - Whether to update ringtone or speaker sounds\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSinkIds = (type: 'ringtone' | 'speaker', sinkIds: string[]): Promise<void> => {\n    const promise: Promise<void> = type === 'ringtone'\n      ? this._updateRingtoneSinkIds(sinkIds)\n      : this._updateSpeakerSinkIds(sinkIds);\n\n    return promise.then(() => {\n      this._publisher.info('audio', `${type}-devices-set`, {\n        audio_device_ids: sinkIds,\n      }, this._activeCall);\n    }, error => {\n      this._publisher.error('audio', `${type}-devices-set-failed`, {\n        audio_device_ids: sinkIds,\n        message: error.message,\n      }, this._activeCall);\n\n      throw error;\n    });\n  }\n\n  /**\n   * Update the device IDs of output devices being used to play the non-ringtone sounds\n   * and Call audio through.\n   * @param sinkIds - An array of device IDs\n   */\n  private _updateSpeakerSinkIds(sinkIds: string[]): Promise<void> {\n    Array.from(this._soundcache.entries())\n      .filter(entry => entry[0] !== Device.SoundName.Incoming)\n      .forEach(entry => entry[1].setSinkIds(sinkIds));\n\n    this._callSinkIds = sinkIds;\n    const call = this._activeCall;\n    return call\n      ? call._setSinkIds(sinkIds)\n      : Promise.resolve();\n  }\n}\n\nnamespace Device {\n  /**\n   * Emitted when the {@link Device} receives an error.\n   * @param error\n   * @example `device.on('error', call => { })`\n   * @event\n   */\n  declare function errorEvent(error: TwilioError, call?: Call): void;\n\n  /**\n   * Emitted when an incoming {@link Call} is received.\n   * @param call - The incoming {@link Call}.\n   * @example `device.on('incoming', call => { })`\n   * @event\n   */\n  declare function incomingEvent(call: Call): void;\n\n  /**\n   * Emitted when the {@link Device} is unregistered.\n   * @param device\n   * @example `device.on('unregistered', device => { })`\n   * @event\n   */\n  declare function unregisteredEvent(device: Device): void;\n\n  /**\n   * Emitted when the {@link Device} is registering.\n   * @param device\n   * @example `device.on('registering', device => { })`\n   * @event\n   */\n  declare function registeringEvent(device: Device): void;\n\n  /**\n   * Emitted when the {@link Device} is registered.\n   * @param device\n   * @example `device.on('registered', device => { })`\n   * @event\n   */\n  declare function registeredEvent(device: Device): void;\n\n  /**\n   * Emitted when the {@link Device}'s token is about to expire. Use DeviceOptions.refreshTokenMs\n   * to set a custom warning time. Default is 10000 (10 seconds) prior to the token expiring.\n   * @example `device.on('tokenWillExpire', () => {\n   *   const token = getNewTokenViaAjax();\n   *   device.updateToken(token);\n   * })`\n   * @event\n   */\n  declare function tokenWillExpireEvent(device: Device): void;\n\n  /**\n   * All valid {@link Device} event names.\n   */\n  export enum EventName {\n    Error = 'error',\n    Incoming = 'incoming',\n    Destroyed = 'destroyed',\n    Unregistered = 'unregistered',\n    Registering = 'registering',\n    Registered = 'registered',\n    TokenWillExpire = 'tokenWillExpire',\n  }\n\n  /**\n   * All possible {@link Device} states.\n   */\n  export enum State {\n    Destroyed = 'destroyed',\n    Unregistered = 'unregistered',\n    Registering = 'registering',\n    Registered = 'registered',\n  }\n\n  /**\n   * Names of all sounds handled by the {@link Device}.\n   */\n  export enum SoundName {\n    Incoming = 'incoming',\n    Outgoing = 'outgoing',\n    Disconnect = 'disconnect',\n    Dtmf0 = 'dtmf0',\n    Dtmf1 = 'dtmf1',\n    Dtmf2 = 'dtmf2',\n    Dtmf3 = 'dtmf3',\n    Dtmf4 = 'dtmf4',\n    Dtmf5 = 'dtmf5',\n    Dtmf6 = 'dtmf6',\n    Dtmf7 = 'dtmf7',\n    Dtmf8 = 'dtmf8',\n    Dtmf9 = 'dtmf9',\n    DtmfS = 'dtmfs',\n    DtmfH = 'dtmfh',\n  }\n\n  /**\n   * Names of all togglable sounds.\n   */\n  export type ToggleableSound = Device.SoundName.Incoming | Device.SoundName.Outgoing | Device.SoundName.Disconnect;\n\n  /**\n   * Options to be passed to {@link Device.connect}.\n   */\n  export interface ConnectOptions extends Call.AcceptOptions {\n   /**\n    * A flat object containing key:value pairs to be sent to the TwiML app.\n    */\n    params?: Record<string, string>;\n  }\n\n  /**\n   * Options that may be passed to the {@link Device} constructor, or Device.setup via public API\n   */\n  export interface Options {\n    /**\n     * Whether the Device should raise the {@link incomingEvent} event when a new call invite is\n     * received while already on an active call. Default behavior is false.\n     */\n    allowIncomingWhileBusy?: boolean;\n\n    /**\n     * A name for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific application, particularly in the case where\n     * one account may be connected to by multiple applications.\n     */\n    appName?: string;\n\n    /**\n     * A version for the application that is instantiating the {@link Device}. This is used to improve logging\n     * in Insights by associating Insights data with a specific version of the given application. This can help\n     * track down when application-level bugs were introduced.\n     */\n    appVersion?: string;\n\n    /**\n     * Whether to enable close protection, to prevent users from accidentally\n     * navigating away from the page during a call. If string, the value will\n     * be used as a custom message.\n     */\n    closeProtection?: boolean | string;\n\n    /**\n     * An ordered array of codec names, from most to least preferred.\n     */\n    codecPreferences?: Call.Codec[];\n\n    /**\n     * Whether AudioContext sounds should be disabled. Useful for trouble shooting sound issues\n     * that may be caused by AudioContext-specific sounds. If set to true, will fall back to\n     * HTMLAudioElement sounds.\n     */\n    disableAudioContextSounds?: boolean;\n\n    /**\n     * Whether to use googDscp in RTC constraints.\n     */\n    dscp?: boolean;\n\n    /**\n     * The edge value corresponds to the geographic location that the client\n     * will use to connect to Twilio infrastructure. The default value is\n     * \"roaming\" which automatically selects an edge based on the latency of the\n     * client relative to available edges.\n     */\n    edge?: string[] | string;\n\n    /**\n     * Experimental feature.\n     * Whether to use ICE Aggressive nomination.\n     */\n    forceAggressiveIceNomination?: boolean;\n\n    /**\n     * Log level.\n     */\n    logLevel?: LogLevelDesc;\n\n    /**\n     * The maximum average audio bitrate to use, in bits per second (bps) based on\n     * [RFC-7587 7.1](https://tools.ietf.org/html/rfc7587#section-7.1). By default, the setting\n     * is not used. If you specify 0, then the setting is not used. Any positive integer is allowed,\n     * but values outside the range 6000 to 510000 are ignored and treated as 0. The recommended\n     * bitrate for speech is between 8000 and 40000 bps as noted in\n     * [RFC-7587 3.1.1](https://tools.ietf.org/html/rfc7587#section-3.1.1).\n     */\n    maxAverageBitrate?: number;\n\n    /**\n     * The maximum duration to attempt to reconnect to a preferred URI.\n     * This is used by signaling reconnection in that during the existence of\n     * any call, edge-fallback is disabled until this length of time has\n     * elapsed.\n     *\n     * Using a value of 30000 as an example: while a call exists, the Device\n     * will attempt to reconnect to the edge that the call was established on\n     * for approximately 30 seconds. After the next failure to connect, the\n     * Device will use edge-fallback.\n     *\n     * This feature is opt-in, and will not work until a number greater than 0\n     * is explicitly specified within the Device options.\n     */\n    maxCallSignalingTimeoutMs?: number;\n\n    /**\n     * A mapping of custom sound URLs by sound name.\n     */\n    sounds?: Partial<Record<Device.SoundName, string>>;\n\n    /**\n     * Number of milliseconds fewer than the token's TTL to emit the tokenWillExpire event.\n     * Default is 10000 (10 seconds).\n     */\n    tokenRefreshMs?: number;\n  }\n}\n\nexport default Device;\n"]},"metadata":{},"sourceType":"script"}