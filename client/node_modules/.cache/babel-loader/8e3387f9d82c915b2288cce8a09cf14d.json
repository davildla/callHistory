{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/* eslint-disable no-fallthrough */\n\n\nvar _a = require('../errors'),\n    NotSupportedError = _a.NotSupportedError,\n    InvalidArgumentError = _a.InvalidArgumentError;\n\nvar MockRTCStatsReport = require('./mockrtcstatsreport');\n\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\n\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  var promise;\n\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(function (resolve) {\n      return peerConnection.getStats(resolve);\n    }).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\n\n\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample: createRTCSample\n  }, options);\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\n\n\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then(function (report) {\n    // Find the relevant information needed to determine selected candidates later\n    var _a = Array.from(report.values()).reduce(function (rval, stat) {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n\n          break;\n      }\n\n      return rval;\n    }, {}),\n        candidatePairs = _a.candidatePairs,\n        localCandidates = _a.localCandidates,\n        remoteCandidates = _a.remoteCandidates,\n        transport = _a.transport; // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n\n\n    var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n      // Firefox\n      return pair.selected || // Spec-compliant way\n      transport && pair.id === transport.selectedCandidatePairId;\n    });\n    var selectedIceCandidatePairStats;\n\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.localCandidateId;\n        }),\n        remoteCandidate: remoteCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.remoteCandidateId;\n        })\n      };\n    } // Build the return object\n\n\n    return {\n      iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n      selectedIceCandidatePairStats: selectedIceCandidatePairStats\n    };\n  });\n}\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\n\n\nfunction RTCSample() {}\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\n\n\nfunction createRTCSample(statsReport) {\n  var activeTransportId = null;\n  var sample = new RTCSample();\n  var fallbackTimestamp;\n  Array.from(statsReport.values()).forEach(function (stats) {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) {\n      return;\n    } // Firefox hack -- Older firefox doesn't have dashes in type names\n\n\n    var type = stats.type.replace('-', '');\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp; // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n\n    if (stats.remoteId) {\n      var remote = statsReport.get(stats.remoteId);\n\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n        break;\n\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          var codec = statsReport.get(stats.codecId);\n          sample.codecName = codec ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2] : stats.codecId;\n        }\n\n        break;\n\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  var activeTransport = statsReport.get(activeTransportId);\n\n  if (!activeTransport) {\n    return sample;\n  }\n\n  var selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n\n  if (!selectedCandidatePair) {\n    return sample;\n  }\n\n  var localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n  var remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair && selectedCandidatePair.currentRoundTripTime * 1000;\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip\n  });\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats: getRTCStats,\n  getRTCIceCandidateStatsReport: getRTCIceCandidateStatsReport\n};","map":{"version":3,"mappings":"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","names":["NotSupportedError","InvalidArgumentError","MockRTCStatsReport","require","ERROR_PEER_CONNECTION_NULL","ERROR_WEB_RTC_UNSUPPORTED","getRTCStatsReport","peerConnection","Promise","reject","getStats","promise","e","resolve","then","fromRTCStatsResponse","getRTCStats","options","Object","assign","createRTCSample","getRTCIceCandidateStatsReport","report","candidatePairs","localCandidates","remoteCandidates","transport","selectedCandidatePairReport","find","selected","pair","id","selectedCandidatePairId","selectedIceCandidatePairStats","localCandidate","localCandidateId","remoteCandidate","remoteCandidateId","iceCandidateStats","RTCSample","statsReport","activeTransportId","sample","fallbackTimestamp","Array","from","values","forEach","stats","isRemote","type","replace","timestamp","remoteId","remote","get","roundTripTime","rtt","jitter","packetsLost","packetsReceived","bytesReceived","packetsSent","bytesSent","codecId","codec","codecName","mimeType","match","activeTransport","selectedCandidatePair","currentRoundTripTime","localAddress","ip","remoteAddress","module","exports"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/rtc/stats.js"],"sourcesContent":["/* eslint-disable no-fallthrough */\nconst { NotSupportedError, InvalidArgumentError } = require('../errors');\nconst MockRTCStatsReport = require('./mockrtcstatsreport');\n\nconst ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nconst ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  let promise;\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(resolve => peerConnection.getStats(resolve)).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample\n  }, options);\n\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then((report) => {\n    // Find the relevant information needed to determine selected candidates later\n    const {\n      candidatePairs, localCandidates, remoteCandidates, transport,\n    } = Array.from(report.values()).reduce((rval, stat) => {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach((prop) => {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n          break;\n      }\n\n      return rval;\n    }, {});\n\n    // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n    const selectedCandidatePairReport = candidatePairs.find(pair =>\n      // Firefox\n      pair.selected ||\n      // Spec-compliant way\n      (transport && pair.id === transport.selectedCandidatePairId)\n    );\n\n    let selectedIceCandidatePairStats;\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(candidate => candidate.id === selectedCandidatePairReport.localCandidateId),\n        remoteCandidate: remoteCandidates.find(candidate => candidate.id === selectedCandidatePairReport.remoteCandidateId),\n      };\n    }\n\n    // Build the return object\n    return {\n      iceCandidateStats: [...localCandidates, ...remoteCandidates],\n      selectedIceCandidatePairStats,\n    };\n  });\n}\n\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\nfunction RTCSample() { }\n\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\nfunction createRTCSample(statsReport) {\n  let activeTransportId = null;\n  const sample = new RTCSample();\n  let fallbackTimestamp;\n\n  Array.from(statsReport.values()).forEach(stats => {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) { return; }\n\n    // Firefox hack -- Older firefox doesn't have dashes in type names\n    const type = stats.type.replace('-', '');\n\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp;\n\n    // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n    if (stats.remoteId) {\n      const remote = statsReport.get(stats.remoteId);\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n\n        break;\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          const codec = statsReport.get(stats.codecId);\n          sample.codecName = codec\n            ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2]\n            : stats.codecId;\n        }\n\n        break;\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  const activeTransport = statsReport.get(activeTransportId);\n  if (!activeTransport) { return sample; }\n\n  const selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n  if (!selectedCandidatePair) { return sample; }\n\n  const localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n  const remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair &&\n      (selectedCandidatePair.currentRoundTripTime * 1000);\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip,\n  });\n\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats,\n  getRTCIceCandidateStatsReport,\n};\n"]},"metadata":{},"sourceType":"script"}