{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar DEFAULT_TEST_SOUND_URL = constants_1.SOUNDS_BASE_URL + \"/outgoing.mp3\";\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\n\nvar OutputDeviceCollection =\n/** @class */\nfunction () {\n  /**\n   * @private\n   */\n  function OutputDeviceCollection(_name, _availableDevices, _beforeChange, _isSupported) {\n    this._name = _name;\n    this._availableDevices = _availableDevices;\n    this._beforeChange = _beforeChange;\n    this._isSupported = _isSupported;\n    /**\n     * The currently active output devices.\n     */\n\n    this._activeDevices = new Set();\n  }\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n\n\n  OutputDeviceCollection.prototype.delete = function (device) {\n    var wasDeleted = !!this._activeDevices.delete(device);\n    var defaultDevice = this._availableDevices.get('default') || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    } // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n\n\n    var deviceIds = Array.from(this._activeDevices.values()).map(function (deviceInfo) {\n      return deviceInfo.deviceId;\n    });\n\n    this._beforeChange(this._name, deviceIds);\n\n    return !!wasDeleted;\n  };\n  /**\n   * Get the current set of devices.\n   */\n\n\n  OutputDeviceCollection.prototype.get = function () {\n    return this._activeDevices;\n  };\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n\n\n  OutputDeviceCollection.prototype.set = function (deviceIdOrIds) {\n    var _this = this;\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    var deviceIds = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    var missingIds = [];\n    var devices = deviceIds.map(function (id) {\n      var device = _this._availableDevices.get(id);\n\n      if (!device) {\n        missingIds.push(id);\n      }\n\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Devices not found: \" + missingIds.join(', ')));\n    }\n\n    return new Promise(function (resolve) {\n      resolve(_this._beforeChange(_this._name, deviceIds));\n    }).then(function () {\n      _this._activeDevices.clear();\n\n      devices.forEach(_this._activeDevices.add, _this._activeDevices);\n    });\n  };\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n\n\n  OutputDeviceCollection.prototype.test = function (soundUrl) {\n    if (soundUrl === void 0) {\n      soundUrl = DEFAULT_TEST_SOUND_URL;\n    }\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new errors_1.InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map(function (device) {\n      var el; // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n\n      return new Promise(function (resolve) {\n        el = new Audio(soundUrl);\n        el.oncanplay = resolve;\n      }).then(function () {\n        return el.setSinkId(device.deviceId).then(function () {\n          return el.play();\n        });\n      });\n    }));\n  };\n\n  return OutputDeviceCollection;\n}();\n\nexports.default = OutputDeviceCollection;","map":{"version":3,"mappings":"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","names":["DEFAULT_TEST_SOUND_URL","constants_1","_name","_availableDevices","_beforeChange","_isSupported","Set","OutputDeviceCollection","device","wasDeleted","_activeDevices","delete","defaultDevice","get","Array","from","values","size","add","deviceIds","map","deviceId","deviceIdOrIds","Promise","reject","errors_1","isArray","length","missingIds","devices","id","_this","push","join","resolve","then","clear","forEach","soundUrl","all","el","Audio","oncanplay","setSinkId","play"],"sources":["/home/david/Desktop/workSpace/bots-dashboard/node_modules/@twilio/voice-sdk/lib/twilio/outputdevicecollection.ts"],"sourcesContent":["/**\n * @packageDocumentation\n * @module Voice\n */\nimport { SOUNDS_BASE_URL } from './constants';\nimport { InvalidArgumentError, InvalidStateError, NotSupportedError } from './errors';\nconst DEFAULT_TEST_SOUND_URL = `${SOUNDS_BASE_URL}/outgoing.mp3`;\n\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\nexport default class OutputDeviceCollection {\n  /**\n   * The currently active output devices.\n   */\n  private _activeDevices: Set<MediaDeviceInfo> = new Set();\n\n  /**\n   * @private\n   */\n  constructor(private _name: string,\n              private _availableDevices: Map<string, MediaDeviceInfo>,\n              private _beforeChange: (name: string, devices: string[]) => Promise<void>,\n              private _isSupported: boolean) { }\n\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n  delete(device: MediaDeviceInfo): boolean {\n    const wasDeleted: boolean = !!(this._activeDevices.delete(device));\n\n    const defaultDevice: MediaDeviceInfo = this._availableDevices.get('default')\n      || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    }\n\n    // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n    const deviceIds = Array.from(this._activeDevices.values()).map(deviceInfo => deviceInfo.deviceId);\n\n    this._beforeChange(this._name, deviceIds);\n    return !!wasDeleted;\n  }\n\n  /**\n   * Get the current set of devices.\n   */\n  get(): Set<MediaDeviceInfo> {\n    return this._activeDevices;\n  }\n\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n  set(deviceIdOrIds: string | string[]): Promise<void> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    const deviceIds: string[] = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    const missingIds: string[] = [];\n    const devices: Array<MediaDeviceInfo | undefined> = deviceIds.map((id: string) => {\n      const device: MediaDeviceInfo | undefined = this._availableDevices.get(id);\n      if (!device) { missingIds.push(id); }\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new InvalidArgumentError(`Devices not found: ${missingIds.join(', ')}`));\n    }\n\n    return new Promise(resolve => {\n      resolve(this._beforeChange(this._name, deviceIds));\n    }).then(() => {\n      this._activeDevices.clear();\n      devices.forEach(this._activeDevices.add, this._activeDevices);\n    });\n  }\n\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n  test(soundUrl: string = DEFAULT_TEST_SOUND_URL): Promise<any> {\n    if (!this._isSupported) {\n      return Promise.reject(new NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map((device: MediaDeviceInfo) => {\n      let el: HTMLAudioElement;\n\n      // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n      return new Promise((resolve: Function) => {\n        el = new Audio(soundUrl);\n        (el as any).oncanplay = resolve;\n      }).then(() => (el as any).setSinkId(device.deviceId).then(() => el.play()));\n    }));\n  }\n}\n"]},"metadata":{},"sourceType":"script"}