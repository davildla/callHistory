{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/**\n * @packageDocumentation\n * @module Voice\n */\n\nvar constants_1 = require(\"./constants\");\n\nvar errors_1 = require(\"./errors\");\n\nvar DEFAULT_TEST_SOUND_URL = constants_1.SOUNDS_BASE_URL + \"/outgoing.mp3\";\n/**\n * A smart collection containing a Set of active output devices.\n * @publicapi\n */\n\nvar OutputDeviceCollection =\n/** @class */\nfunction () {\n  /**\n   * @private\n   */\n  function OutputDeviceCollection(_name, _availableDevices, _beforeChange, _isSupported) {\n    this._name = _name;\n    this._availableDevices = _availableDevices;\n    this._beforeChange = _beforeChange;\n    this._isSupported = _isSupported;\n    /**\n     * The currently active output devices.\n     */\n\n    this._activeDevices = new Set();\n  }\n  /**\n   * Delete a device from the collection. If no devices remain, the 'default'\n   * device will be added as the sole device. If no `default` device exists,\n   * the first available device will be used.\n   * @param device - The device to delete from the collection\n   * @returns whether the device was present before it was deleted\n   */\n\n\n  OutputDeviceCollection.prototype.delete = function (device) {\n    var wasDeleted = !!this._activeDevices.delete(device);\n    var defaultDevice = this._availableDevices.get('default') || Array.from(this._availableDevices.values())[0];\n\n    if (!this._activeDevices.size && defaultDevice) {\n      this._activeDevices.add(defaultDevice);\n    } // Call _beforeChange so that the implementation can react when a device is\n    // removed or lost.\n\n\n    var deviceIds = Array.from(this._activeDevices.values()).map(function (deviceInfo) {\n      return deviceInfo.deviceId;\n    });\n\n    this._beforeChange(this._name, deviceIds);\n\n    return !!wasDeleted;\n  };\n  /**\n   * Get the current set of devices.\n   */\n\n\n  OutputDeviceCollection.prototype.get = function () {\n    return this._activeDevices;\n  };\n  /**\n   * Replace the current set of devices with a new set of devices.\n   * @param deviceIdOrIds - An ID or array of IDs of devices to replace the existing devices with.\n   * @returns Rejects if this feature is not supported, any of the supplied IDs are not found,\n   * or no IDs are passed.\n   */\n\n\n  OutputDeviceCollection.prototype.set = function (deviceIdOrIds) {\n    var _this = this;\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    var deviceIds = Array.isArray(deviceIdOrIds) ? deviceIdOrIds : [deviceIdOrIds];\n\n    if (!deviceIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError('Must specify at least one device to set'));\n    }\n\n    var missingIds = [];\n    var devices = deviceIds.map(function (id) {\n      var device = _this._availableDevices.get(id);\n\n      if (!device) {\n        missingIds.push(id);\n      }\n\n      return device;\n    });\n\n    if (missingIds.length) {\n      return Promise.reject(new errors_1.InvalidArgumentError(\"Devices not found: \" + missingIds.join(', ')));\n    }\n\n    return new Promise(function (resolve) {\n      resolve(_this._beforeChange(_this._name, deviceIds));\n    }).then(function () {\n      _this._activeDevices.clear();\n\n      devices.forEach(_this._activeDevices.add, _this._activeDevices);\n    });\n  };\n  /**\n   * Test the devices by playing audio through them.\n   * @param [soundUrl] - An optional URL. If none is specified, we will\n   *   play a default test tone.\n   * @returns Resolves with the result of the underlying HTMLAudioElements' play() calls.\n   */\n\n\n  OutputDeviceCollection.prototype.test = function (soundUrl) {\n    if (soundUrl === void 0) {\n      soundUrl = DEFAULT_TEST_SOUND_URL;\n    }\n\n    if (!this._isSupported) {\n      return Promise.reject(new errors_1.NotSupportedError('This browser does not support audio output selection'));\n    }\n\n    if (!this._activeDevices.size) {\n      return Promise.reject(new errors_1.InvalidStateError('No active output devices to test'));\n    }\n\n    return Promise.all(Array.from(this._activeDevices).map(function (device) {\n      var el; // (rrowland) We need to wait for the oncanplay event because of a regression introduced\n      // in Chrome M72: https://bugs.chromium.org/p/chromium/issues/detail?id=930876\n\n      return new Promise(function (resolve) {\n        el = new Audio(soundUrl);\n        el.oncanplay = resolve;\n      }).then(function () {\n        return el.setSinkId(device.deviceId).then(function () {\n          return el.play();\n        });\n      });\n    }));\n  };\n\n  return OutputDeviceCollection;\n}();\n\nexports.default = OutputDeviceCollection; //# sourceMappingURL=outputdevicecollection.js.map","map":null,"metadata":{},"sourceType":"script"}