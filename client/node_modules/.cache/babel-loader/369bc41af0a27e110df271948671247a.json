{"ast":null,"code":"var __spreadArrays = this && this.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];\n\n  return r;\n};\n/* eslint-disable no-fallthrough */\n\n\nvar _a = require('../errors'),\n    NotSupportedError = _a.NotSupportedError,\n    InvalidArgumentError = _a.InvalidArgumentError;\n\nvar MockRTCStatsReport = require('./mockrtcstatsreport');\n\nvar ERROR_PEER_CONNECTION_NULL = 'PeerConnection is null';\nvar ERROR_WEB_RTC_UNSUPPORTED = 'WebRTC statistics are unsupported';\n/**\n * Generate WebRTC statistics report for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCStatsReport>} WebRTC RTCStatsReport object\n */\n\nfunction getRTCStatsReport(peerConnection) {\n  if (!peerConnection) {\n    return Promise.reject(new InvalidArgumentError(ERROR_PEER_CONNECTION_NULL));\n  }\n\n  if (typeof peerConnection.getStats !== 'function') {\n    return Promise.reject(new NotSupportedError(ERROR_WEB_RTC_UNSUPPORTED));\n  }\n\n  var promise;\n\n  try {\n    promise = peerConnection.getStats();\n  } catch (e) {\n    promise = new Promise(function (resolve) {\n      return peerConnection.getStats(resolve);\n    }).then(MockRTCStatsReport.fromRTCStatsResponse);\n  }\n\n  return promise;\n}\n/**\n * @typedef {Object} StatsOptions\n * Used for testing to inject and extract methods.\n * @property {function} [createRTCSample] - Method for parsing an RTCStatsReport\n */\n\n/**\n * Collects any WebRTC statistics for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @param {StatsOptions} options - List of custom options.\n * @return {Promise<RTCSample>} Universally-formatted version of RTC stats.\n */\n\n\nfunction getRTCStats(peerConnection, options) {\n  options = Object.assign({\n    createRTCSample: createRTCSample\n  }, options);\n  return getRTCStatsReport(peerConnection).then(options.createRTCSample);\n}\n/**\n * Generate WebRTC stats report containing relevant information about ICE candidates for the given {@link PeerConnection}\n * @param {PeerConnection} peerConnection - Target connection.\n * @return {Promise<RTCIceCandidateStatsReport>} RTCIceCandidateStatsReport object\n */\n\n\nfunction getRTCIceCandidateStatsReport(peerConnection) {\n  return getRTCStatsReport(peerConnection).then(function (report) {\n    // Find the relevant information needed to determine selected candidates later\n    var _a = Array.from(report.values()).reduce(function (rval, stat) {\n      ['candidatePairs', 'localCandidates', 'remoteCandidates'].forEach(function (prop) {\n        if (!rval[prop]) {\n          rval[prop] = [];\n        }\n      });\n\n      switch (stat.type) {\n        case 'candidate-pair':\n          rval.candidatePairs.push(stat);\n          break;\n\n        case 'local-candidate':\n          rval.localCandidates.push(stat);\n          break;\n\n        case 'remote-candidate':\n          rval.remoteCandidates.push(stat);\n          break;\n\n        case 'transport':\n          // This transport is the one being used if selectedCandidatePairId is populated\n          if (stat.selectedCandidatePairId) {\n            rval.transport = stat;\n          }\n\n          break;\n      }\n\n      return rval;\n    }, {}),\n        candidatePairs = _a.candidatePairs,\n        localCandidates = _a.localCandidates,\n        remoteCandidates = _a.remoteCandidates,\n        transport = _a.transport; // This is a report containing information about the selected candidates, such as IDs\n    // This is coming from WebRTC stats directly and doesn't contain the actual ICE Candidates info\n\n\n    var selectedCandidatePairReport = candidatePairs.find(function (pair) {\n      // Firefox\n      return pair.selected || // Spec-compliant way\n      transport && pair.id === transport.selectedCandidatePairId;\n    });\n    var selectedIceCandidatePairStats;\n\n    if (selectedCandidatePairReport) {\n      selectedIceCandidatePairStats = {\n        localCandidate: localCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.localCandidateId;\n        }),\n        remoteCandidate: remoteCandidates.find(function (candidate) {\n          return candidate.id === selectedCandidatePairReport.remoteCandidateId;\n        })\n      };\n    } // Build the return object\n\n\n    return {\n      iceCandidateStats: __spreadArrays(localCandidates, remoteCandidates),\n      selectedIceCandidatePairStats: selectedIceCandidatePairStats\n    };\n  });\n}\n/**\n * @typedef {Object} RTCSample - A sample containing relevant WebRTC stats information.\n * @property {Number} [timestamp]\n * @property {String} [codecName] - MimeType name of the codec being used by the outbound audio stream\n * @property {Number} [rtt] - Round trip time\n * @property {Number} [jitter]\n * @property {Number} [packetsSent]\n * @property {Number} [packetsLost]\n * @property {Number} [packetsReceived]\n * @property {Number} [bytesReceived]\n * @property {Number} [bytesSent]\n * @property {Number} [localAddress]\n * @property {Number} [remoteAddress]\n */\n\n\nfunction RTCSample() {}\n/**\n * Create an RTCSample object from an RTCStatsReport\n * @private\n * @param {RTCStatsReport} statsReport\n * @returns {RTCSample}\n */\n\n\nfunction createRTCSample(statsReport) {\n  var activeTransportId = null;\n  var sample = new RTCSample();\n  var fallbackTimestamp;\n  Array.from(statsReport.values()).forEach(function (stats) {\n    // Skip isRemote tracks which will be phased out completely and break in FF66.\n    if (stats.isRemote) {\n      return;\n    } // Firefox hack -- Older firefox doesn't have dashes in type names\n\n\n    var type = stats.type.replace('-', '');\n    fallbackTimestamp = fallbackTimestamp || stats.timestamp; // (rrowland) As I understand it, this is supposed to come in on remote-inbound-rtp but it's\n    // currently coming in on remote-outbound-rtp, so I'm leaving this outside the switch until\n    // the appropriate place to look is cleared up.\n\n    if (stats.remoteId) {\n      var remote = statsReport.get(stats.remoteId);\n\n      if (remote && remote.roundTripTime) {\n        sample.rtt = remote.roundTripTime * 1000;\n      }\n    }\n\n    switch (type) {\n      case 'inboundrtp':\n        sample.timestamp = sample.timestamp || stats.timestamp;\n        sample.jitter = stats.jitter * 1000;\n        sample.packetsLost = stats.packetsLost;\n        sample.packetsReceived = stats.packetsReceived;\n        sample.bytesReceived = stats.bytesReceived;\n        break;\n\n      case 'outboundrtp':\n        sample.timestamp = stats.timestamp;\n        sample.packetsSent = stats.packetsSent;\n        sample.bytesSent = stats.bytesSent;\n\n        if (stats.codecId) {\n          var codec = statsReport.get(stats.codecId);\n          sample.codecName = codec ? codec.mimeType && codec.mimeType.match(/(.*\\/)?(.*)/)[2] : stats.codecId;\n        }\n\n        break;\n\n      case 'transport':\n        activeTransportId = stats.id;\n        break;\n    }\n  });\n\n  if (!sample.timestamp) {\n    sample.timestamp = fallbackTimestamp;\n  }\n\n  var activeTransport = statsReport.get(activeTransportId);\n\n  if (!activeTransport) {\n    return sample;\n  }\n\n  var selectedCandidatePair = statsReport.get(activeTransport.selectedCandidatePairId);\n\n  if (!selectedCandidatePair) {\n    return sample;\n  }\n\n  var localCandidate = statsReport.get(selectedCandidatePair.localCandidateId);\n  var remoteCandidate = statsReport.get(selectedCandidatePair.remoteCandidateId);\n\n  if (!sample.rtt) {\n    sample.rtt = selectedCandidatePair && selectedCandidatePair.currentRoundTripTime * 1000;\n  }\n\n  Object.assign(sample, {\n    localAddress: localCandidate && localCandidate.ip,\n    remoteAddress: remoteCandidate && remoteCandidate.ip\n  });\n  return sample;\n}\n\nmodule.exports = {\n  getRTCStats: getRTCStats,\n  getRTCIceCandidateStatsReport: getRTCIceCandidateStatsReport\n}; //# sourceMappingURL=stats.js.map","map":null,"metadata":{},"sourceType":"script"}